Title: BazelCon 2019 Day 1: Selective Testing + Q&A
Publication date: 2020-01-09
Playlist: BazelCon 2019
Description: 
	Benjamin Peterson, Dropbox event: Bazelcon 2019; re_ty: Publish; product: Open Source - General; fullname: Benjamin Peterson;
Captions: 
	00:00:00,000 --> 00:00:04,680
right so next up is Benjamin from from

00:00:03,240 --> 00:00:14,670
der box and he'll talk about test

00:00:04,680 --> 00:00:16,410
selection greetings salutations hi it's

00:00:14,670 --> 00:00:19,619
great to see all of you here this

00:00:16,410 --> 00:00:23,240
afternoon I have to be here it seems

00:00:19,619 --> 00:00:25,949
like we find ourselves back in sunny Val

00:00:23,240 --> 00:00:28,590
Sunnyvale of course is America's

00:00:25,949 --> 00:00:31,590
corporate campus capital with

00:00:28,590 --> 00:00:34,170
representatives from all of the nation's

00:00:31,590 --> 00:00:37,800
most ethically tainted industries

00:00:34,170 --> 00:00:40,829
but despite the sense of anomie and

00:00:37,800 --> 00:00:43,290
white-collar alienation pervading the

00:00:40,829 --> 00:00:47,730
place this venue is quite an upgrade for

00:00:43,290 --> 00:00:49,440
for basil Kahn you know maybe it's a a

00:00:47,730 --> 00:00:51,780
reflection of our rising status a

00:00:49,440 --> 00:00:55,520
community maybe once you do 1.0 you get

00:00:51,780 --> 00:00:55,520
to use the grown-ups conference center

00:00:56,090 --> 00:01:01,739
but I say that if this is your first

00:00:59,609 --> 00:01:02,940
basil Kahn you missed the experience of

00:01:01,739 --> 00:01:06,030
attending a conference held in this

00:01:02,940 --> 00:01:07,799
shoebox I know a whole lot less this

00:01:06,030 --> 00:01:15,119
year about how my fellow basil

00:01:07,799 --> 00:01:18,360
enthusiasts smell so I hide Benjamin my

00:01:15,119 --> 00:01:20,220
name is Benjamin and I put food on the

00:01:18,360 --> 00:01:23,280
table these days by working for a

00:01:20,220 --> 00:01:25,740
company called Dropbox specifically I

00:01:23,280 --> 00:01:29,100
work on Dropbox's development

00:01:25,740 --> 00:01:30,829
infrastructure team and we responsible

00:01:29,100 --> 00:01:33,720
for all the tools continuous integration

00:01:30,829 --> 00:01:36,210
build stuff that Dropbox engineers use

00:01:33,720 --> 00:01:38,549
to get their job done and we've been

00:01:36,210 --> 00:01:40,340
using basil for quite a while now about

00:01:38,549 --> 00:01:43,439
four years since it was originally

00:01:40,340 --> 00:01:45,810
became open-source I would say that we'd

00:01:43,439 --> 00:01:48,000
been using it before it was cool except

00:01:45,810 --> 00:01:50,490
I think that still today build systems

00:01:48,000 --> 00:01:52,740
occupy a level of glamour and cultural

00:01:50,490 --> 00:01:56,040
cachet that is somewhere between like

00:01:52,740 --> 00:02:00,210
dentures and latex gloves so I want I

00:01:56,040 --> 00:02:02,159
won't make that claim so but anyway

00:02:00,210 --> 00:02:06,689
we've had over the years the opportunity

00:02:02,159 --> 00:02:10,709
to accumulate a lot of successes and

00:02:06,689 --> 00:02:13,560
Titanic failures building tooling around

00:02:10,709 --> 00:02:15,480
Basel and we've talked about it the last

00:02:13,560 --> 00:02:17,250
- basil cons so we talked about

00:02:15,480 --> 00:02:20,340
generating build files and we talked

00:02:17,250 --> 00:02:23,160
about integration testing with basil so

00:02:20,340 --> 00:02:25,800
I go look up those if you want to hear

00:02:23,160 --> 00:02:27,780
about those topics and we also just

00:02:25,800 --> 00:02:30,900
yesterday we released a bunch of our

00:02:27,780 --> 00:02:34,080
basil related tooling on github so the

00:02:30,900 --> 00:02:36,599
URL is right there you can go and find

00:02:34,080 --> 00:02:38,580
it uh so this is our build file

00:02:36,599 --> 00:02:41,220
generator our integration testing

00:02:38,580 --> 00:02:44,130
framework and also our Python rules so

00:02:41,220 --> 00:02:47,489
we can probably do something for your

00:02:44,130 --> 00:02:50,790
Python problems if if you are willing to

00:02:47,489 --> 00:02:53,370
do things our way but that's not not

00:02:50,790 --> 00:02:57,390
really the topic of this talk we also

00:02:53,370 --> 00:03:00,930
put up a blog post a on our tech blog

00:02:57,390 --> 00:03:04,560
about how we integrate basil in our CI

00:03:00,930 --> 00:03:06,090
system if it has a long URL which I

00:03:04,560 --> 00:03:08,220
didn't bother to put up there but if you

00:03:06,090 --> 00:03:10,769
go I'm sure you'll be able to find it

00:03:08,220 --> 00:03:16,769
if you stick Dropbox tech blob in

00:03:10,769 --> 00:03:18,480
DuckDuckGo I mean Google all right so we

00:03:16,769 --> 00:03:21,540
like basil because of its scalability

00:03:18,480 --> 00:03:23,640
it's focused on hermeticity and

00:03:21,540 --> 00:03:29,160
reproducibility and I and because it

00:03:23,640 --> 00:03:31,739
tastes great on pasta and pizza but I

00:03:29,160 --> 00:03:33,480
have a more personal reason for really

00:03:31,739 --> 00:03:35,730
liking basil and that is that it

00:03:33,480 --> 00:03:44,340
contains my favorite java method

00:03:35,730 --> 00:03:48,959
definition ever right right so so so so

00:03:44,340 --> 00:03:51,959
so so verbosity is is the standard in

00:03:48,959 --> 00:03:54,239
java naming of course right but in in

00:03:51,959 --> 00:03:57,030
this case the pasta kind of fuss to

00:03:54,239 --> 00:03:59,160
Cates more than more than enlightens and

00:03:57,030 --> 00:04:02,190
so there's 10 words in this method name

00:03:59,160 --> 00:04:06,000
five of them are unique the word for two

00:04:02,190 --> 00:04:07,459
appears four times and after thinking a

00:04:06,000 --> 00:04:09,959
long time doing a lot of nail-biting

00:04:07,459 --> 00:04:11,790
consulting with talk top linguistics

00:04:09,959 --> 00:04:13,290
experts I've come to the conclusions of

00:04:11,790 --> 00:04:15,660
the way you should segment this method

00:04:13,290 --> 00:04:19,320
name is convert library to linked list

00:04:15,660 --> 00:04:21,539
to library the link list now that's

00:04:19,320 --> 00:04:24,030
still a little confusing right because

00:04:21,539 --> 00:04:25,680
if you ignore the fact that the argument

00:04:24,030 --> 00:04:27,500
to this function as a set rather than

00:04:25,680 --> 00:04:29,060
the list it still sees

00:04:27,500 --> 00:04:32,360
functions not be doing anything right

00:04:29,060 --> 00:04:34,040
but everything becomes clear if you

00:04:32,360 --> 00:04:36,950
notice that there's actually two classes

00:04:34,040 --> 00:04:38,930
called library to link right there's the

00:04:36,950 --> 00:04:41,030
library to link package level class and

00:04:38,930 --> 00:04:45,200
the nested class of linker inputs

00:04:41,030 --> 00:04:49,100
alright so this is this brings a smile

00:04:45,200 --> 00:04:50,600
to my face every time I do a build and

00:04:49,100 --> 00:04:53,450
you can think about what's inside next

00:04:50,600 --> 00:04:54,710
time you're ready to build - and I I

00:04:53,450 --> 00:04:57,200
could probably give a whole talk about

00:04:54,710 --> 00:04:59,540
the hidden gems of basil but

00:04:57,200 --> 00:05:01,400
unfortunately that is not this top and

00:04:59,540 --> 00:05:06,500
we're best getting back to the actual

00:05:01,400 --> 00:05:08,540
topic of this talk and to do that I'd

00:05:06,500 --> 00:05:12,040
like to introduce a kind of framing

00:05:08,540 --> 00:05:14,180
story an overall problem for this talk

00:05:12,040 --> 00:05:16,730
there's a lot of problems in this talk

00:05:14,180 --> 00:05:18,800
as you'll see and that is what I'm going

00:05:16,730 --> 00:05:21,470
to call the selection problem and here

00:05:18,800 --> 00:05:23,720
are the contours of that problem so I

00:05:21,470 --> 00:05:27,910
run a continuing issue in continuous

00:05:23,720 --> 00:05:30,740
integration system and I Dropbox has

00:05:27,910 --> 00:05:33,010
millions of lines of code and thousands

00:05:30,740 --> 00:05:36,760
of primates making changes to this code

00:05:33,010 --> 00:05:40,550
sometimes they even write tests and so

00:05:36,760 --> 00:05:42,680
the the continuous integration system is

00:05:40,550 --> 00:05:47,000
exposed to these proposed changes in

00:05:42,680 --> 00:05:49,700
several forms so pre pre review testing

00:05:47,000 --> 00:05:52,700
code tests on code reviews pre submit

00:05:49,700 --> 00:05:56,930
tests and tests after a change has

00:05:52,700 --> 00:05:59,210
actually landed and every time the CI

00:05:56,930 --> 00:06:04,430
system sees a test I has to decide what

00:05:59,210 --> 00:06:06,169
tests to run and in particular we want

00:06:04,430 --> 00:06:11,720
to run the tests which are most useful

00:06:06,169 --> 00:06:14,120
for engineers to be seeing the results

00:06:11,720 --> 00:06:16,340
for for a particular change and one kind

00:06:14,120 --> 00:06:18,200
of logically obvious thing is that we

00:06:16,340 --> 00:06:21,800
should only run tests that can possibly

00:06:18,200 --> 00:06:23,600
be affected by a change and so kind of

00:06:21,800 --> 00:06:25,760
in basil terminology that means we

00:06:23,600 --> 00:06:27,650
should only be running tests that have a

00:06:25,760 --> 00:06:30,290
transitive dependency on files that were

00:06:27,650 --> 00:06:32,390
modified in a particular change so this

00:06:30,290 --> 00:06:35,030
talk is going to be focusing on testing

00:06:32,390 --> 00:06:36,830
but this idea of selecting targets

00:06:35,030 --> 00:06:39,320
computing the targets that are affected

00:06:36,830 --> 00:06:41,300
by a particular change has other uses -

00:06:39,320 --> 00:06:43,879
for example you can do things

00:06:41,300 --> 00:06:45,800
I only deploy binaries which have

00:06:43,879 --> 00:06:48,520
actually changed over a series of

00:06:45,800 --> 00:06:51,440
commits and generate custom change logs

00:06:48,520 --> 00:06:53,180
from an overall change log for just the

00:06:51,440 --> 00:06:58,849
changes that affected a particular

00:06:53,180 --> 00:07:00,409
target all right so if we first see this

00:06:58,849 --> 00:07:02,960
problem we might think well what's the

00:07:00,409 --> 00:07:06,199
problem why don't we just do this you

00:07:02,960 --> 00:07:09,470
know run basil test over our entire

00:07:06,199 --> 00:07:11,930
workspace and as we've seen several

00:07:09,470 --> 00:07:15,099
times before in this conference on you

00:07:11,930 --> 00:07:17,990
probably know as a basil user basil will

00:07:15,099 --> 00:07:21,590
not run the tests which don't it which

00:07:17,990 --> 00:07:23,900
it doesn't think need to be run and sort

00:07:21,590 --> 00:07:27,800
of like cashed in the test results if it

00:07:23,900 --> 00:07:31,520
didn't run them and so this solution has

00:07:27,800 --> 00:07:33,020
the the advantage that it looks pretty

00:07:31,520 --> 00:07:35,300
simple on the surface we don't have to

00:07:33,020 --> 00:07:38,659
build anything extra and since we're

00:07:35,300 --> 00:07:40,879
using Basil's built-in eye invalidation

00:07:38,659 --> 00:07:42,530
and caching logic should be about as

00:07:40,879 --> 00:07:46,190
correct as basil which is which is a

00:07:42,530 --> 00:07:51,740
generally a pretty high standard but on

00:07:46,190 --> 00:07:54,259
the other hand this this solution basil

00:07:51,740 --> 00:07:56,690
test slash slash dot has some serious

00:07:54,259 --> 00:07:58,250
scalability concerns for example we

00:07:56,690 --> 00:08:00,080
almost certainly are going to need to

00:07:58,250 --> 00:08:03,469
have a remote execution for this to

00:08:00,080 --> 00:08:05,240
continue to scale because large changes

00:08:03,469 --> 00:08:06,979
or changes to particularly common

00:08:05,240 --> 00:08:09,020
dependencies will trigger a lot of tests

00:08:06,979 --> 00:08:11,259
which won't be reasonable to run in a

00:08:09,020 --> 00:08:14,419
reasonable amount of time on one machine

00:08:11,259 --> 00:08:17,960
this also still continues to do a lot of

00:08:14,419 --> 00:08:20,509
work kind of up to actually executing

00:08:17,960 --> 00:08:22,789
the actions in basil so this does

00:08:20,509 --> 00:08:25,190
analysis competes the command lines for

00:08:22,789 --> 00:08:28,699
everything and that itself can take a

00:08:25,190 --> 00:08:30,620
lot of memory and a lot of CPU so on a

00:08:28,699 --> 00:08:31,969
workspace of sufficient size this is not

00:08:30,620 --> 00:08:34,339
really a reasonable thing to doing and

00:08:31,969 --> 00:08:35,899
then finally this doesn't really give us

00:08:34,339 --> 00:08:38,750
everything we want so it's a little

00:08:35,899 --> 00:08:40,640
inflexible we might want to be able to

00:08:38,750 --> 00:08:42,260
apply custom policies to the kinds of

00:08:40,640 --> 00:08:43,760
tests we're running in a repository for

00:08:42,260 --> 00:08:45,589
example maybe there are some really

00:08:43,760 --> 00:08:48,230
expensive tests that we only want to run

00:08:45,589 --> 00:08:50,270
every few hours or every day or

00:08:48,230 --> 00:08:51,890
something but basil doesn't really give

00:08:50,270 --> 00:08:54,110
us the controls to do things like that

00:08:51,890 --> 00:08:56,300
just using basil tests

00:08:54,110 --> 00:09:01,370
finally we don't actually manage to

00:08:56,300 --> 00:09:03,019
produce a set of targets from doing this

00:09:01,370 --> 00:09:05,480
Basel just kind of executes what it

00:09:03,019 --> 00:09:08,540
thinks it needs to be executed and it

00:09:05,480 --> 00:09:12,170
doesn't tell us what the true affected

00:09:08,540 --> 00:09:14,750
set was so we need to do a little better

00:09:12,170 --> 00:09:18,529
but first let's define our problem a

00:09:14,750 --> 00:09:21,829
little more closely so the input to the

00:09:18,529 --> 00:09:24,350
selection problem is a set of change

00:09:21,829 --> 00:09:27,800
source files so we can also think of

00:09:24,350 --> 00:09:30,110
this as being two revisions of a version

00:09:27,800 --> 00:09:31,670
control system where we're looking at

00:09:30,110 --> 00:09:33,680
the the changes between those two

00:09:31,670 --> 00:09:36,620
revisions these are equivalent ways of

00:09:33,680 --> 00:09:38,630
thinking about this particular input and

00:09:36,620 --> 00:09:39,950
we'll be switching between them because

00:09:38,630 --> 00:09:42,170
sometimes it's convenient think of it in

00:09:39,950 --> 00:09:44,750
one form or another and then we also

00:09:42,170 --> 00:09:46,370
have a universe of targets that where

00:09:44,750 --> 00:09:49,100
we're going to be searching for the

00:09:46,370 --> 00:09:51,170
affected targets within so in our this

00:09:49,100 --> 00:09:53,029
talk and our examples will always be

00:09:51,170 --> 00:09:56,990
using the entire work space slash slash

00:09:53,029 --> 00:10:00,800
dot but there's certainly use cases for

00:09:56,990 --> 00:10:02,420
a more restricted scope okay and so our

00:10:00,800 --> 00:10:04,790
algorithm our solution to the selection

00:10:02,420 --> 00:10:06,860
problem I supposed to produce a subset

00:10:04,790 --> 00:10:08,660
of the universe that is possibly

00:10:06,860 --> 00:10:09,740
affected by those changes so we're

00:10:08,660 --> 00:10:12,800
always going to have to be a little

00:10:09,740 --> 00:10:15,680
conservative we can't always prove that

00:10:12,800 --> 00:10:17,839
a test is definitely affected by a

00:10:15,680 --> 00:10:19,610
particular change but we want to be

00:10:17,839 --> 00:10:23,060
conserving include all the tests that

00:10:19,610 --> 00:10:25,459
might be affected all right let me also

00:10:23,060 --> 00:10:27,320
shoot the controlling example for my

00:10:25,459 --> 00:10:30,050
change here alright so we're going to be

00:10:27,320 --> 00:10:33,110
considering a little package called

00:10:30,050 --> 00:10:35,360
slash foo and here's the build file for

00:10:33,110 --> 00:10:37,880
slash slash foo alright so I have a

00:10:35,360 --> 00:10:40,490
library C++ library and with a single

00:10:37,880 --> 00:10:42,860
source libbed c c and then there's a

00:10:40,490 --> 00:10:45,019
test called my test which depends on the

00:10:42,860 --> 00:10:48,769
library and you'll also see at the top

00:10:45,019 --> 00:10:51,860
there is a dependency on a star large

00:10:48,769 --> 00:10:54,680
file called my rule that bzl so this is

00:10:51,860 --> 00:10:56,500
kind of a very silly dependency it's a

00:10:54,680 --> 00:10:58,519
it's the whole thing is a bit contrived

00:10:56,500 --> 00:10:59,930
but it will work for our example

00:10:58,519 --> 00:11:03,800
purposes and if you want to see a

00:10:59,930 --> 00:11:06,980
non-trivial build file we're hiring

00:11:03,800 --> 00:11:08,269
all right so with example in hand we can

00:11:06,980 --> 00:11:11,629
start to think about how we're actually

00:11:08,269 --> 00:11:14,329
going to pick out the targets that are

00:11:11,629 --> 00:11:16,399
affected by change and this means we're

00:11:14,329 --> 00:11:18,439
gonna be looking at basal dependency

00:11:16,399 --> 00:11:22,429
graph and the tool to do that of course

00:11:18,439 --> 00:11:26,239
is basil query so basil query i'll lets

00:11:22,429 --> 00:11:27,499
us do post loading inspection of the

00:11:26,239 --> 00:11:30,199
dependency graph so that's a little bit

00:11:27,499 --> 00:11:31,699
of basil jargon loading that essentially

00:11:30,199 --> 00:11:33,769
means that the build files have been

00:11:31,699 --> 00:11:37,910
executed from top to bottom but rules

00:11:33,769 --> 00:11:39,739
haven't been instantiated so targets are

00:11:37,910 --> 00:11:41,569
basically a name with a bunch of

00:11:39,739 --> 00:11:45,649
attributes attached to him like sources

00:11:41,569 --> 00:11:50,319
and depths and so forth and basil query

00:11:45,649 --> 00:11:53,689
lets us manipulate this graph it's a

00:11:50,319 --> 00:11:55,489
very extensive tool with extensive

00:11:53,689 --> 00:11:58,009
documentation there's a good reference

00:11:55,489 --> 00:11:59,779
you can also see the basil query how to

00:11:58,009 --> 00:12:01,939
document which has a lot of neat

00:11:59,779 --> 00:12:04,819
examples about things you can do with

00:12:01,939 --> 00:12:06,949
bait with basil query but like any

00:12:04,819 --> 00:12:10,100
sufficiently powerful tool it has some

00:12:06,949 --> 00:12:12,769
some complexities in gotchas which can

00:12:10,100 --> 00:12:15,410
which can cop up if you're trying to do

00:12:12,769 --> 00:12:17,990
some serious production things with

00:12:15,410 --> 00:12:19,579
basil query so for example there's that

00:12:17,990 --> 00:12:22,549
i'm aware of three different internal

00:12:19,579 --> 00:12:25,639
implementations of query two of them are

00:12:22,549 --> 00:12:26,899
even documented and this is the kind of

00:12:25,639 --> 00:12:29,059
thing that's going to come up when

00:12:26,899 --> 00:12:33,049
you're doing like large performance

00:12:29,059 --> 00:12:34,490
sensitive queries so if if there's one

00:12:33,049 --> 00:12:37,100
sub theme of this talk is that you

00:12:34,490 --> 00:12:38,749
should you should treat treat basil

00:12:37,100 --> 00:12:42,499
query with a little reverence and maybe

00:12:38,749 --> 00:12:44,059
a little fear so anyway if we go and

00:12:42,499 --> 00:12:47,509
look at the basil query reference

00:12:44,059 --> 00:12:49,249
documentation will quickly find some

00:12:47,509 --> 00:12:53,869
functions which will probably be helpful

00:12:49,249 --> 00:12:56,689
to us in figuring out what targets are

00:12:53,869 --> 00:12:59,029
affected given a set of change files so

00:12:56,689 --> 00:13:00,709
the first is the test function so the

00:12:59,029 --> 00:13:02,540
test function takes a bunch of targets

00:13:00,709 --> 00:13:04,429
and it throws out all the targets that

00:13:02,540 --> 00:13:06,439
aren't test so we'll use this as a kind

00:13:04,429 --> 00:13:08,089
of final filtering phase in our

00:13:06,439 --> 00:13:09,049
algorithm to only pick out the test

00:13:08,089 --> 00:13:10,939
targets because that's what we're

00:13:09,049 --> 00:13:12,769
interested in running and then the real

00:13:10,939 --> 00:13:14,899
workhorse is going to be the our depth

00:13:12,769 --> 00:13:17,149
function so the our depth function

00:13:14,899 --> 00:13:17,420
computes the worst dependencies of a set

00:13:17,149 --> 00:13:20,930
of

00:13:17,420 --> 00:13:22,670
argit's within a particular universe so

00:13:20,930 --> 00:13:24,560
with these two it doesn't take much

00:13:22,670 --> 00:13:27,590
imagination to see that we probably want

00:13:24,560 --> 00:13:29,330
to do something like this okay so we

00:13:27,590 --> 00:13:30,830
feed the change files into the are dips

00:13:29,330 --> 00:13:32,780
function we want to compute it over the

00:13:30,830 --> 00:13:35,330
entire universe so that gives us all the

00:13:32,780 --> 00:13:41,060
are depths transit Lee of those change

00:13:35,330 --> 00:13:42,950
files and then we pick up a test so if

00:13:41,060 --> 00:13:46,220
you run this on our really silly foo

00:13:42,950 --> 00:13:50,900
example we'll see that indeed if we

00:13:46,220 --> 00:13:52,730
suppose that our my Lib C C source file

00:13:50,900 --> 00:13:54,830
was changed then we'll see that we

00:13:52,730 --> 00:13:59,080
should be running a foo foo slash

00:13:54,830 --> 00:14:01,190
washroom my test great right are we done

00:13:59,080 --> 00:14:04,370
well if we were done this would have

00:14:01,190 --> 00:14:08,540
been a lightning talk there's a few

00:14:04,370 --> 00:14:11,210
problems and many of them center around

00:14:08,540 --> 00:14:13,820
the asking the question like well what

00:14:11,210 --> 00:14:17,930
if we mutate the build graph instead of

00:14:13,820 --> 00:14:20,240
source files so here's the first of

00:14:17,930 --> 00:14:22,790
three problems what if we what if we

00:14:20,240 --> 00:14:24,740
modify a build file ok so if we put a ma

00:14:22,790 --> 00:14:27,020
if we put a build file into our our

00:14:24,740 --> 00:14:31,310
depp's expression here basil just say

00:14:27,020 --> 00:14:33,230
nope nothing depends on that and to some

00:14:31,310 --> 00:14:35,720
degree that's true right my test does

00:14:33,230 --> 00:14:38,300
not actually depend on the build file to

00:14:35,720 --> 00:14:42,380
execute but modifying the build file

00:14:38,300 --> 00:14:44,330
could certainly affect the test so we're

00:14:42,380 --> 00:14:47,270
gonna need something to deal - deal with

00:14:44,330 --> 00:14:49,580
it to deal with build files but happily

00:14:47,270 --> 00:14:51,140
if we go back to the base of career

00:14:49,580 --> 00:14:53,420
reference documentation we can find out

00:14:51,140 --> 00:14:56,540
some more functions which might help us

00:14:53,420 --> 00:14:58,790
with that so specifically the siblings

00:14:56,540 --> 00:15:00,530
function so the siblings function takes

00:14:58,790 --> 00:15:03,290
in a target and it returns all the

00:15:00,530 --> 00:15:09,680
targets which are in the same package as

00:15:03,290 --> 00:15:11,660
a the target the input target so this

00:15:09,680 --> 00:15:14,270
function is useful for computing all the

00:15:11,660 --> 00:15:16,430
targets in a build file and then we also

00:15:14,270 --> 00:15:18,350
have the filter function which filters

00:15:16,430 --> 00:15:25,070
targets by applying a regular expression

00:15:18,350 --> 00:15:27,200
to their name so with this we can look

00:15:25,070 --> 00:15:29,480
given our set of change files we can

00:15:27,200 --> 00:15:30,890
filter out all the build files and then

00:15:29,480 --> 00:15:31,190
we can compute all the targets that are

00:15:30,890 --> 00:15:36,080
in the

00:15:31,190 --> 00:15:37,340
build files so we might there's this

00:15:36,080 --> 00:15:39,080
little subtle question which is like

00:15:37,340 --> 00:15:40,430
what targets do we actually need to mark

00:15:39,080 --> 00:15:43,100
affect it if a build file is modified

00:15:40,430 --> 00:15:44,930
right so if all we know is the fill

00:15:43,100 --> 00:15:46,160
files modified arbitrary things could

00:15:44,930 --> 00:15:47,750
have happened to the targets within it

00:15:46,160 --> 00:15:50,000
so we basically have to run all the

00:15:47,750 --> 00:15:52,070
targets in that build file and all the

00:15:50,000 --> 00:15:55,400
targets which have a transitive risk

00:15:52,070 --> 00:15:58,330
dependency on that build file but using

00:15:55,400 --> 00:16:03,560
these tools we can kind of integrate our

00:15:58,330 --> 00:16:05,330
original our depth query and this fix

00:16:03,560 --> 00:16:07,250
for the build file thing so I'm making

00:16:05,330 --> 00:16:09,860
use of Basel query syntax to let you

00:16:07,250 --> 00:16:11,780
define a variable to store my change

00:16:09,860 --> 00:16:14,150
files and then I have the our dips over

00:16:11,780 --> 00:16:15,950
the change files and then also all the

00:16:14,150 --> 00:16:18,410
targets in build files that were

00:16:15,950 --> 00:16:21,110
modified and that again prints food

00:16:18,410 --> 00:16:23,210
tests if change files is is is /f built

00:16:21,110 --> 00:16:25,520
all right so that fixes that problem but

00:16:23,210 --> 00:16:28,130
we had three problems so let's look at

00:16:25,520 --> 00:16:29,780
problem number two so another way you

00:16:28,130 --> 00:16:32,750
can modify the build graph is by

00:16:29,780 --> 00:16:34,670
changing a star-like file all right and

00:16:32,750 --> 00:16:37,100
if we tried the original our depth query

00:16:34,670 --> 00:16:41,810
the result is even more horrific than

00:16:37,100 --> 00:16:44,480
the the build file case basel is gonna

00:16:41,810 --> 00:16:46,400
basel is going to tell us you know i've

00:16:44,480 --> 00:16:50,270
never heard of this this my rule that

00:16:46,400 --> 00:16:51,560
bzl file what are you talking about and

00:16:50,270 --> 00:16:53,120
it's also going to give us some hint

00:16:51,560 --> 00:16:56,900
about maybe you want to put export files

00:16:53,120 --> 00:16:59,720
in your build file so we can go and put

00:16:56,900 --> 00:17:01,040
export files in our build file but

00:16:59,720 --> 00:17:02,510
that's really not going to help us very

00:17:01,040 --> 00:17:06,439
much and kind of just stick us back in

00:17:02,510 --> 00:17:09,680
the the situation the build file it's

00:17:06,439 --> 00:17:11,930
it's a red herring and this problem is

00:17:09,680 --> 00:17:14,300
also fixable but we need to do some more

00:17:11,930 --> 00:17:16,550
learning specifically we need to learn

00:17:14,300 --> 00:17:18,439
about something called sky query so sky

00:17:16,550 --> 00:17:21,740
query is one of those other query

00:17:18,439 --> 00:17:24,620
implementations so the generic query

00:17:21,740 --> 00:17:26,900
implementation of basil works by kind of

00:17:24,620 --> 00:17:29,360
using Basil's build file parser and

00:17:26,900 --> 00:17:31,460
loader to load all the targets and then

00:17:29,360 --> 00:17:33,740
it copies all this target graph

00:17:31,460 --> 00:17:35,510
information into a separate graph and

00:17:33,740 --> 00:17:36,920
does the query over that so that makes

00:17:35,510 --> 00:17:39,770
it very flexible because it's a very

00:17:36,920 --> 00:17:41,450
generic graph implementation but it also

00:17:39,770 --> 00:17:45,110
means there's this overhead involved in

00:17:41,450 --> 00:17:47,690
in copying targets into the other graph

00:17:45,110 --> 00:17:52,789
skyy query on the other hand uses

00:17:47,690 --> 00:17:55,039
Basil's native incremental 'ti loading

00:17:52,789 --> 00:17:57,309
framework directly to implement query

00:17:55,039 --> 00:18:00,320
and we that we get slightly different

00:17:57,309 --> 00:18:03,710
performance characteristics so there's

00:18:00,320 --> 00:18:05,029
less copying and I feel it might be a

00:18:03,710 --> 00:18:07,309
little more performant especially with

00:18:05,029 --> 00:18:09,440
really large Universal queries like what

00:18:07,309 --> 00:18:11,960
we're doing here but we also get a

00:18:09,440 --> 00:18:15,440
slightly different feature set with sky

00:18:11,960 --> 00:18:16,789
query in particular we can't ask for our

00:18:15,440 --> 00:18:19,249
output to be ordered in any particular

00:18:16,789 --> 00:18:22,669
way so to activate sky query we have to

00:18:19,249 --> 00:18:24,559
pass - - order output equals no and so

00:18:22,669 --> 00:18:27,230
that's okay for the selected target the

00:18:24,559 --> 00:18:28,700
target selection case because we don't

00:18:27,230 --> 00:18:29,989
really care what output what order we

00:18:28,700 --> 00:18:32,320
get it in we just want all of the

00:18:29,989 --> 00:18:35,480
targets and then we also have to use a

00:18:32,320 --> 00:18:37,879
option called - - universe scope and

00:18:35,480 --> 00:18:39,739
that's going to be the total universe

00:18:37,879 --> 00:18:41,179
that we're allowed to access within the

00:18:39,739 --> 00:18:43,489
query so we're gonna be we're gonna be

00:18:41,179 --> 00:18:46,070
passing slash slash dot dot and there

00:18:43,489 --> 00:18:47,629
anyway the main advantage we get from is

00:18:46,070 --> 00:18:49,850
getting sky query at least in this case

00:18:47,629 --> 00:18:53,239
is that we get another function called

00:18:49,850 --> 00:18:56,629
our build files and our build files

00:18:53,239 --> 00:18:58,279
takes a path for example a star large

00:18:56,629 --> 00:19:04,369
file and tells us all the build files

00:18:58,279 --> 00:19:08,119
that trans ibly depend on that that path

00:19:04,369 --> 00:19:10,580
alright so our first attempt to use this

00:19:08,119 --> 00:19:11,989
actually might fail like this all right

00:19:10,580 --> 00:19:14,720
so we're using our build files and we're

00:19:11,989 --> 00:19:16,279
passing they're our star arc file but

00:19:14,720 --> 00:19:19,690
we're still getting empty results does

00:19:16,279 --> 00:19:23,509
this thing not work as advertised well

00:19:19,690 --> 00:19:24,950
actually if you go careful read the

00:19:23,509 --> 00:19:28,100
documentation you'll see that our build

00:19:24,950 --> 00:19:30,019
files unlike every other basil query

00:19:28,100 --> 00:19:32,570
function does not take targets it takes

00:19:30,019 --> 00:19:35,539
path fragments so we have to go pass a

00:19:32,570 --> 00:19:37,489
path not a target and if we do that

00:19:35,539 --> 00:19:40,070
we'll finally find out that through

00:19:37,489 --> 00:19:43,460
slice build depends on that star large

00:19:40,070 --> 00:19:44,809
file great okay so now that we've found

00:19:43,460 --> 00:19:46,100
all the build files that depend on a

00:19:44,809 --> 00:19:48,409
star large file we can apply the same

00:19:46,100 --> 00:19:50,029
logic where we get all the targets in

00:19:48,409 --> 00:19:51,559
this build files and then and then mark

00:19:50,029 --> 00:19:57,730
all the targets there and all their

00:19:51,559 --> 00:19:57,730
reverse dependencies as affected so

00:19:59,350 --> 00:20:03,280
great like we can go and we'll be using

00:20:01,840 --> 00:20:05,290
the siblings function right so that

00:20:03,280 --> 00:20:07,360
should that should that that should

00:20:05,290 --> 00:20:10,900
still work I won't show you the combined

00:20:07,360 --> 00:20:12,790
query let's look at the next problem at

00:20:10,900 --> 00:20:14,290
this point I'm sorry I'm sorry to

00:20:12,790 --> 00:20:18,310
announce that my problem counter works

00:20:14,290 --> 00:20:20,920
like the Basel action counter and yes

00:20:18,310 --> 00:20:22,510
yes yes we're we're we're up to five of

00:20:20,920 --> 00:20:27,790
the Dominator who knows how high it will

00:20:22,510 --> 00:20:29,260
go and but anyway problem free problem

00:20:27,790 --> 00:20:31,870
three has to do with well what if

00:20:29,260 --> 00:20:34,390
instead of modifying a file we deleted a

00:20:31,870 --> 00:20:36,910
file all right

00:20:34,390 --> 00:20:39,670
so if we ask for the reverse dependency

00:20:36,910 --> 00:20:41,620
of a deleted file basil quite reasonably

00:20:39,670 --> 00:20:45,730
is going to tell us I don't know about

00:20:41,620 --> 00:20:47,770
this it doesn't exist but I do it but

00:20:45,730 --> 00:20:49,450
removing a file could still modify the

00:20:47,770 --> 00:20:51,460
build graph for example if there was a

00:20:49,450 --> 00:20:54,490
glob somewhere that has stopped picking

00:20:51,460 --> 00:20:55,780
up this this file so we need to do

00:20:54,490 --> 00:20:57,790
something about this and there's

00:20:55,780 --> 00:21:01,060
something that we have to do is we have

00:20:57,790 --> 00:21:03,880
to go back to the old version where this

00:21:01,060 --> 00:21:05,680
file do this deleted file exists compute

00:21:03,880 --> 00:21:08,380
the affected targets of the deleted file

00:21:05,680 --> 00:21:10,450
and then bring those forward into the

00:21:08,380 --> 00:21:11,860
new universe I'd intersect it with all

00:21:10,450 --> 00:21:14,080
the targets that exist in the new

00:21:11,860 --> 00:21:18,130
version okay so we're gonna have to run

00:21:14,080 --> 00:21:21,520
at least two queries now let's jump on

00:21:18,130 --> 00:21:23,770
to problem for which also has to do with

00:21:21,520 --> 00:21:28,210
adding or deleting files but this time

00:21:23,770 --> 00:21:30,220
build files so and it revolves around a

00:21:28,210 --> 00:21:32,860
problem with the glob function so the

00:21:30,220 --> 00:21:35,650
glove function which lets you pick up

00:21:32,860 --> 00:21:39,730
lots of files in Bill files can be used

00:21:35,650 --> 00:21:42,370
recursively but it cannot cross package

00:21:39,730 --> 00:21:44,200
boundaries so a recursive glob will pick

00:21:42,370 --> 00:21:45,640
up files and directories until it hits

00:21:44,200 --> 00:21:48,130
another build file and then it will go

00:21:45,640 --> 00:21:50,380
no further this means that if you add or

00:21:48,130 --> 00:21:55,570
remove a package you can affect the

00:21:50,380 --> 00:21:57,010
globs of its parent packages so this

00:21:55,570 --> 00:21:58,810
isn't this is another problem where we

00:21:57,010 --> 00:22:01,780
have to figure out what the the files

00:21:58,810 --> 00:22:04,240
which are affected by this are and kind

00:22:01,780 --> 00:22:10,720
of invalidate all the targets in those

00:22:04,240 --> 00:22:12,280
files and so this is

00:22:10,720 --> 00:22:13,929
a particularly annoying because we can't

00:22:12,280 --> 00:22:15,490
really do it in the context of query I

00:22:13,929 --> 00:22:17,530
would kind of have to manually traverse

00:22:15,490 --> 00:22:19,450
the filesystem and find out packages

00:22:17,530 --> 00:22:22,270
which had sub-packages editor deleted

00:22:19,450 --> 00:22:24,580
but this problem is fixable and then

00:22:22,270 --> 00:22:26,190
eventually we'll end up with something

00:22:24,580 --> 00:22:30,150
great like this you know this is our

00:22:26,190 --> 00:22:33,010
universal reverse depth computing query

00:22:30,150 --> 00:22:35,490
so you can see we have all of our fixes

00:22:33,010 --> 00:22:38,440
we have the reverse steps of the the

00:22:35,490 --> 00:22:40,840
change files we deal with the build

00:22:38,440 --> 00:22:45,549
files we deal with a star-like files and

00:22:40,840 --> 00:22:47,559
then we deal with with the build files

00:22:45,549 --> 00:22:49,990
with added or removed sub packages

00:22:47,559 --> 00:22:54,100
you'll see I have to filter out the

00:22:49,990 --> 00:22:55,960
paths by by extension and I did that by

00:22:54,100 --> 00:22:57,580
ensuring some horrible shell that's

00:22:55,960 --> 00:23:01,210
because I don't have to maintain slides

00:22:57,580 --> 00:23:02,770
code and then finally we have another

00:23:01,210 --> 00:23:04,419
target query which we had to run

00:23:02,770 --> 00:23:05,950
previously and insert into this one

00:23:04,419 --> 00:23:07,960
which is the affected targets it deleted

00:23:05,950 --> 00:23:13,030
files from the older version all right

00:23:07,960 --> 00:23:14,890
so this plugs most of the holes but you

00:23:13,030 --> 00:23:17,380
know we might have to this this is far

00:23:14,890 --> 00:23:18,820
cry from our original intention here

00:23:17,380 --> 00:23:21,340
where it seems so nice and easy with our

00:23:18,820 --> 00:23:24,370
our one our depth function in one test

00:23:21,340 --> 00:23:27,340
function and and if this actually works

00:23:24,370 --> 00:23:29,890
you know we've certainly you know our

00:23:27,340 --> 00:23:32,020
quest for elegance has certainly taken a

00:23:29,890 --> 00:23:34,270
cold shower and since that's really what

00:23:32,020 --> 00:23:37,750
matters in software engineering I don't

00:23:34,270 --> 00:23:43,260
I don't want to do this so let's take a

00:23:37,750 --> 00:23:45,850
step back and reconsider all right so

00:23:43,260 --> 00:23:50,309
thinking about this again at the

00:23:45,850 --> 00:23:53,590
beginning I said that a target is

00:23:50,309 --> 00:23:57,580
approximately at loading phase a name

00:23:53,590 --> 00:24:00,789
with some attributes and there's

00:23:57,580 --> 00:24:03,309
actually a way to get basil to tell you

00:24:00,789 --> 00:24:04,990
what the attributes are so so far we've

00:24:03,309 --> 00:24:08,590
been using query in a mode where it only

00:24:04,990 --> 00:24:10,000
outputs the names of targets but query

00:24:08,590 --> 00:24:11,320
is quite capable of telling us basically

00:24:10,000 --> 00:24:14,289
everything there is to know about a

00:24:11,320 --> 00:24:18,940
particular target in particular if we

00:24:14,289 --> 00:24:21,549
pass - - output equals proto basil will

00:24:18,940 --> 00:24:24,519
emit a giant proto for all the targets

00:24:21,549 --> 00:24:26,589
which are the output of the rule so

00:24:24,519 --> 00:24:30,009
here's an example from my food package

00:24:26,589 --> 00:24:32,549
so you can see there's a target message

00:24:30,009 --> 00:24:35,709
it tells us what type it is it's a rule

00:24:32,549 --> 00:24:37,570
we tells us what it's rural classes and

00:24:35,709 --> 00:24:39,669
then each attribute has a proto buff

00:24:37,570 --> 00:24:42,489
which tells us what it's type is its

00:24:39,669 --> 00:24:46,859
name and its value and then finally at

00:24:42,489 --> 00:24:46,859
the end we have some rule input

00:24:47,129 --> 00:24:56,399
attributes and this tells us what rules

00:24:52,419 --> 00:25:00,509
this particular target depends on so

00:24:56,399 --> 00:25:04,450
thinking about this a little and also

00:25:00,509 --> 00:25:07,659
thinking about cryptography we can go

00:25:04,450 --> 00:25:09,909
back and apropriate an old idea from

00:25:07,659 --> 00:25:13,950
from cryptography so old is important

00:25:09,909 --> 00:25:13,950
because that means a patent has expired

00:25:14,009 --> 00:25:21,969
and that old idea is the miracle tree so

00:25:18,399 --> 00:25:25,839
what I want to do is construct take my

00:25:21,969 --> 00:25:29,229
target dependency graph and associate a

00:25:25,839 --> 00:25:32,320
hash to each node such that the hash

00:25:29,229 --> 00:25:33,969
depends on the attributes of that target

00:25:32,320 --> 00:25:36,159
and also all of its transitive

00:25:33,969 --> 00:25:38,320
dependencies and using that I can tell

00:25:36,159 --> 00:25:40,359
whether a particular target has changed

00:25:38,320 --> 00:25:41,859
or not so the way that works is that at

00:25:40,359 --> 00:25:43,839
the bottom of our defensive graph we

00:25:41,859 --> 00:25:46,359
usually have a lot of source files so

00:25:43,839 --> 00:25:48,759
for example libbed c c so we could just

00:25:46,359 --> 00:25:51,099
say that the the hash of that node is

00:25:48,759 --> 00:25:52,359
the hash of the contents of the file and

00:25:51,099 --> 00:25:54,249
then moving up a level we have our

00:25:52,359 --> 00:25:56,379
liberal which actually contains the

00:25:54,249 --> 00:25:58,539
source file and so the hash of that will

00:25:56,379 --> 00:26:04,709
be a hassle of all its attributes for

00:25:58,539 --> 00:26:08,200
example the c OPS+ the hash of the its

00:26:04,709 --> 00:26:10,809
source file a Lib dot C C and finally at

00:26:08,200 --> 00:26:14,169
the top our test has its own attributes

00:26:10,809 --> 00:26:16,269
and it depends on my lab so we hash all

00:26:14,169 --> 00:26:18,429
those things and get a final hash all

00:26:16,269 --> 00:26:22,809
right so perhaps it's a little easier to

00:26:18,429 --> 00:26:26,679
see this in code - a target we just go

00:26:22,809 --> 00:26:28,179
through all of its attributes sort of we

00:26:26,679 --> 00:26:30,570
can we could just hash the attributes by

00:26:28,179 --> 00:26:34,599
Siri serializing the attribute protobuf

00:26:30,570 --> 00:26:38,140
or message and then we recursively call

00:26:34,599 --> 00:26:40,450
hash target - hash all the rural inputs

00:26:38,140 --> 00:26:41,770
all right so this this simplifies a

00:26:40,450 --> 00:26:43,630
little because there's more things on

00:26:41,770 --> 00:26:45,910
the real protobuf that we need but it's

00:26:43,630 --> 00:26:47,740
largely largely the the idea and then

00:26:45,910 --> 00:26:49,900
using this information we can write a

00:26:47,740 --> 00:26:53,080
little code to actually compute targets

00:26:49,900 --> 00:26:55,059
that are changed so we're gonna need is

00:26:53,080 --> 00:26:56,920
inputs all the targets in the old

00:26:55,059 --> 00:27:00,880
revision and all the targets in the new

00:26:56,920 --> 00:27:03,940
revision so we compute a map from the

00:27:00,880 --> 00:27:06,580
target name to its hash for both the old

00:27:03,940 --> 00:27:08,320
revision and the new revision and then

00:27:06,580 --> 00:27:10,360
for all the targets in the new revision

00:27:08,320 --> 00:27:12,340
first we check whether that target

00:27:10,360 --> 00:27:14,080
exists in the old revision or not if it

00:27:12,340 --> 00:27:15,040
doesn't exist at all then its new so we

00:27:14,080 --> 00:27:16,929
definitely need to run it it's

00:27:15,040 --> 00:27:18,610
definitely affected so we'll the added

00:27:16,929 --> 00:27:23,350
to our affected set and then otherwise

00:27:18,610 --> 00:27:25,059
if the affected the the hash of the

00:27:23,350 --> 00:27:27,010
target in the new revision differs from

00:27:25,059 --> 00:27:32,760
that in the old revision we'll add it to

00:27:27,010 --> 00:27:34,900
our affected set and kind of on a macro

00:27:32,760 --> 00:27:36,730
operational level this is what just this

00:27:34,900 --> 00:27:39,580
looks out looks like if say if we were

00:27:36,730 --> 00:27:42,220
using git so we output we check out the

00:27:39,580 --> 00:27:46,840
old revision and then we run this query

00:27:42,220 --> 00:27:49,179
which is pretty simple to sort of dump

00:27:46,840 --> 00:27:51,730
the entire basil dependency target graph

00:27:49,179 --> 00:27:54,429
as a proto we say that we check out the

00:27:51,730 --> 00:27:57,429
new revision we run the same query and

00:27:54,429 --> 00:27:59,440
that produces a giant proto but file and

00:27:57,429 --> 00:28:04,030
then we run our code select targets

00:27:59,440 --> 00:28:06,040
passing in the the old graph and the new

00:28:04,030 --> 00:28:08,860
graph and the the files we think are

00:28:06,040 --> 00:28:11,049
changed and then that runs the code up

00:28:08,860 --> 00:28:13,570
from the previous slide which finally

00:28:11,049 --> 00:28:16,090
tells us that foo my test has been

00:28:13,570 --> 00:28:20,650
modified okay

00:28:16,090 --> 00:28:22,960
so on one hand we've we've kind of given

00:28:20,650 --> 00:28:25,480
up on using query we've sort of reduced

00:28:22,960 --> 00:28:29,070
basil to like a glorified incremental

00:28:25,480 --> 00:28:32,350
build file proto dump or parser thing

00:28:29,070 --> 00:28:36,460
but and we had to write some code of our

00:28:32,350 --> 00:28:39,280
own which is never good but on the other

00:28:36,460 --> 00:28:41,169
hand it's once you get your idea around

00:28:39,280 --> 00:28:43,030
the build miracle tree your head around

00:28:41,169 --> 00:28:44,950
the idea of the build miracle tree it's

00:28:43,030 --> 00:28:47,200
pretty conceptually easy to understand

00:28:44,950 --> 00:28:48,820
and it's much easier to believe that

00:28:47,200 --> 00:28:51,160
this is correct rather than the the

00:28:48,820 --> 00:28:51,970
 the monstrous query I was showing

00:28:51,160 --> 00:28:55,840
you

00:28:51,970 --> 00:28:59,530
showing you before but there's still

00:28:55,840 --> 00:29:04,450
another problem and that has to do with

00:28:59,530 --> 00:29:07,480
external workspaces and the root of this

00:29:04,450 --> 00:29:10,300
problem is that query cannot really tell

00:29:07,480 --> 00:29:12,760
you what files are affected in an

00:29:10,300 --> 00:29:15,520
external workspace so like if I go look

00:29:12,760 --> 00:29:19,420
at an example right so if I have this

00:29:15,520 --> 00:29:22,470
HTTP archive file in my rule in my

00:29:19,420 --> 00:29:25,090
workspace file then that defines a

00:29:22,470 --> 00:29:27,820
external repository at awesome

00:29:25,090 --> 00:29:30,400
third-party software and if someone goes

00:29:27,820 --> 00:29:32,290
and modifies this URL that will probably

00:29:30,400 --> 00:29:35,470
cause a corresponding changes in the

00:29:32,290 --> 00:29:37,660
source files of the external work space

00:29:35,470 --> 00:29:39,520
but query just has no way to tell us

00:29:37,660 --> 00:29:42,760
that to match up the change in the

00:29:39,520 --> 00:29:47,050
workspace file to that in the external

00:29:42,760 --> 00:29:49,030
repository and partially that's just

00:29:47,050 --> 00:29:52,810
because that's a truly impossible task

00:29:49,030 --> 00:29:55,720
so this is a very tame external

00:29:52,810 --> 00:29:57,520
workspace but it's very easy to have an

00:29:55,720 --> 00:29:59,710
external workspace that causes arbitrary

00:29:57,520 --> 00:30:01,870
code to execute reads arbitrary things

00:29:59,710 --> 00:30:03,850
from the system that makes Network calls

00:30:01,870 --> 00:30:06,100
and is just basically flag currently non

00:30:03,850 --> 00:30:07,900
hermetic and in that case it's in pot

00:30:06,100 --> 00:30:10,060
it's essentially impossible to compute

00:30:07,900 --> 00:30:11,530
the inputs to a workspace rule or

00:30:10,060 --> 00:30:16,450
whether it changed or not because the

00:30:11,530 --> 00:30:18,400
inputs are the world so we can put we

00:30:16,450 --> 00:30:20,170
can partially address this problem at

00:30:18,400 --> 00:30:22,840
least for a restricted set of a

00:30:20,170 --> 00:30:26,980
workspace rules by using the disgusting

00:30:22,840 --> 00:30:29,350
hack and so basil does not expose this

00:30:26,980 --> 00:30:30,520
information at all but basil itself kind

00:30:29,350 --> 00:30:32,560
of has this problem where it needs to

00:30:30,520 --> 00:30:37,420
know whether to refresh a repository or

00:30:32,560 --> 00:30:39,160
not and so it's kind of stores a hat a

00:30:37,420 --> 00:30:41,530
hash of what it thinks are the inputs to

00:30:39,160 --> 00:30:45,700
the repository in a special place in its

00:30:41,530 --> 00:30:48,160
internal output tree so you also can go

00:30:45,700 --> 00:30:49,540
and slurp up these hashes and then if

00:30:48,160 --> 00:30:53,260
they change you know the repository

00:30:49,540 --> 00:30:56,800
changed so it's it's it's it's gross but

00:30:53,260 --> 00:30:59,710
but but effective so that that plugs the

00:30:56,800 --> 00:31:01,810
external workspace rule all right

00:30:59,710 --> 00:31:03,460
with with that behind us I'd like to

00:31:01,810 --> 00:31:04,809
talk a little bit about the optimization

00:31:03,460 --> 00:31:07,720
of

00:31:04,809 --> 00:31:09,460
argit's election so this is a very

00:31:07,720 --> 00:31:11,499
critical piece of a continuous

00:31:09,460 --> 00:31:14,320
integration pipeline selecting a test to

00:31:11,499 --> 00:31:15,879
run for one it runs on every single time

00:31:14,320 --> 00:31:18,309
someone wants to use the continuous

00:31:15,879 --> 00:31:21,039
integration system and also it's kind of

00:31:18,309 --> 00:31:22,840
in the critical path it blocks actually

00:31:21,039 --> 00:31:26,379
executing the test because we don't know

00:31:22,840 --> 00:31:28,450
what they are yet and so we spent some

00:31:26,379 --> 00:31:30,879
time making this faster and probably the

00:31:28,450 --> 00:31:36,100
most important thing we did was we made

00:31:30,879 --> 00:31:38,799
Basel query into a service so every time

00:31:36,100 --> 00:31:40,899
we were previously executing Basel kind

00:31:38,799 --> 00:31:43,200
of like a shell command we instead make

00:31:40,899 --> 00:31:47,049
an RPC and the Basel quarry service

00:31:43,200 --> 00:31:50,649
encapsulate the idea of checking out a

00:31:47,049 --> 00:31:53,110
revision of our particular revision of

00:31:50,649 --> 00:31:55,299
our version control system executing a

00:31:53,110 --> 00:31:58,299
query and then uploading the results to

00:31:55,299 --> 00:32:00,700
a persistent storage so that the client

00:31:58,299 --> 00:32:02,710
can actually access those results so we

00:32:00,700 --> 00:32:05,980
have to use a kind of large file storage

00:32:02,710 --> 00:32:08,190
thing because these these outputs could

00:32:05,980 --> 00:32:12,690
be in the hundreds of megabytes easily

00:32:08,190 --> 00:32:15,669
all right so why is this better

00:32:12,690 --> 00:32:17,409
well one reason is that the Basel query

00:32:15,669 --> 00:32:21,840
service can kind of maintain a farm of

00:32:17,409 --> 00:32:24,610
hot Basel servers and so that means

00:32:21,840 --> 00:32:27,279
basil's incrementality logic can avoid

00:32:24,610 --> 00:32:31,090
doing unnecessary work it kind of has

00:32:27,279 --> 00:32:35,499
hot state of files that it's parsed and

00:32:31,090 --> 00:32:38,230
also the the JVM stays warm another

00:32:35,499 --> 00:32:43,600
advantage is that we can cache queries

00:32:38,230 --> 00:32:45,999
so if you get this the same request for

00:32:43,600 --> 00:32:47,669
a query on the same revision twice you

00:32:45,999 --> 00:32:49,929
should be able to only compute that once

00:32:47,669 --> 00:32:51,309
and then probably the biggest advantage

00:32:49,929 --> 00:32:54,369
is that we can execute queries in

00:32:51,309 --> 00:32:55,899
parallel so you saw we have to have

00:32:54,369 --> 00:32:57,730
there's fundamentally we have to have

00:32:55,899 --> 00:32:59,019
two queries we have to have a query on

00:32:57,730 --> 00:33:02,409
the old revision of the query on a new

00:32:59,019 --> 00:33:03,789
revision so with a query server so we

00:33:02,409 --> 00:33:06,460
can just submit two queries at the same

00:33:03,789 --> 00:33:08,309
time and kind of get the results back in

00:33:06,460 --> 00:33:11,919
about half the time which is a very

00:33:08,309 --> 00:33:14,159
major improvement because query is kind

00:33:11,919 --> 00:33:16,960
of the slowest part of this operation

00:33:14,159 --> 00:33:18,520
all right so you might reasonably wonder

00:33:16,960 --> 00:33:21,610
what it's like to operate

00:33:18,520 --> 00:33:23,710
the basil quarry service it's kind of a

00:33:21,610 --> 00:33:25,210
weird service where it's it's it's I

00:33:23,710 --> 00:33:27,970
would say quasi a stateful

00:33:25,210 --> 00:33:30,340
so the kind of the entire point of it is

00:33:27,970 --> 00:33:33,130
to have some maintain state at warm

00:33:30,340 --> 00:33:36,070
basal service and caches and so forth

00:33:33,130 --> 00:33:37,600
but also you know if the cluster

00:33:36,070 --> 00:33:39,100
management software comes along and says

00:33:37,600 --> 00:33:42,670
this machine needs to go away it's not

00:33:39,100 --> 00:33:44,530
too much too much of a loss to to remove

00:33:42,670 --> 00:33:47,170
that Basel query system because it's all

00:33:44,530 --> 00:33:51,850
re replicatable by starting up new

00:33:47,170 --> 00:33:54,370
Basil's on the workspace but another

00:33:51,850 --> 00:33:56,260
special property of basil quarry service

00:33:54,370 --> 00:33:59,410
is that because query is executed for so

00:33:56,260 --> 00:34:01,660
long like minutes is not a unhard of

00:33:59,410 --> 00:34:03,400
time period we need to have a special

00:34:01,660 --> 00:34:06,460
kind of front-end for the basal query

00:34:03,400 --> 00:34:08,050
service that takes care of keeping track

00:34:06,460 --> 00:34:10,389
of which workers are busy executing

00:34:08,050 --> 00:34:14,470
queries and routes queries to the

00:34:10,389 --> 00:34:16,570
correct back-end which is free and so

00:34:14,470 --> 00:34:18,550
basil is actually not not too difficult

00:34:16,570 --> 00:34:19,899
to manage in this situation we've found

00:34:18,550 --> 00:34:22,840
and kind of the most difficult thing

00:34:19,899 --> 00:34:24,550
actually has been get so get just it

00:34:22,840 --> 00:34:26,710
seems like if you like execute it too

00:34:24,550 --> 00:34:28,720
many times on a repository or like gets

00:34:26,710 --> 00:34:32,080
uncleanly shut down at some point it

00:34:28,720 --> 00:34:35,830
just like gives up and and and corrupts

00:34:32,080 --> 00:34:38,020
your repo or something and so kind of a

00:34:35,830 --> 00:34:41,200
lot of the work of the stability the

00:34:38,020 --> 00:34:43,030
system stable has been just like pars

00:34:41,200 --> 00:34:44,590
and get error messages to decide whether

00:34:43,030 --> 00:34:46,540
it's like completely broken or not and

00:34:44,590 --> 00:34:49,240
we need to blow away the repo and so

00:34:46,540 --> 00:34:51,280
that's one of the more disappointing

00:34:49,240 --> 00:34:52,780
learnings from from from this whole

00:34:51,280 --> 00:34:55,389
affair like I'm not sure if this is

00:34:52,780 --> 00:34:57,250
because git is just wrong or because

00:34:55,389 --> 00:34:59,460
it's just impossible to write data

00:34:57,250 --> 00:35:01,900
preserving systems on Linux file systems

00:34:59,460 --> 00:35:09,040
but in either way we can blame the same

00:35:01,900 --> 00:35:11,260
person right so okay finally I would

00:35:09,040 --> 00:35:15,550
like to touch on what I'm calling being

00:35:11,260 --> 00:35:20,340
incorrect for profit and this result

00:35:15,550 --> 00:35:23,350
this this revolves around the fact that

00:35:20,340 --> 00:35:24,070
only running affected tests only gets

00:35:23,350 --> 00:35:30,100
you so far

00:35:24,070 --> 00:35:31,930
for one thing it's very much a a depends

00:35:30,100 --> 00:35:33,569
on the structure of your dependency

00:35:31,930 --> 00:35:36,069
graph right so if you have many fine

00:35:33,569 --> 00:35:38,920
dependencies you're much more likely to

00:35:36,069 --> 00:35:43,540
select out a lot of tests if for example

00:35:38,920 --> 00:35:44,829
you have one giant monolithic web app

00:35:43,540 --> 00:35:46,990
where everything is an integration test

00:35:44,829 --> 00:35:51,220
it depends on everything hypothetically

00:35:46,990 --> 00:35:56,079
you might not win quite as much but even

00:35:51,220 --> 00:35:57,819
with affected only running affected test

00:35:56,079 --> 00:36:00,280
it kind of seems like you only cut out

00:35:57,819 --> 00:36:02,500
of like a say on average a constant

00:36:00,280 --> 00:36:04,839
factor of the number of tests you're

00:36:02,500 --> 00:36:07,569
going to run and there seems to be a sad

00:36:04,839 --> 00:36:12,490
fact that test execution time in CI

00:36:07,569 --> 00:36:13,839
systems grows quadratically and the two

00:36:12,490 --> 00:36:16,599
quadratic factors are the number of

00:36:13,839 --> 00:36:20,980
changes and and the enemy and the amount

00:36:16,599 --> 00:36:22,680
of code and like quadratic growth is no

00:36:20,980 --> 00:36:25,900
one wants to wait for quadratic growth

00:36:22,680 --> 00:36:28,420
for the test to run i and most

00:36:25,900 --> 00:36:29,980
importantly companies don't want to pay

00:36:28,420 --> 00:36:33,400
for quadratic growth in testing

00:36:29,980 --> 00:36:35,710
resources so this is not really an

00:36:33,400 --> 00:36:37,420
acceptable situation to be in so we need

00:36:35,710 --> 00:36:40,000
to apply some even more aggressive

00:36:37,420 --> 00:36:42,520
strategies to prune the tests that we're

00:36:40,000 --> 00:36:46,119
running and there's several ways of

00:36:42,520 --> 00:36:47,260
going about this one is batching so

00:36:46,119 --> 00:36:49,510
that's where you take a whole bunch of

00:36:47,260 --> 00:36:51,910
tests changes and then you compute the

00:36:49,510 --> 00:36:54,700
affected test set over all of them and

00:36:51,910 --> 00:36:56,680
run the test once so that way you don't

00:36:54,700 --> 00:36:58,540
you only run a test at least once for

00:36:56,680 --> 00:37:00,040
all these changes it does have the

00:36:58,540 --> 00:37:02,140
complexity that there's it kind of

00:37:00,040 --> 00:37:04,270
extends the tail of guinea test results

00:37:02,140 --> 00:37:05,619
for changes in the middle it also means

00:37:04,270 --> 00:37:07,630
you want to have some sort of automatic

00:37:05,619 --> 00:37:09,819
bisection system to find out if tests

00:37:07,630 --> 00:37:12,040
were broken in between but it can

00:37:09,819 --> 00:37:13,960
dramatically reduce reduce the number of

00:37:12,040 --> 00:37:16,630
test executions which are largely

00:37:13,960 --> 00:37:20,349
duplicate that you have to do you can

00:37:16,630 --> 00:37:22,000
also apply policies which bound

00:37:20,349 --> 00:37:24,040
selections so you can say things like

00:37:22,000 --> 00:37:25,510
well we're only going to run tests which

00:37:24,040 --> 00:37:29,109
are for hops in the dependency graph

00:37:25,510 --> 00:37:33,400
away from the file that was changed and

00:37:29,109 --> 00:37:35,109
the goal here is to hopefully test which

00:37:33,400 --> 00:37:36,910
are closer to the code being changed are

00:37:35,109 --> 00:37:39,339
more likely to actually find find

00:37:36,910 --> 00:37:44,349
problems with it and finally if you want

00:37:39,339 --> 00:37:45,700
to be really clever and modern you can

00:37:44,349 --> 00:37:48,520
do predictive testing where

00:37:45,700 --> 00:37:50,380
try to guess what tests are most likely

00:37:48,520 --> 00:37:54,100
to fail so usually doing this with

00:37:50,380 --> 00:37:56,740
statistics or other kinds of machine

00:37:54,100 --> 00:37:58,510
learning Google and Facebook have

00:37:56,740 --> 00:38:02,230
published some interesting papers about

00:37:58,510 --> 00:38:04,150
this all right so with that in the bag

00:38:02,230 --> 00:38:08,560
I'm I'm largely done here's an image

00:38:04,150 --> 00:38:10,210
credit for my first slide and I will

00:38:08,560 --> 00:38:11,860
turn it over to you if you have any

00:38:10,210 --> 00:38:14,230
questions this of course is my email

00:38:11,860 --> 00:38:16,990
address you can reach you can reach me

00:38:14,230 --> 00:38:18,640
there until such a time that one entity

00:38:16,990 --> 00:38:24,160
on either side of the @ sign decides to

00:38:18,640 --> 00:38:26,970
call it quits and please do check out

00:38:24,160 --> 00:38:33,630
our other talks and our open-source

00:38:26,970 --> 00:38:33,630
bazel tools on github Thanks

00:38:33,710 --> 00:38:37,900
[Applause]

00:38:38,300 --> 00:38:42,380
all right so talking about hidden gems I

00:38:40,640 --> 00:38:45,619
think Benjamin talk is a hidden gem on

00:38:42,380 --> 00:38:47,330
every Basel cone so far so and I'm most

00:38:45,619 --> 00:38:50,630
looking forward to actual talk about

00:38:47,330 --> 00:38:54,710
hidden gems in Basel code base was that

00:38:50,630 --> 00:39:00,170
are any questions yeah

00:38:54,710 --> 00:39:01,730
etai I have two questions one is what

00:39:00,170 --> 00:39:03,950
what's the order mine is it like how

00:39:01,730 --> 00:39:05,600
much time does this take how much time

00:39:03,950 --> 00:39:07,790
does it commit me to wait a build

00:39:05,600 --> 00:39:09,680
request needs to wait so I think so I

00:39:07,790 --> 00:39:11,720
think this is completely proportional to

00:39:09,680 --> 00:39:16,220
the size of your your work space so I

00:39:11,720 --> 00:39:18,970
think word about two minutes to this

00:39:16,220 --> 00:39:22,250
selection is that right yeah two minutes

00:39:18,970 --> 00:39:23,720
did you consider preemptively running

00:39:22,250 --> 00:39:26,360
the basic query you know based on

00:39:23,720 --> 00:39:28,850
basically it get events so that when the

00:39:26,360 --> 00:39:30,800
build request comes then maybe you've

00:39:28,850 --> 00:39:34,580
already computed the basic query

00:39:30,800 --> 00:39:36,170
well I there's it's not really

00:39:34,580 --> 00:39:38,119
pre-emptive because our CI system is

00:39:36,170 --> 00:39:41,360
triggered off get put okay so there's

00:39:38,119 --> 00:39:42,859
like we there's nothing there's not

00:39:41,360 --> 00:39:44,810
really any guessing to be done in our

00:39:42,859 --> 00:39:48,580
case anyway oh again actually a third

00:39:44,810 --> 00:39:51,380
question did you consider having it

00:39:48,580 --> 00:39:54,650
basically in in memory the the graph

00:39:51,380 --> 00:39:57,800
instead of learning basic query so I

00:39:54,650 --> 00:40:00,920
mean well you would still need some way

00:39:57,800 --> 00:40:03,740
to update that right and you and like

00:40:00,920 --> 00:40:05,210
you need basil because basil is the only

00:40:03,740 --> 00:40:07,670
thing that's capable of doing the like

00:40:05,210 --> 00:40:09,700
somewhat complex work of parsing build

00:40:07,670 --> 00:40:12,560
files and like turning that into targets

00:40:09,700 --> 00:40:15,200
right so I basil is the one that has the

00:40:12,560 --> 00:40:18,950
in memory graph and you know probably if

00:40:15,200 --> 00:40:20,300
we if we wanted to be clever we would

00:40:18,950 --> 00:40:21,650
actually just like hack up the basil

00:40:20,300 --> 00:40:23,180
codebase to do this selection

00:40:21,650 --> 00:40:24,830
incrementally for us like that would be

00:40:23,180 --> 00:40:26,270
the next performance frontier because

00:40:24,830 --> 00:40:28,310
there's this whole point like why are we

00:40:26,270 --> 00:40:30,080
like serializing this into protobuf so

00:40:28,310 --> 00:40:32,630
we can put it in memory in another

00:40:30,080 --> 00:40:37,960
program and like hash it like something

00:40:32,630 --> 00:40:40,460
is a little silly here but I

00:40:37,960 --> 00:40:42,109
that's another scaling boundary I think

00:40:40,460 --> 00:40:43,940
which we all wish we could because

00:40:42,109 --> 00:40:47,690
because rumor has it that the least some

00:40:43,940 --> 00:40:51,859
companies have have in-memory graphs of

00:40:47,690 --> 00:40:53,960
a basil graph and you know what

00:40:51,859 --> 00:40:57,140
can think that maybe the community would

00:40:53,960 --> 00:40:58,910
also benefit from having I see I see I

00:40:57,140 --> 00:41:05,799
see you're you're like me this morning

00:40:58,910 --> 00:41:05,799
yeah I can't help you with Google sorry

00:41:09,369 --> 00:41:15,799
if I will change the action of some rule

00:41:13,670 --> 00:41:18,559
which is like I found in my PDF file

00:41:15,799 --> 00:41:22,160
who'd that be captured by a hash an

00:41:18,559 --> 00:41:24,440
input not import like the extreme like I

00:41:22,160 --> 00:41:27,769
can change the PDF file and say it was

00:41:24,440 --> 00:41:29,630
actually the Koshien rule well also the

00:41:27,769 --> 00:41:31,160
Starlog file yeah so that's actually a

00:41:29,630 --> 00:41:34,549
good question which was something ill

00:41:31,160 --> 00:41:36,589
I did for simplicity which is that basil

00:41:34,549 --> 00:41:38,660
sticks an extra magical attribute on

00:41:36,589 --> 00:41:41,690
every target which is called the rural

00:41:38,660 --> 00:41:44,390
implementation hash which is a hash of

00:41:41,690 --> 00:41:46,880
all the code that went into computing

00:41:44,390 --> 00:41:48,710
goes into computing that rule so if you

00:41:46,880 --> 00:41:50,779
just stick that attribute into your

00:41:48,710 --> 00:41:53,119
overall target hash then that takes care

00:41:50,779 --> 00:41:56,809
of that oh good and the second question

00:41:53,119 --> 00:42:00,920
is it's like hashing out like other two

00:41:56,809 --> 00:42:05,150
like it any open source so it's ours

00:42:00,920 --> 00:42:07,160
ours is not open source at the moment we

00:42:05,150 --> 00:42:13,640
proudly present have too many

00:42:07,160 --> 00:42:20,980
dependencies we can think about it thank

00:42:13,640 --> 00:42:23,390
you Oh tradition hey hi I work fuga I

00:42:20,980 --> 00:42:25,670
was wondering if you're using the right

00:42:23,390 --> 00:42:27,559
query options because the ones on the

00:42:25,670 --> 00:42:32,029
slides were not the right query options

00:42:27,559 --> 00:42:33,380
I also I also elided some stuff for

00:42:32,029 --> 00:42:36,890
that's not exactly what we're running

00:42:33,380 --> 00:42:38,960
but but what are the right query options

00:42:36,890 --> 00:42:41,119
I did a little bit of work on query

00:42:38,960 --> 00:42:42,769
performance earlier this year you know

00:42:41,119 --> 00:42:48,970
what's funny if you advance my slide by

00:42:42,769 --> 00:42:50,560
one and show it

00:42:48,970 --> 00:42:52,060
it'll probably be about what alphas

00:42:50,560 --> 00:42:55,540
gonna tell us about but maybe he's

00:42:52,060 --> 00:42:57,730
better graph was query there is graph

00:42:55,540 --> 00:42:59,800
this query something else yes what is

00:42:57,730 --> 00:43:04,330
well you should also use auto outputting

00:42:59,800 --> 00:43:08,530
with no a in all cases yeah I know and

00:43:04,330 --> 00:43:13,450
the cert is stream proto yes yes yes yes

00:43:08,530 --> 00:43:15,300
yes yes yes I yes I yes I meant to start

00:43:13,450 --> 00:43:17,440
using that but I didn't I didn't

00:43:15,300 --> 00:43:20,050
excellent thank you that's a good point

00:43:17,440 --> 00:43:22,420
though yeah so just for everyone else

00:43:20,050 --> 00:43:25,990
here grassless query avoids making a

00:43:22,420 --> 00:43:28,120
copy that's what it says here and the

00:43:25,990 --> 00:43:30,940
the advantage of using stream proto is

00:43:28,120 --> 00:43:33,670
that it doesn't construct a single giant

00:43:30,940 --> 00:43:36,130
proto in memory right you get a problem

00:43:33,670 --> 00:43:38,710
when you get to like two gigabyte

00:43:36,130 --> 00:43:40,720
proto's because then the int isn't large

00:43:38,710 --> 00:43:43,300
enough to address the entire product and

00:43:40,720 --> 00:43:45,220
then it'll fail with an out of memory

00:43:43,300 --> 00:43:46,990
error because it can't allocate in an

00:43:45,220 --> 00:43:48,670
array that's large enough anyway I think

00:43:46,990 --> 00:43:51,370
the stream proto is a very very good

00:43:48,670 --> 00:43:54,310
hint it's always that these are

00:43:51,370 --> 00:43:55,960
documentation and and definitely the set

00:43:54,310 --> 00:43:57,540
of flags we have need some improvement

00:43:55,960 --> 00:44:00,850
here

00:43:57,540 --> 00:44:03,280
of course yeah hello I'm John from

00:44:00,850 --> 00:44:05,470
stripe two questions first would it be

00:44:03,280 --> 00:44:08,440
correct to say that this is a mitigation

00:44:05,470 --> 00:44:12,310
for lack of remote test execution oh no

00:44:08,440 --> 00:44:14,560
because because as I I was trying to say

00:44:12,310 --> 00:44:16,780
this is beginning but if we we we never

00:44:14,560 --> 00:44:19,780
want to run basil test slash slash dot

00:44:16,780 --> 00:44:21,910
dot because that does already does a

00:44:19,780 --> 00:44:24,550
huge amount of work on every target in

00:44:21,910 --> 00:44:27,130
the in the base of like all the work up

00:44:24,550 --> 00:44:28,930
to actually executing it and so like we

00:44:27,130 --> 00:44:32,410
want we want to be able to cut out

00:44:28,930 --> 00:44:34,540
eliminate tests like at the many levels

00:44:32,410 --> 00:44:35,650
but like sort of the work the level

00:44:34,540 --> 00:44:38,860
where we have to do the least amount of

00:44:35,650 --> 00:44:41,710
work on it and so we don't we don't want

00:44:38,860 --> 00:44:43,690
to analyze all rules we just want we

00:44:41,710 --> 00:44:46,360
want to be able to prove that they can't

00:44:43,690 --> 00:44:48,910
be affected sort of as quickly and is

00:44:46,360 --> 00:44:50,140
with the least amount of resources as as

00:44:48,910 --> 00:44:52,780
as possible

00:44:50,140 --> 00:44:54,940
and a notice about Jeff seem used with

00:44:52,780 --> 00:44:57,190
some successes having sort of metadata

00:44:54,940 --> 00:44:59,440
files at different levels of the source

00:44:57,190 --> 00:45:01,030
file system where you say anything under

00:44:59,440 --> 00:45:02,270
this directory needs to run these tests

00:45:01,030 --> 00:45:03,860
and then if you make

00:45:02,270 --> 00:45:05,750
changes outside of that directory you

00:45:03,860 --> 00:45:06,770
may not necessarily need to add that

00:45:05,750 --> 00:45:08,060
test to your test set

00:45:06,770 --> 00:45:12,250
well that sounds like a workaround for

00:45:08,060 --> 00:45:18,190
something else okay all I didn't answer

00:45:12,250 --> 00:45:18,190

YouTube URL: https://www.youtube.com/watch?v=9Dk7mtIm7_A


