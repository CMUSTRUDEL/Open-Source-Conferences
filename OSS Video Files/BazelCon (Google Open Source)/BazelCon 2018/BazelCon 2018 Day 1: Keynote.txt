Title: BazelCon 2018 Day 1: Keynote
Publication date: 2018-11-01
Playlist: BazelCon 2018
Description: 
	Melody Meckfessel, Google VP of Engineering event: Bazelcon 2018; re_ty: Publish; product: Open Source - General; fullname: Melody Meckfessel;
Captions: 
	00:00:02,550 --> 00:00:07,480
hello my name is Jeff Cox I am the

00:00:05,740 --> 00:00:11,019
engineering director in charge of the

00:00:07,480 --> 00:00:14,620
build test deploy group at Google which

00:00:11,019 --> 00:00:16,509
includes the Basel project I'm here to

00:00:14,620 --> 00:00:20,350
introduce our keynote speaker for today

00:00:16,509 --> 00:00:23,800
Meli my vessel who is our vice president

00:00:20,350 --> 00:00:24,789
of engineering I've had the luxury of

00:00:23,800 --> 00:00:27,730
working with melody now for I think

00:00:24,789 --> 00:00:29,500
seven years enjoyed every minute of it

00:00:27,730 --> 00:00:32,439
and she is here to talk to us about

00:00:29,500 --> 00:00:33,910
testing how testing yields velocity and

00:00:32,439 --> 00:00:37,710
I will have the important job of running

00:00:33,910 --> 00:00:41,950
the clicker thanks dad can you hear me

00:00:37,710 --> 00:00:45,790
okay good I can't see you unfortunately

00:00:41,950 --> 00:00:49,719
but excellent thanks so much Jeff it's

00:00:45,790 --> 00:00:51,160
it's really an honor to be here today to

00:00:49,719 --> 00:00:53,680
work with Jeff and to work with the team

00:00:51,160 --> 00:00:57,399
and to be part of what is a growing

00:00:53,680 --> 00:01:00,219
community around Basel I lead the DevOps

00:00:57,399 --> 00:01:03,640
team at Google and really what that

00:01:00,219 --> 00:01:07,229
includes is you know source control

00:01:03,640 --> 00:01:09,520
management build test deployment

00:01:07,229 --> 00:01:11,950
operations for services running in

00:01:09,520 --> 00:01:14,229
production for almost all Google

00:01:11,950 --> 00:01:16,900
developers and that includes chrome and

00:01:14,229 --> 00:01:18,869
Android and teams doing open source

00:01:16,900 --> 00:01:22,799
development like tensorflow

00:01:18,869 --> 00:01:26,740
but today I wanted to focus on testing

00:01:22,799 --> 00:01:30,900
near and dear to my heart and talk a

00:01:26,740 --> 00:01:34,560
little bit about the benefits of Basel

00:01:30,900 --> 00:01:37,090
so if you could go to the next slide and

00:01:34,560 --> 00:01:41,380
then can you put the slides back on the

00:01:37,090 --> 00:01:44,590
projector there you go thank you so we

00:01:41,380 --> 00:01:48,009
know you know as engineers the benefits

00:01:44,590 --> 00:01:51,310
of testing pretty well-known you know

00:01:48,009 --> 00:01:54,340
makes our code better which in the end

00:01:51,310 --> 00:01:55,570
makes our users happier and I I can't

00:01:54,340 --> 00:01:57,640
I'm not gonna be able to see the the

00:01:55,570 --> 00:02:01,030
hands raised but how many people in the

00:01:57,640 --> 00:02:06,219
crowd in the audience have carried a

00:02:01,030 --> 00:02:07,760
pager Jeff what's the what's the

00:02:06,219 --> 00:02:11,530
approximate

00:02:07,760 --> 00:02:14,840
some problem maybe not enough okay

00:02:11,530 --> 00:02:17,000
I just want to point out the uptime

00:02:14,840 --> 00:02:19,070
right the quality of the code that we

00:02:17,000 --> 00:02:23,240
write we wanted to make it out for our

00:02:19,070 --> 00:02:24,800
end users and you know when I'm gonna

00:02:23,240 --> 00:02:29,650
hit on this point a couple of times in

00:02:24,800 --> 00:02:32,060
this talk but when we compromise and we

00:02:29,650 --> 00:02:33,680
implement workarounds we're impacting

00:02:32,060 --> 00:02:35,900
the quality of what we're delivering to

00:02:33,680 --> 00:02:36,500
our end users and if we don't carry the

00:02:35,900 --> 00:02:39,080
pager

00:02:36,500 --> 00:02:40,880
we're probably impacting you know the

00:02:39,080 --> 00:02:43,490
humans that are keeping the service up

00:02:40,880 --> 00:02:45,470
and running so I think those are

00:02:43,490 --> 00:02:49,130
important motivators to remember that

00:02:45,470 --> 00:02:53,570
this has an impact on on multiple people

00:02:49,130 --> 00:02:55,850
colleagues our users and you know the

00:02:53,570 --> 00:02:59,420
surest way to make I think any developer

00:02:55,850 --> 00:03:01,070
angry is to slow them down and so you

00:02:59,420 --> 00:03:03,860
know I think that's where automation

00:03:01,070 --> 00:03:06,350
comes into play we can get the quality

00:03:03,860 --> 00:03:08,120
that we need to at scale and have this

00:03:06,350 --> 00:03:10,430
sustainable growth where we keep making

00:03:08,120 --> 00:03:13,760
our code better we keep growing our

00:03:10,430 --> 00:03:15,680
application and we keep we keep the

00:03:13,760 --> 00:03:17,920
sustainability around how to how'd it

00:03:15,680 --> 00:03:21,110
have that growth in an interactional way

00:03:17,920 --> 00:03:23,510
so you know there's no pros and cons on

00:03:21,110 --> 00:03:26,600
here it's all it's all good and it's all

00:03:23,510 --> 00:03:31,880
creamy why we why we should test it so

00:03:26,600 --> 00:03:35,870
next slide so great we're writing tasks

00:03:31,880 --> 00:03:42,230
we're testing all things but next slide

00:03:35,870 --> 00:03:44,060
it's not quite the full story so you

00:03:42,230 --> 00:03:45,590
know Google has done some studies and

00:03:44,060 --> 00:03:48,050
there's many that are published out

00:03:45,590 --> 00:03:51,500
there across hundreds of organizations

00:03:48,050 --> 00:03:53,930
and we've found that from through that

00:03:51,500 --> 00:03:57,470
research that the testing practices are

00:03:53,930 --> 00:03:59,900
really falling short of what of what you

00:03:57,470 --> 00:04:02,810
know the ambitions or the targets are

00:03:59,900 --> 00:04:06,170
for teams so very few teams are running

00:04:02,810 --> 00:04:08,270
tasks at every code change and even

00:04:06,170 --> 00:04:10,340
fewer have instrumented their entire

00:04:08,270 --> 00:04:12,800
code base to be able to exercise every

00:04:10,340 --> 00:04:15,350
code path so it's very you know while

00:04:12,800 --> 00:04:18,109
it's very common for most teams to run

00:04:15,350 --> 00:04:21,739
kind of like a full test suite once a

00:04:18,109 --> 00:04:23,750
day or maybe less than that it's

00:04:21,739 --> 00:04:26,900
you know that the completeness of that

00:04:23,750 --> 00:04:30,590
test suite is is usually not sufficient

00:04:26,900 --> 00:04:34,190
so even if we know it's good we're not

00:04:30,590 --> 00:04:37,190
doing it enough and it is impacting

00:04:34,190 --> 00:04:39,410
impacting quality so let's do some let's

00:04:37,190 --> 00:04:41,030
do some root cause analysis oh my I

00:04:39,410 --> 00:04:43,639
aren't we testing if we know as

00:04:41,030 --> 00:04:47,360
engineers that it helps us find defects

00:04:43,639 --> 00:04:49,580
before making an out to re end-users we

00:04:47,360 --> 00:04:51,979
know it helps our velocity why aren't we

00:04:49,580 --> 00:04:56,690
doing it we have very good intentions as

00:04:51,979 --> 00:05:03,139
engineers to test so next slide what we

00:04:56,690 --> 00:05:04,849
found keep going is that we sort of hit

00:05:03,139 --> 00:05:09,139
this reality which is a set of

00:05:04,849 --> 00:05:12,650
trade-offs that we have to make so we

00:05:09,139 --> 00:05:15,199
add tasks we increased our test coverage

00:05:12,650 --> 00:05:19,970
but then testing takes more time and

00:05:15,199 --> 00:05:22,729
resources so it starts to become a drag

00:05:19,970 --> 00:05:26,000
on our productivity and our arm velocity

00:05:22,729 --> 00:05:29,060
to get features out the door and so you

00:05:26,000 --> 00:05:32,000
know probably most of us in the audience

00:05:29,060 --> 00:05:34,729
have kicked a build-off and gone and

00:05:32,000 --> 00:05:36,680
done something had lunch had a coffee

00:05:34,729 --> 00:05:39,650
talked to front and went for a walk and

00:05:36,680 --> 00:05:42,020
come back and it's potentially still

00:05:39,650 --> 00:05:43,940
running and so we start to make these

00:05:42,020 --> 00:05:45,680
decision well maybe we shouldn't test

00:05:43,940 --> 00:05:48,800
everything maybe we should just test

00:05:45,680 --> 00:05:52,759
some things and that gets us into a

00:05:48,800 --> 00:05:56,750
trade-off situation so next slide so we

00:05:52,759 --> 00:05:59,780
find ourselves in this conundrum where

00:05:56,750 --> 00:06:02,210
more testing leads to higher overhead it

00:05:59,780 --> 00:06:04,669
leads to less defects which is what we

00:06:02,210 --> 00:06:07,340
want but as you increase your test

00:06:04,669 --> 00:06:09,560
practices your code gets better and

00:06:07,340 --> 00:06:12,139
better right but your build and tests

00:06:09,560 --> 00:06:14,030
may take longer and longer and that

00:06:12,139 --> 00:06:15,949
means you need more and more hardware

00:06:14,030 --> 00:06:18,710
you need more and more resources to be

00:06:15,949 --> 00:06:20,750
able to execute those tests so this puts

00:06:18,710 --> 00:06:23,030
puts you as a developer you as a

00:06:20,750 --> 00:06:25,759
development team you as an engineering

00:06:23,030 --> 00:06:28,190
company in a really tough kind of

00:06:25,759 --> 00:06:30,139
situation where should you take the

00:06:28,190 --> 00:06:31,260
extra time to run a bunch of tests that

00:06:30,139 --> 00:06:35,210
main

00:06:31,260 --> 00:06:37,950
reveal any problems right or should you

00:06:35,210 --> 00:06:39,870
you know get that application out to

00:06:37,950 --> 00:06:44,460
your users as quickly as you can and

00:06:39,870 --> 00:06:46,890
risk shipping a defect and so you know

00:06:44,460 --> 00:06:48,660
for the human that's carrying the pager

00:06:46,890 --> 00:06:50,910
on your team that's gonna have to deal

00:06:48,660 --> 00:06:54,120
with the defect or for the impact to the

00:06:50,910 --> 00:06:56,400
user communities of that defect it's

00:06:54,120 --> 00:06:59,010
it's a tough choice it's a tough choice

00:06:56,400 --> 00:07:00,720
to make and so I think what a lot of us

00:06:59,010 --> 00:07:04,170
are trying to figure out is what is that

00:07:00,720 --> 00:07:05,550
what is the sweet spot when you have to

00:07:04,170 --> 00:07:07,860
make this decision around these

00:07:05,550 --> 00:07:09,780
trade-offs you know you can ship you can

00:07:07,860 --> 00:07:12,810
ship it right now or you can wait and

00:07:09,780 --> 00:07:14,220
ship it correctly and so you know going

00:07:12,810 --> 00:07:17,160
back to some of the research that we've

00:07:14,220 --> 00:07:18,930
done even teams with you know elite

00:07:17,160 --> 00:07:21,960
DevOps teams that have the most

00:07:18,930 --> 00:07:24,570
sophisticated testing practices their

00:07:21,960 --> 00:07:26,880
number one challenge that stated is

00:07:24,570 --> 00:07:30,030
balancing test frequency from resources

00:07:26,880 --> 00:07:32,760
right because it's Costin time and so

00:07:30,030 --> 00:07:38,550
we're we're trying to figure out what is

00:07:32,760 --> 00:07:40,500
the right balance there so next slide so

00:07:38,550 --> 00:07:43,230
if we take a step back and talk about

00:07:40,500 --> 00:07:45,300
why we test you know I think this is

00:07:43,230 --> 00:07:48,450
pretty clear like we want to create a

00:07:45,300 --> 00:07:50,010
great user experience for the code that

00:07:48,450 --> 00:07:52,500
we're writing for the application that

00:07:50,010 --> 00:07:54,510
our users are using and we want to avoid

00:07:52,500 --> 00:07:56,880
the operational issues right because

00:07:54,510 --> 00:07:58,590
customers users expect high up times

00:07:56,880 --> 00:08:01,650
just think of the apps that you yourself

00:07:58,590 --> 00:08:03,480
use so we're really trying to get rid of

00:08:01,650 --> 00:08:06,030
the errors in our own code but we're

00:08:03,480 --> 00:08:09,990
also struggling with what our

00:08:06,030 --> 00:08:12,770
dependencies are so you know these days

00:08:09,990 --> 00:08:17,430
very few projects to go to the next

00:08:12,770 --> 00:08:18,630
build Jeff very few projects open the

00:08:17,430 --> 00:08:21,480
code all the way down to the hardware

00:08:18,630 --> 00:08:24,600
right we are as as developers depending

00:08:21,480 --> 00:08:27,240
more and more on libraries on services

00:08:24,600 --> 00:08:29,670
that are not developed by us that are

00:08:27,240 --> 00:08:31,320
open-source and that's great right

00:08:29,670 --> 00:08:33,360
because we get to reuse code and we get

00:08:31,320 --> 00:08:35,610
to focus on the thing that you know that

00:08:33,360 --> 00:08:38,099
we're good at that we want to build but

00:08:35,610 --> 00:08:41,849
even really small systems have a ton of

00:08:38,099 --> 00:08:44,670
dependencies now and that depending on

00:08:41,849 --> 00:08:48,030
something you don't own can be really

00:08:44,670 --> 00:08:50,310
challenging because you're we're all

00:08:48,030 --> 00:08:53,250
having to handle kind of this very rapid

00:08:50,310 --> 00:08:56,670
state of change on things that we you

00:08:53,250 --> 00:09:00,450
know that we just don't control next

00:08:56,670 --> 00:09:02,520
slide so what's our ideal where our

00:09:00,450 --> 00:09:05,270
ideal really is that we're integrating

00:09:02,520 --> 00:09:08,040
those dependencies right we are often

00:09:05,270 --> 00:09:11,730
integration often and everywhere right

00:09:08,040 --> 00:09:14,490
so we're trying to make sure that we

00:09:11,730 --> 00:09:16,980
don't have to do a ton of you know

00:09:14,490 --> 00:09:18,210
pre-release testing we're we're just

00:09:16,980 --> 00:09:19,980
making sure that we're testing the

00:09:18,210 --> 00:09:21,510
dependencies that we have and we're

00:09:19,980 --> 00:09:24,690
doing that everywhere and this is really

00:09:21,510 --> 00:09:27,960
what underlies the whole practice around

00:09:24,690 --> 00:09:30,870
continuous integration which is really

00:09:27,960 --> 00:09:32,720
to increase our velocity and you know

00:09:30,870 --> 00:09:34,830
there's an interesting part here around

00:09:32,720 --> 00:09:37,800
security right so if we're trying to

00:09:34,830 --> 00:09:39,690
protect ourselves that integration of

00:09:37,800 --> 00:09:42,900
dependencies is going to require testing

00:09:39,690 --> 00:09:45,510
and if we're doing it frequently it's

00:09:42,900 --> 00:09:48,510
gonna require even more testing so you

00:09:45,510 --> 00:09:51,930
could just you can see how this all you

00:09:48,510 --> 00:09:56,160
know really just builds on itself next

00:09:51,930 --> 00:09:58,770
slide you know and and when we talk

00:09:56,160 --> 00:10:01,590
about CI right where we're continuous

00:09:58,770 --> 00:10:03,660
integration all the time frequently it

00:10:01,590 --> 00:10:05,760
can be particularly challenging so you

00:10:03,660 --> 00:10:08,760
can see right as the size of your

00:10:05,760 --> 00:10:10,950
codebase increases and the frequency of

00:10:08,760 --> 00:10:13,550
your testing your integration increases

00:10:10,950 --> 00:10:16,110
so does your testing overhead right like

00:10:13,550 --> 00:10:18,390
and then that and then that starts to

00:10:16,110 --> 00:10:19,890
drag on developer productivity so the

00:10:18,390 --> 00:10:21,930
thing about dependency is is that in

00:10:19,890 --> 00:10:23,640
order to defend to really bet those

00:10:21,930 --> 00:10:25,140
dependencies every time you integrate

00:10:23,640 --> 00:10:27,350
you need to make sure that you're

00:10:25,140 --> 00:10:31,260
testing everything that they depend on

00:10:27,350 --> 00:10:34,590
and you know this just is leading to a

00:10:31,260 --> 00:10:37,080
lot of testing time in our development

00:10:34,590 --> 00:10:38,790
process so next slide so where do we

00:10:37,080 --> 00:10:41,880
want to be how do we find that sweet

00:10:38,790 --> 00:10:44,820
spot where we're testing the right

00:10:41,880 --> 00:10:47,190
amount to improve our test hygiene

00:10:44,820 --> 00:10:50,160
without these negative effects of

00:10:47,190 --> 00:10:53,160
slowing us down hurting our productivity

00:10:50,160 --> 00:10:54,870
or radically increasing our test

00:10:53,160 --> 00:10:58,200
infrastructure and the costs associated

00:10:54,870 --> 00:11:00,480
with that test overhead so

00:10:58,200 --> 00:11:03,960
slide so I want to tell you a little bit

00:11:00,480 --> 00:11:06,900
about how we do automated software

00:11:03,960 --> 00:11:09,000
testing at Google and how bazel plays a

00:11:06,900 --> 00:11:12,060
key role in this so at Google we've

00:11:09,000 --> 00:11:14,580
invested a lot in allowing developers to

00:11:12,060 --> 00:11:16,830
test in a way that helps us move very

00:11:14,580 --> 00:11:19,320
quickly and hopefully not break things

00:11:16,830 --> 00:11:21,690
on a really large code base so

00:11:19,320 --> 00:11:22,830
automation is at the key of this we

00:11:21,690 --> 00:11:26,160
couldn't do it

00:11:22,830 --> 00:11:28,920
I think engineers would be incredibly

00:11:26,160 --> 00:11:32,160
unhappy if we were slowing down their

00:11:28,920 --> 00:11:33,840
velocity so we've added automation and a

00:11:32,160 --> 00:11:37,140
lot of that ties back to the to the

00:11:33,840 --> 00:11:39,330
build system or basil and you know we've

00:11:37,140 --> 00:11:42,600
learned a lot from working with them at

00:11:39,330 --> 00:11:44,070
Google engineering community and so part

00:11:42,600 --> 00:11:46,370
of what we're doing is we're starting to

00:11:44,070 --> 00:11:49,050
take these out into external communities

00:11:46,370 --> 00:11:51,570
basil is a great example of that you

00:11:49,050 --> 00:11:54,120
know I remember Jeff and I and various

00:11:51,570 --> 00:11:55,830
members of the team were like we should

00:11:54,120 --> 00:11:57,720
really open-source this this is

00:11:55,830 --> 00:12:00,270
something that everyone could contribute

00:11:57,720 --> 00:12:02,880
to and make better and then there are

00:12:00,270 --> 00:12:05,580
other tools like cloud build you know

00:12:02,880 --> 00:12:09,360
build CI and CD in the cloud that were

00:12:05,580 --> 00:12:13,410
making available on TCP in our cloud

00:12:09,360 --> 00:12:15,030
platform so I'm gonna just talk for a

00:12:13,410 --> 00:12:17,850
couple more minutes and then really we

00:12:15,030 --> 00:12:21,480
want to get into doing demo features but

00:12:17,850 --> 00:12:23,100
I just you know wanted to say the whole

00:12:21,480 --> 00:12:25,200
reason we're doing this conference

00:12:23,100 --> 00:12:26,940
well reason we open-source was so that

00:12:25,200 --> 00:12:29,160
we could build it together so I know

00:12:26,940 --> 00:12:31,140
myself and everyone on the team is

00:12:29,160 --> 00:12:34,320
really interested in hearing one of

00:12:31,140 --> 00:12:37,890
these ideas resonate with you so next

00:12:34,320 --> 00:12:42,030
slide so this is I call this the

00:12:37,890 --> 00:12:43,650
vanities you know numbers are

00:12:42,030 --> 00:12:46,400
interesting I think the thing that's

00:12:43,650 --> 00:12:49,140
there's a couple interesting bits here

00:12:46,400 --> 00:12:51,000
but for any one of these like for the

00:12:49,140 --> 00:12:54,060
commits for the builds for the number of

00:12:51,000 --> 00:12:56,190
tasks for the code reviews I don't think

00:12:54,060 --> 00:12:58,110
we could do any of this without the

00:12:56,190 --> 00:13:03,300
infrastructure and the automation behind

00:12:58,110 --> 00:13:05,370
it so we my team has really just put the

00:13:03,300 --> 00:13:07,890
focus on automation as much as we can

00:13:05,370 --> 00:13:09,870
automate as much we're going to talk in

00:13:07,890 --> 00:13:12,030
a second about intelligent test

00:13:09,870 --> 00:13:13,920
execution making the best you

00:13:12,030 --> 00:13:18,480
the resources so that engineers can move

00:13:13,920 --> 00:13:20,730
quickly and next slide so you know is

00:13:18,480 --> 00:13:24,360
any of this Google experience relevant

00:13:20,730 --> 00:13:27,180
to you I think likely it is now the the

00:13:24,360 --> 00:13:30,330
code the code size you know the scale or

00:13:27,180 --> 00:13:34,500
the the increase of the code base itself

00:13:30,330 --> 00:13:36,360
made you know are different possibly but

00:13:34,500 --> 00:13:38,280
the benefit of the test automation I

00:13:36,360 --> 00:13:40,560
think is still there for all of us it's

00:13:38,280 --> 00:13:43,410
it's it's important for everyone in the

00:13:40,560 --> 00:13:46,290
community because if the intent is to

00:13:43,410 --> 00:13:48,990
get those features out to our users

00:13:46,290 --> 00:13:51,210
quickly with the expectations that they

00:13:48,990 --> 00:13:56,160
have of quality and about time and I've

00:13:51,210 --> 00:14:01,170
you know security I think that's really

00:13:56,160 --> 00:14:05,040
you know a common a common goal that

00:14:01,170 --> 00:14:08,310
unites all of us in this space and basil

00:14:05,040 --> 00:14:11,010
can basil can help with that so our test

00:14:08,310 --> 00:14:12,690
next slide are our test automation is

00:14:11,010 --> 00:14:14,190
built around some principles and so I

00:14:12,690 --> 00:14:18,330
wanted to share a little bit of those

00:14:14,190 --> 00:14:19,890
principles and those principles factored

00:14:18,330 --> 00:14:22,350
into the decisions that we make about

00:14:19,890 --> 00:14:25,050
how we build the infrastructure and they

00:14:22,350 --> 00:14:27,150
really build on each other in terms of

00:14:25,050 --> 00:14:30,240
how we think about the build system and

00:14:27,150 --> 00:14:32,910
the role that basil plays in it next

00:14:30,240 --> 00:14:35,850
slide so we're gonna start to the left

00:14:32,910 --> 00:14:37,950
and move our way across so first we want

00:14:35,850 --> 00:14:39,750
to run only those tasks needed to

00:14:37,950 --> 00:14:43,980
validate a change so why is that

00:14:39,750 --> 00:14:47,270
important next slide so as you know in

00:14:43,980 --> 00:14:50,010
basil we declare these logical groups of

00:14:47,270 --> 00:14:52,380
sources and tasks and we call them

00:14:50,010 --> 00:14:55,010
targets and the idea here is how do we

00:14:52,380 --> 00:14:58,650
break down the source into small

00:14:55,010 --> 00:15:00,510
autonomous units that basil can

00:14:58,650 --> 00:15:03,630
understand right that we can able we can

00:15:00,510 --> 00:15:06,750
process as efficiently as possible next

00:15:03,630 --> 00:15:10,020
slide so then we take these targets and

00:15:06,750 --> 00:15:13,860
we determine the units of build and test

00:15:10,020 --> 00:15:16,500
execution and each unit of execution we

00:15:13,860 --> 00:15:18,330
call that an action right so you can see

00:15:16,500 --> 00:15:20,850
the action that we're gonna take and

00:15:18,330 --> 00:15:25,570
that has a fully specified list of you

00:15:20,850 --> 00:15:27,310
know inputs and outputs next slide

00:15:25,570 --> 00:15:30,820
so then those actions get pulled

00:15:27,310 --> 00:15:32,529
together into a graph and the output of

00:15:30,820 --> 00:15:34,630
one action becomes the target or the

00:15:32,529 --> 00:15:36,579
input to the next one

00:15:34,630 --> 00:15:40,029
and we treat you see in this diagram

00:15:36,579 --> 00:15:43,000
here right we treat test actions just

00:15:40,029 --> 00:15:45,519
like compiled actions so we're treating

00:15:43,000 --> 00:15:47,529
them the same way I build and test build

00:15:45,519 --> 00:15:53,110
and test actions leading to the artifact

00:15:47,529 --> 00:15:55,870
that we want to create so next slide so

00:15:53,110 --> 00:15:57,940
we really again sort of principle run

00:15:55,870 --> 00:15:59,889
the test that matter make best use of

00:15:57,940 --> 00:16:02,560
the resources have the fastest velocity

00:15:59,889 --> 00:16:05,139
so let's say that you built and tested

00:16:02,560 --> 00:16:07,509
your code once and this is the graph of

00:16:05,139 --> 00:16:11,620
action so say you make a change and if

00:16:07,509 --> 00:16:13,149
you can just click Jeff and then and

00:16:11,620 --> 00:16:15,130
then you basically you need to figure

00:16:13,149 --> 00:16:16,449
out what you rebuild in task of these

00:16:15,130 --> 00:16:18,940
elements that everything that they

00:16:16,449 --> 00:16:21,880
depend on so click again and then you

00:16:18,940 --> 00:16:23,110
can see here with the original graph we

00:16:21,880 --> 00:16:24,850
don't have to rebuild and test

00:16:23,110 --> 00:16:26,860
everything right we're checking the

00:16:24,850 --> 00:16:28,480
dependencies and making sure that we're

00:16:26,860 --> 00:16:32,910
only testing the things that need to be

00:16:28,480 --> 00:16:36,430
that need to be retested so next slide

00:16:32,910 --> 00:16:38,620
so that graph and the composition of

00:16:36,430 --> 00:16:41,980
that graph is is really important

00:16:38,620 --> 00:16:44,170
because you know this determines the

00:16:41,980 --> 00:16:47,649
sort of development time performance

00:16:44,170 --> 00:16:51,250
that you know the that we're gonna

00:16:47,649 --> 00:16:53,380
execute on and you know you don't we're

00:16:51,250 --> 00:16:56,519
not gonna construct the full graphs with

00:16:53,380 --> 00:16:59,680
it you know ten million nodes but

00:16:56,519 --> 00:17:01,420
constructing that graph and then being

00:16:59,680 --> 00:17:03,100
able to understand like the small

00:17:01,420 --> 00:17:06,429
fraction of the graph that we need to

00:17:03,100 --> 00:17:08,409
test is really important at Google

00:17:06,429 --> 00:17:11,339
we construct the graph across all

00:17:08,409 --> 00:17:13,750
dependencies multiple languages multiple

00:17:11,339 --> 00:17:15,939
platforms and it's not just about the

00:17:13,750 --> 00:17:17,620
code it's about the tools as well so

00:17:15,939 --> 00:17:21,400
we're really trying to model all of

00:17:17,620 --> 00:17:24,010
those targets and actions and the

00:17:21,400 --> 00:17:26,650
dependencies between them so that we are

00:17:24,010 --> 00:17:30,940
minimizing the number of tests that we

00:17:26,650 --> 00:17:34,299
need to run all right next slide so the

00:17:30,940 --> 00:17:37,900
next principle so we want to have with a

00:17:34,299 --> 00:17:41,679
separate the well-behaved tests for

00:17:37,900 --> 00:17:43,900
the not so well-behaved tests so next

00:17:41,679 --> 00:17:46,500
slide so we have two big buckets here to

00:17:43,900 --> 00:17:50,710
think about hermetic and deterministic

00:17:46,500 --> 00:17:53,320
and non meta can deterministic so we

00:17:50,710 --> 00:17:56,980
want to ensure that as many tasks are in

00:17:53,320 --> 00:17:59,080
this HD category as possible and by

00:17:56,980 --> 00:18:02,650
separating them out we can only run them

00:17:59,080 --> 00:18:08,020
when we need to Basel still supports

00:18:02,650 --> 00:18:10,779
being able to run non HD tests but

00:18:08,020 --> 00:18:12,700
really we if you click the next slide we

00:18:10,779 --> 00:18:16,980
really only want to be running those HD

00:18:12,700 --> 00:18:19,510
tests when when dependencies change so

00:18:16,980 --> 00:18:21,039
again really trying to figure out the

00:18:19,510 --> 00:18:25,169
highest quality test and that we're

00:18:21,039 --> 00:18:28,480
running them constantly next slide okay

00:18:25,169 --> 00:18:31,390
reproducibility super important in terms

00:18:28,480 --> 00:18:33,190
of controlling the tests the test

00:18:31,390 --> 00:18:37,510
environment where we're executing the

00:18:33,190 --> 00:18:40,720
test so next slide so really is about

00:18:37,510 --> 00:18:44,710
ensuring that her you know hermetic and

00:18:40,720 --> 00:18:46,809
deterministic behavior of tests so we

00:18:44,710 --> 00:18:50,470
design the runners and the execution

00:18:46,809 --> 00:18:53,049
environments to support this sandbox is

00:18:50,470 --> 00:18:54,909
things like emulators for mobile devices

00:18:53,049 --> 00:18:58,630
so that things are ready to go and

00:18:54,909 --> 00:19:02,620
controlled I know at Google you know

00:18:58,630 --> 00:19:04,330
flaky test tests are still an issue when

00:19:02,620 --> 00:19:06,429
you you know developers may think that

00:19:04,330 --> 00:19:07,899
they're hermetic and deterministic but

00:19:06,429 --> 00:19:10,240
they're not when you look at the data

00:19:07,899 --> 00:19:12,250
when you look at the execution so we've

00:19:10,240 --> 00:19:13,779
defined some services that help spot

00:19:12,250 --> 00:19:16,809
those flaky tests so that we can take

00:19:13,779 --> 00:19:18,429
action on them and you know they're met

00:19:16,809 --> 00:19:20,649
their basal features that I'm sure we'll

00:19:18,429 --> 00:19:23,080
talk about today that mitigate that

00:19:20,649 --> 00:19:25,510
flakiness doing things like

00:19:23,080 --> 00:19:27,399
automatically running on failure and

00:19:25,510 --> 00:19:30,669
being able to flag you know the

00:19:27,399 --> 00:19:32,380
flakiness over time so those are

00:19:30,669 --> 00:19:36,240
important principles and testing that

00:19:32,380 --> 00:19:40,510
we've we factored into basal next slide

00:19:36,240 --> 00:19:42,340
so we want to distribute you know test

00:19:40,510 --> 00:19:44,590
execution and we want to cache as much

00:19:42,340 --> 00:19:47,559
as possible so again the testing is

00:19:44,590 --> 00:19:50,260
about quality right while maintaining

00:19:47,559 --> 00:19:51,520
our velocity we

00:19:50,260 --> 00:19:55,000
you want to make best use of the

00:19:51,520 --> 00:19:56,590
resources that we have so next slide so

00:19:55,000 --> 00:19:59,860
this is the graph that we just saw a

00:19:56,590 --> 00:20:02,860
minute ago and the green nodes or the or

00:19:59,860 --> 00:20:04,870
the minimal set that we need to rerun so

00:20:02,860 --> 00:20:08,440
if you click again I think it builds

00:20:04,870 --> 00:20:09,700
yeah these blue and so you can see here

00:20:08,440 --> 00:20:12,190
right there's no dependencies between

00:20:09,700 --> 00:20:16,330
them so we can you know we can run them

00:20:12,190 --> 00:20:19,120
in parallel and speed things up next

00:20:16,330 --> 00:20:20,890
slide and this was the other graph from

00:20:19,120 --> 00:20:23,140
a second ago

00:20:20,890 --> 00:20:25,060
these actions right each one of these

00:20:23,140 --> 00:20:26,950
actions can either be executed locally

00:20:25,060 --> 00:20:30,900
on whatever the machine is that you're

00:20:26,950 --> 00:20:35,680
running basil or remotely in the cloud

00:20:30,900 --> 00:20:39,850
so we're trying to design for X parallel

00:20:35,680 --> 00:20:42,070
execution next slide and we compute a

00:20:39,850 --> 00:20:43,930
signature for each of the action based

00:20:42,070 --> 00:20:46,870
on the inputs and the functions that

00:20:43,930 --> 00:20:49,240
that it computes and then the results of

00:20:46,870 --> 00:20:51,490
these actions we cache them

00:20:49,240 --> 00:20:53,260
so that if the inputs don't change we

00:20:51,490 --> 00:20:56,230
don't have to regenerate the output and

00:20:53,260 --> 00:20:59,590
these cached actions are shared across

00:20:56,230 --> 00:21:01,750
users and basil instances so caching is

00:20:59,590 --> 00:21:03,550
it's just a critical part of how we've

00:21:01,750 --> 00:21:06,600
been able to control the test costs

00:21:03,550 --> 00:21:11,320
within Google yeah there you go

00:21:06,600 --> 00:21:15,280
caching has been a huge win for test

00:21:11,320 --> 00:21:20,050
execution and and just performance and

00:21:15,280 --> 00:21:22,120
expectations of the users of basil next

00:21:20,050 --> 00:21:26,170
slide all right just a couple more

00:21:22,120 --> 00:21:27,970
slides then we'll do the demo so point I

00:21:26,170 --> 00:21:29,910
want to make here that I think we we are

00:21:27,970 --> 00:21:32,770
I already mentioned earlier is that

00:21:29,910 --> 00:21:34,710
basil does interoperate with different

00:21:32,770 --> 00:21:39,220
execution environments so you can see

00:21:34,710 --> 00:21:42,010
here you know Mac OS Windows browsers

00:21:39,220 --> 00:21:43,660
mobile emulators physical devices it's

00:21:42,010 --> 00:21:46,390
important that we support continued

00:21:43,660 --> 00:21:48,460
evolution of the execution environments

00:21:46,390 --> 00:21:50,010
and as they change that that the build

00:21:48,460 --> 00:21:54,880
system supports them

00:21:50,010 --> 00:21:57,370
all right next slide so shifting left so

00:21:54,880 --> 00:21:58,900
again if we want to catch things before

00:21:57,370 --> 00:22:00,940
they may commit out to users they have a

00:21:58,900 --> 00:22:03,309
negative effect on what we're building

00:22:00,940 --> 00:22:05,590
we want to shift left

00:22:03,309 --> 00:22:07,570
dhf left is not just for tests either

00:22:05,590 --> 00:22:10,029
for things like finding security

00:22:07,570 --> 00:22:13,169
vulnerabilities and doing vulnerability

00:22:10,029 --> 00:22:16,419
scanning before you push out to prod so

00:22:13,169 --> 00:22:20,080
the next next slide we're really trying

00:22:16,419 --> 00:22:24,389
to shift as many tasks left as possible

00:22:20,080 --> 00:22:27,940
so you can see here matrix right of

00:22:24,389 --> 00:22:30,700
testing Google's testing infrastructure

00:22:27,940 --> 00:22:34,629
were regularly running thousands of unit

00:22:30,700 --> 00:22:36,460
tests for change and that same basal

00:22:34,629 --> 00:22:38,830
infrastructure is being used for all of

00:22:36,460 --> 00:22:41,590
the Hermetic and deterministic tests so

00:22:38,830 --> 00:22:44,139
you know we can easily move tasks

00:22:41,590 --> 00:22:45,639
between different different tiers this

00:22:44,139 --> 00:22:47,470
whole principle of catching things

00:22:45,639 --> 00:22:49,779
before they affect other teams you can

00:22:47,470 --> 00:22:51,700
see with pre cement right we're trying

00:22:49,779 --> 00:22:54,759
to we're trying to catch things before

00:22:51,700 --> 00:22:57,220
they're gonna break anyone else which i

00:22:54,759 --> 00:23:00,279
think is just you know it's good good

00:22:57,220 --> 00:23:02,740
engineering good collaboration you know

00:23:00,279 --> 00:23:05,110
we haven't we have a norm for post

00:23:02,740 --> 00:23:07,799
submit that we will just automatically

00:23:05,110 --> 00:23:10,389
roll back and ask questions later and

00:23:07,799 --> 00:23:11,529
that's a policy decision right that you

00:23:10,389 --> 00:23:14,379
can make as part of your testing

00:23:11,529 --> 00:23:16,149
practices but the goal behind all of

00:23:14,379 --> 00:23:18,759
these the implementation of these

00:23:16,149 --> 00:23:21,580
principles is to make testing so fast

00:23:18,759 --> 00:23:23,409
and easy that as developers we will want

00:23:21,580 --> 00:23:24,759
to write tests and we won't be put in a

00:23:23,409 --> 00:23:29,379
position where we're making those

00:23:24,759 --> 00:23:31,659
difficult trade-offs so really a lot to

00:23:29,379 --> 00:23:33,850
think about in terms of the impact that

00:23:31,659 --> 00:23:39,389
it can have and the and the cascading

00:23:33,850 --> 00:23:42,480
effect so final slide here we are

00:23:39,389 --> 00:23:45,970
showing test results in this aggregated

00:23:42,480 --> 00:23:49,119
dashboard you can see here tests are at

00:23:45,970 --> 00:23:51,100
the top commits left to right

00:23:49,119 --> 00:23:55,450
lights where's tests that weren't

00:23:51,100 --> 00:23:58,179
affected really helpful to see easy to

00:23:55,450 --> 00:24:02,169
identify where tests failed very clear

00:23:58,179 --> 00:24:08,049
like indicator here and flaky tests that

00:24:02,169 --> 00:24:09,639
are highlighted so really I think you

00:24:08,049 --> 00:24:11,769
know there's there's still a lot of work

00:24:09,639 --> 00:24:14,080
to do to keep up with what's you know

00:24:11,769 --> 00:24:15,399
what's occurring in in development

00:24:14,080 --> 00:24:17,820
especially as it relates to

00:24:15,399 --> 00:24:20,979
I think we're all struggling with

00:24:17,820 --> 00:24:22,719
dependency you know analysis and testing

00:24:20,979 --> 00:24:24,249
as it relates to that and and in this

00:24:22,719 --> 00:24:25,509
situation where we're looking for help

00:24:24,249 --> 00:24:28,239
we're looking for tools and

00:24:25,509 --> 00:24:31,619
infrastructure to help ourselves have

00:24:28,239 --> 00:24:34,479
the highest quality code as possible

00:24:31,619 --> 00:24:36,969
while maintaining you know the

00:24:34,479 --> 00:24:39,580
expectations of our user communities so

00:24:36,969 --> 00:24:41,200
with that I think we have the demo necks

00:24:39,580 --> 00:24:43,149
and I just wanted to say thank you so

00:24:41,200 --> 00:24:46,359
much to everyone that's coming I know

00:24:43,149 --> 00:24:47,739
last year was our our first year and and

00:24:46,359 --> 00:24:49,719
it's great it's great that everyone

00:24:47,739 --> 00:24:52,210
could come and get together and talk

00:24:49,719 --> 00:24:55,210
about Basel and I really believe what we

00:24:52,210 --> 00:24:57,519
will make it better together with a lot

00:24:55,210 --> 00:24:59,679
of feedback and and thinking through

00:24:57,519 --> 00:25:01,239
what are the best ways to address it so

00:24:59,679 --> 00:25:02,080
thanks so much I hope you have a great

00:25:01,239 --> 00:25:07,809
day

00:25:02,080 --> 00:25:09,940
and I wish I was there so you've heard a

00:25:07,809 --> 00:25:12,099
little bit for melody about how Google

00:25:09,940 --> 00:25:13,479
tries to push more tests and push its

00:25:12,099 --> 00:25:15,729
testing earlier in the development cycle

00:25:13,479 --> 00:25:17,619
so the catch bugs sooner and we improve

00:25:15,729 --> 00:25:19,809
developer productivity we can move

00:25:17,619 --> 00:25:21,549
faster so I want to show you just a

00:25:19,809 --> 00:25:23,739
little example of how having the right

00:25:21,549 --> 00:25:25,509
to lling that can help you push those

00:25:23,739 --> 00:25:27,339
things earlier can really help increase

00:25:25,509 --> 00:25:29,259
developer productivity and help improve

00:25:27,339 --> 00:25:36,039
your software if we can switch over to

00:25:29,259 --> 00:25:37,629
the demo machine there it is so I have

00:25:36,039 --> 00:25:38,830
I'm connected to a machine here that is

00:25:37,629 --> 00:25:45,070
set up to build tensorflow

00:25:38,830 --> 00:25:48,339
and I'm going to use basil to build a

00:25:45,070 --> 00:25:50,529
part of tensorflow so basil start to up

00:25:48,339 --> 00:25:52,059
it builds this dependency graph and it

00:25:50,529 --> 00:25:53,889
starts compiling things and things are

00:25:52,059 --> 00:25:57,149
running along nicely you can see this is

00:25:53,889 --> 00:25:59,830
a 16 core machine about 60 gigs of ram

00:25:57,149 --> 00:26:01,320
reasonably powerful machine and you can

00:25:59,830 --> 00:26:04,989
see it's running 16 things in parallel

00:26:01,320 --> 00:26:07,059
which is great and and basil does a

00:26:04,989 --> 00:26:08,349
great job of creating that graph and

00:26:07,059 --> 00:26:10,899
figuring out what we don't need to

00:26:08,349 --> 00:26:14,830
execute the only problem is you can see

00:26:10,899 --> 00:26:17,549
we're at about 150 200 actions right now

00:26:14,830 --> 00:26:20,950
this is part of the tensorflow project

00:26:17,549 --> 00:26:24,070
this part takes about 8500 actions to

00:26:20,950 --> 00:26:25,749
complete so this is this bills probably

00:26:24,070 --> 00:26:29,230
gonna take about 15 minutes or so to

00:26:25,749 --> 00:26:31,540
finish and if I were a developer

00:26:29,230 --> 00:26:32,890
be thinking okay I guess I'll go read

00:26:31,540 --> 00:26:35,740
some email got a cup of coffee or

00:26:32,890 --> 00:26:36,910
something like that but I literally just

00:26:35,740 --> 00:26:39,460
got started this is the first thing I

00:26:36,910 --> 00:26:40,510
did was build my tree and and try to

00:26:39,460 --> 00:26:42,700
test to make sure that everything's

00:26:40,510 --> 00:26:46,780
working in a clean state so we would

00:26:42,700 --> 00:26:50,890
really love to speed this up and there

00:26:46,780 --> 00:26:53,200
is a way to speed this up so melody

00:26:50,890 --> 00:26:55,090
talked about how we can run more things

00:26:53,200 --> 00:26:57,730
in parallel and we can offload these

00:26:55,090 --> 00:27:00,850
things to the cloud so this is a similar

00:26:57,730 --> 00:27:03,370
machine setup but set up for basil to

00:27:00,850 --> 00:27:05,620
distribute things to the cloud and I've

00:27:03,370 --> 00:27:07,660
kicked off the build you can see all of

00:27:05,620 --> 00:27:07,990
a sudden we're not running 16 things in

00:27:07,660 --> 00:27:10,440
parallel

00:27:07,990 --> 00:27:13,320
we're running 500 things in parallel so

00:27:10,440 --> 00:27:15,190
this builds gonna take a lot less time

00:27:13,320 --> 00:27:17,590
it still takes a little time because

00:27:15,190 --> 00:27:19,660
it's a completely clean build from from

00:27:17,590 --> 00:27:20,830
scratch I think the tree this morning if

00:27:19,660 --> 00:27:28,390
we can switch back over to the slides

00:27:20,830 --> 00:27:30,400
quickly this is also a 16 core machine

00:27:28,390 --> 00:27:32,049
although to be honest it doesn't need

00:27:30,400 --> 00:27:33,400
those 16 cores the machine is largely

00:27:32,049 --> 00:27:35,500
sitting idle because it's sending

00:27:33,400 --> 00:27:37,270
everything up to the cloud but I wanted

00:27:35,500 --> 00:27:41,740
to do an a/b comparison so I kept the

00:27:37,270 --> 00:27:44,020
machines the same so why is this

00:27:41,740 --> 00:27:46,150
possible so this all goes back to the

00:27:44,020 --> 00:27:48,429
idea of basil creating actions that are

00:27:46,150 --> 00:27:51,490
fully specified and hermetic and

00:27:48,429 --> 00:27:53,260
deterministic so if you know what all

00:27:51,490 --> 00:27:55,840
your inputs are and you know what your

00:27:53,260 --> 00:27:57,520
action is going to look like and you've

00:27:55,840 --> 00:27:59,200
done a good job of fully encapsulating

00:27:57,520 --> 00:28:01,270
that there's no reason why that action

00:27:59,200 --> 00:28:03,610
needs to be run on your local machine so

00:28:01,270 --> 00:28:05,169
basil grabs all that information sends

00:28:03,610 --> 00:28:06,820
it up to a cloud service and then the

00:28:05,169 --> 00:28:10,600
cloud service executes stings and and

00:28:06,820 --> 00:28:13,299
then sends back the results so things

00:28:10,600 --> 00:28:16,059
can just be run in much much greater

00:28:13,299 --> 00:28:18,580
paralyzation as you saw 16 to 500 and

00:28:16,059 --> 00:28:20,350
that's really limited by the amount of

00:28:18,580 --> 00:28:22,600
parallelization available in your build

00:28:20,350 --> 00:28:24,730
graph anything we can run in parallel we

00:28:22,600 --> 00:28:29,830
do so tensorflow tops out at about 500

00:28:24,730 --> 00:28:30,790
as it as it turns out so in terms of

00:28:29,830 --> 00:28:33,970
understanding what this looks like

00:28:30,790 --> 00:28:35,740
obviously there are some some very

00:28:33,970 --> 00:28:37,299
obvious inputs to your build things like

00:28:35,740 --> 00:28:40,600
your source files your data files that

00:28:37,299 --> 00:28:41,950
exist in your repository any libraries

00:28:40,600 --> 00:28:43,149
that you've built in other parts of your

00:28:41,950 --> 00:28:45,339
repository the

00:28:43,149 --> 00:28:46,450
you need for your binaries that you're

00:28:45,339 --> 00:28:48,999
building your tests that you're running

00:28:46,450 --> 00:28:51,489
the command line itself the parameters

00:28:48,999 --> 00:28:53,679
are passing to the program things like

00:28:51,489 --> 00:28:55,899
that and there are some inputs that are

00:28:53,679 --> 00:28:57,460
a little bit more subtle things like the

00:28:55,899 --> 00:29:01,089
installed software on your machine what

00:28:57,460 --> 00:29:03,070
version of Java C or GCC or clang are

00:29:01,089 --> 00:29:05,679
you running what other what other

00:29:03,070 --> 00:29:07,659
utilities is your software invoking what

00:29:05,679 --> 00:29:11,289
system libraries are you linking in etc

00:29:07,659 --> 00:29:14,139
so basil grabs all those things packages

00:29:11,289 --> 00:29:16,089
them up in a in a little proto format

00:29:14,139 --> 00:29:18,249
and sends it up to the cloud and the

00:29:16,089 --> 00:29:20,469
cloud figures out okay I can set up this

00:29:18,249 --> 00:29:23,739
environment I can execute this action I

00:29:20,469 --> 00:29:25,389
can I can run this action and it'll run

00:29:23,739 --> 00:29:26,710
it send back the results they come to

00:29:25,389 --> 00:29:28,509
your local machine you can view the test

00:29:26,710 --> 00:29:32,440
logs the same way you see the test

00:29:28,509 --> 00:29:36,879
results the same way etc so if we can

00:29:32,440 --> 00:29:38,559
flip back to the demo machine so just a

00:29:36,879 --> 00:29:40,509
quick status check this is our local

00:29:38,559 --> 00:29:42,729
build you see is still running sixteen

00:29:40,509 --> 00:29:44,469
things in parallel about thirteen

00:29:42,729 --> 00:29:47,349
hundred actions so we still got a while

00:29:44,469 --> 00:29:51,190
to go if we go to the remote machine

00:29:47,349 --> 00:29:54,070
though no we've run 85 thirty-six out of

00:29:51,190 --> 00:29:57,929
85 thirty seven so we have one long test

00:29:54,070 --> 00:30:00,909
here that should complete momentarily

00:29:57,929 --> 00:30:02,919
but you can see I'm gonna be waiting

00:30:00,909 --> 00:30:06,399
quite a while on this build for this to

00:30:02,919 --> 00:30:08,409
finish and maybe this is a good example

00:30:06,399 --> 00:30:09,820
of why you run your tests first when you

00:30:08,409 --> 00:30:12,460
develop things because maybe this test

00:30:09,820 --> 00:30:13,049
is gonna fail so you know what's what's

00:30:12,460 --> 00:30:17,499
happening

00:30:13,049 --> 00:30:19,139
so I've already saved myself maybe ten

00:30:17,499 --> 00:30:21,580
or fifteen minutes of time by doing this

00:30:19,139 --> 00:30:22,899
I'm actually just going to cancel out of

00:30:21,580 --> 00:30:26,080
this build because we're a little short

00:30:22,899 --> 00:30:28,299
on time we skipped a test but I want to

00:30:26,080 --> 00:30:31,629
show you what happens when you make a

00:30:28,299 --> 00:30:33,849
change so now I've figured out I have a

00:30:31,629 --> 00:30:35,739
clean baseline I'm gonna go into my

00:30:33,849 --> 00:30:39,489
source code and say yeah I want to

00:30:35,739 --> 00:30:41,859
change this I've got this this constant

00:30:39,489 --> 00:30:43,179
here string constant scope to a local

00:30:41,859 --> 00:30:44,799
function I think it might actually be

00:30:43,179 --> 00:30:48,570
useful to pull it out use it somewhere

00:30:44,799 --> 00:30:48,570
else so

00:30:53,150 --> 00:30:58,320
I'm gonna pull it out to the namespace

00:30:55,799 --> 00:31:03,270
scope and delete it from the local scope

00:30:58,320 --> 00:31:06,539
and then I will rerun so Basel once

00:31:03,270 --> 00:31:08,250
again creates this graph of actions and

00:31:06,539 --> 00:31:09,809
it says okay what do I already know

00:31:08,250 --> 00:31:12,690
about what don't I need to compile and

00:31:09,809 --> 00:31:16,020
the answer is most things I don't need

00:31:12,690 --> 00:31:18,510
to compile so it's gonna send basically

00:31:16,020 --> 00:31:21,539
a couple build actions and then those

00:31:18,510 --> 00:31:25,289
216 tests back up to the cloud and we'll

00:31:21,539 --> 00:31:26,340
rerun those takes a few seconds we can

00:31:25,289 --> 00:31:32,190
actually I do want to show one more

00:31:26,340 --> 00:31:34,110
slide if we can flip back to that so you

00:31:32,190 --> 00:31:36,120
can see this is going back to the same

00:31:34,110 --> 00:31:37,919
same imagery we had before you invoke

00:31:36,120 --> 00:31:40,230
basel it creates this whole build graph

00:31:37,919 --> 00:31:43,230
it checks with your local cache to see

00:31:40,230 --> 00:31:44,340
what exists locally and screens out

00:31:43,230 --> 00:31:45,870
filters other bunch of actions it

00:31:44,340 --> 00:31:49,260
doesn't need to run then it checks with

00:31:45,870 --> 00:31:50,610
the cloud cache and says ok what is the

00:31:49,260 --> 00:31:53,010
cloud know about and this is interesting

00:31:50,610 --> 00:31:55,230
is on my machine this is things that any

00:31:53,010 --> 00:31:56,909
developer or any CI system that's

00:31:55,230 --> 00:31:58,980
connected to the system has already run

00:31:56,909 --> 00:32:00,510
so you can see the cloud cache there is

00:31:58,980 --> 00:32:02,490
a lot larger than your local cache it

00:32:00,510 --> 00:32:04,200
holds a lot more historical data a lot

00:32:02,490 --> 00:32:04,890
more data across different revisions and

00:32:04,200 --> 00:32:06,990
things like that

00:32:04,890 --> 00:32:08,909
so you end up with a pretty small list

00:32:06,990 --> 00:32:10,409
of of actions that need to be run those

00:32:08,909 --> 00:32:12,539
get sent up to the cloud and if we

00:32:10,409 --> 00:32:16,470
switch back to the local or to the demo

00:32:12,539 --> 00:32:17,820
machine you can see oh I made a mistake

00:32:16,470 --> 00:32:22,380
what did I do

00:32:17,820 --> 00:32:27,450
I will go check the log file which is

00:32:22,380 --> 00:32:31,799
here and it tells me oh 0 1 oh I know

00:32:27,450 --> 00:32:35,220
what I did I can go back to this file

00:32:31,799 --> 00:32:36,929
I put the 0 at the end because that's

00:32:35,220 --> 00:32:38,690
the way they are on the keyboard but it

00:32:36,929 --> 00:32:43,169
should look like this

00:32:38,690 --> 00:32:48,059
and I can do that and rerun and it'll do

00:32:43,169 --> 00:32:49,529
those tests so you can see that this I'm

00:32:48,059 --> 00:32:53,940
still waiting I'll check on this other

00:32:49,529 --> 00:32:57,090
build yeah 1800 actions I'm getting a

00:32:53,940 --> 00:32:59,250
second cup of coffee so you can see that

00:32:57,090 --> 00:33:01,500
just by having the right tools it means

00:32:59,250 --> 00:33:02,850
that I can run tests faster I can run

00:33:01,500 --> 00:33:03,700
them more often I can run them earlier

00:33:02,850 --> 00:33:06,070
in my development

00:33:03,700 --> 00:33:08,200
and I can catch things sooner I'm not

00:33:06,070 --> 00:33:09,640
waiting for the nightly test run I'm not

00:33:08,200 --> 00:33:10,870
waiting for post submit runs I'm not

00:33:09,640 --> 00:33:13,180
even waiting for pre submit I'm running

00:33:10,870 --> 00:33:14,470
locally on my machine so it really

00:33:13,180 --> 00:33:19,320
tightens up that development loop and

00:33:14,470 --> 00:33:21,550
saves a lot of time so this is a system

00:33:19,320 --> 00:33:23,560
this is this is running against a system

00:33:21,550 --> 00:33:25,450
called cloud build for basil basil has

00:33:23,560 --> 00:33:27,730
the ability built into it to talk to a

00:33:25,450 --> 00:33:30,640
number of different remote build systems

00:33:27,730 --> 00:33:33,070
cloud build for basil as part of the GCP

00:33:30,640 --> 00:33:35,230
Google cloud platform you'll hear more

00:33:33,070 --> 00:33:37,840
about it later today but we use a very

00:33:35,230 --> 00:33:39,460
similar system internally with basil for

00:33:37,840 --> 00:33:41,460
Google across those four million builds

00:33:39,460 --> 00:33:43,600
per day to run all of our tests and

00:33:41,460 --> 00:33:45,040
because this is basil and everything's

00:33:43,600 --> 00:33:47,440
open-source there are actually several

00:33:45,040 --> 00:33:50,170
open source implementations that you can

00:33:47,440 --> 00:33:52,470
build and and self host yourself as well

00:33:50,170 --> 00:33:55,270
and and they all have different

00:33:52,470 --> 00:33:57,460
optimizations different trade-offs but I

00:33:55,270 --> 00:33:58,450
hope you hope you come back this

00:33:57,460 --> 00:34:01,800
afternoon and hear a little bit more

00:33:58,450 --> 00:34:01,800

YouTube URL: https://www.youtube.com/watch?v=DVYRg6b2UBo


