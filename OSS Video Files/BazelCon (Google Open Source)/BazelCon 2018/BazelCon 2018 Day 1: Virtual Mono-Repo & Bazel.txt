Title: BazelCon 2018 Day 1: Virtual Mono-Repo & Bazel
Publication date: 2018-11-01
Playlist: BazelCon 2018
Description: 
	Reproducible HEAD dependency in a many-repo world
Ittai Zeidman (Wix.com) event: Bazelcon 2018; re_ty: Publish; product: Open Source - General; fullname: Ittai Zeidman;
Captions: 
	00:00:03,339 --> 00:00:07,729
right okay

00:00:05,089 --> 00:00:11,090
so you want to work with basil but you

00:00:07,729 --> 00:00:13,910
don't do mono repo now if you're using

00:00:11,090 --> 00:00:16,189
basil in a mono repo it might not seem

00:00:13,910 --> 00:00:18,380
clear what is the relation and if you're

00:00:16,189 --> 00:00:20,300
not using basil yet then it also might

00:00:18,380 --> 00:00:22,519
not seem clear but if you are using

00:00:20,300 --> 00:00:26,119
basil in many people setting you know

00:00:22,519 --> 00:00:28,159
this opens up a can of worms which we're

00:00:26,119 --> 00:00:30,880
trying to solve and so on so on but it's

00:00:28,159 --> 00:00:33,770
not that easy in this talk

00:00:30,880 --> 00:00:36,830
yes I'll talk about how we got many

00:00:33,770 --> 00:00:40,520
repos to work with her dependency and be

00:00:36,830 --> 00:00:42,200
reproducible so first my name is a Thai

00:00:40,520 --> 00:00:43,040
segment and back-engineering will eat at

00:00:42,200 --> 00:00:45,890
wix.com

00:00:43,040 --> 00:00:48,140
I love unblocking developers previously

00:00:45,890 --> 00:00:50,270
I was the server info team leader I

00:00:48,140 --> 00:00:52,910
founded the team over the past two years

00:00:50,270 --> 00:00:55,460
I've been building our next generation

00:00:52,910 --> 00:00:59,600
build system dreaming it vision a

00:00:55,460 --> 00:01:03,470
designing talking with Googlers encoding

00:00:59,600 --> 00:01:05,059
it I'm a commit a novel scholar and a

00:01:03,470 --> 00:01:07,280
commutator of base integration testing

00:01:05,059 --> 00:01:10,550
which is a library that enables you to

00:01:07,280 --> 00:01:12,620
run basically test basil inside of basil

00:01:10,550 --> 00:01:15,560
so if you have Starlog plugins that you

00:01:12,620 --> 00:01:17,770
want to run negative tests go check it

00:01:15,560 --> 00:01:22,430
out we don't have any documentation but

00:01:17,770 --> 00:01:26,330
we do have we do have code some Python

00:01:22,430 --> 00:01:28,909
some go and Java so take a look and

00:01:26,330 --> 00:01:31,370
lastly I'm the proud spouse and for

00:01:28,909 --> 00:01:33,799
those three amazing daughters so wicks

00:01:31,370 --> 00:01:36,560
which is an online website building

00:01:33,799 --> 00:01:39,130
platform we have 130 million website

00:01:36,560 --> 00:01:43,280
builders 600 million monthly visitors

00:01:39,130 --> 00:01:45,409
2,000 employees on 50% in R&D Wilda

00:01:43,280 --> 00:01:49,130
cloud multi data center of course part

00:01:45,409 --> 00:01:51,350
of it is on GCP over 800 different micro

00:01:49,130 --> 00:01:54,260
services and over 300 daily deployments

00:01:51,350 --> 00:01:55,940
to production our CI system we have

00:01:54,260 --> 00:01:57,860
thousands of build configurations and

00:01:55,940 --> 00:02:00,189
every module is a build we have services

00:01:57,860 --> 00:02:03,350
that basically automatically they

00:02:00,189 --> 00:02:05,000
discover when you add a new pom.xml or a

00:02:03,350 --> 00:02:06,680
new package JSON and then they added

00:02:05,000 --> 00:02:08,440
automatically to the build server and

00:02:06,680 --> 00:02:10,250
they run it through matrix

00:02:08,440 --> 00:02:14,030
multiplications to find the shortest

00:02:10,250 --> 00:02:14,550
path to add the shortest triggers we use

00:02:14,030 --> 00:02:17,130
say

00:02:14,550 --> 00:02:20,040
in version which is floating so it's

00:02:17,130 --> 00:02:23,460
snapshot on maven latest on NPM have

00:02:20,040 --> 00:02:25,950
more than 50,000 build runs a day on

00:02:23,460 --> 00:02:27,930
master and millions of test run on on

00:02:25,950 --> 00:02:29,910
master you know this this is not as

00:02:27,930 --> 00:02:33,720
impressive as the stats we saw this

00:02:29,910 --> 00:02:37,260
morning but still we stress out our

00:02:33,720 --> 00:02:40,140
system we have 50 micro services just in

00:02:37,260 --> 00:02:42,540
the CI using Kafka to facilitate all of

00:02:40,140 --> 00:02:46,230
that and still we brought it to its

00:02:42,540 --> 00:02:48,480
knees so we need to build a new system

00:02:46,230 --> 00:02:50,730
and that's what we've been hard at work

00:02:48,480 --> 00:02:54,600
this these are just some of the things

00:02:50,730 --> 00:02:58,080
that we needed to solve and today we'll

00:02:54,600 --> 00:03:01,970
focus on second party but essentially

00:02:58,080 --> 00:03:05,010
moving trying to get the next scale is

00:03:01,970 --> 00:03:10,400
it there are a lot of different fronts

00:03:05,010 --> 00:03:12,660
that you need to attack okay so so I

00:03:10,400 --> 00:03:16,950
talked about a few different terms

00:03:12,660 --> 00:03:19,080
I said many repo at dependency and

00:03:16,950 --> 00:03:21,390
reproducible and that much might sound

00:03:19,080 --> 00:03:23,640
like Greek to some of you so don't worry

00:03:21,390 --> 00:03:24,209
we'll dive into the terms right now so

00:03:23,640 --> 00:03:26,730
mono repo

00:03:24,209 --> 00:03:28,980
what's the mono repo it's putting all of

00:03:26,730 --> 00:03:30,840
the organization's source code into a

00:03:28,980 --> 00:03:35,220
single repository right gate SVA

00:03:30,840 --> 00:03:37,290
mercurial okay now we know that all the

00:03:35,220 --> 00:03:39,300
cool kids are doing it right Google and

00:03:37,290 --> 00:03:43,650
Facebook and Twitter and uber in Yandex

00:03:39,300 --> 00:03:46,230
why why not do a mono repo so first

00:03:43,650 --> 00:03:48,420
what's a mini repo many repos when you

00:03:46,230 --> 00:03:52,820
put your organisation's code in many

00:03:48,420 --> 00:03:55,290
repositories right sound simple so why

00:03:52,820 --> 00:03:57,750
so a mono repo is hard to maintain at

00:03:55,290 --> 00:04:00,270
scale like I said we have around a

00:03:57,750 --> 00:04:05,100
thousand people in R&D we have many

00:04:00,270 --> 00:04:08,010
commits per minute in working hours now

00:04:05,100 --> 00:04:09,930
what do I mean by scale and hard so git

00:04:08,010 --> 00:04:12,360
server does not scale very well with the

00:04:09,930 --> 00:04:14,280
number of reps and number of packs but

00:04:12,360 --> 00:04:16,950
you might say hey we heard that Google

00:04:14,280 --> 00:04:19,169
actually have a service right CSR that

00:04:16,950 --> 00:04:22,500
users get on board and that solves the

00:04:19,169 --> 00:04:24,780
that's to get service scale indeed but

00:04:22,500 --> 00:04:27,479
it doesn't serve softe gets client scale

00:04:24,780 --> 00:04:28,290
issues so just for example we took all

00:04:27,479 --> 00:04:29,850
of our code

00:04:28,290 --> 00:04:34,890
with the refs impacts of course and put

00:04:29,850 --> 00:04:37,230
it in one get repo locally and simple

00:04:34,890 --> 00:04:39,870
operations like it status and gates -

00:04:37,230 --> 00:04:42,390
took many many minutes I don't want to

00:04:39,870 --> 00:04:45,750
even tell you but many much more than 10

00:04:42,390 --> 00:04:48,630
minutes so nothing currently solves get

00:04:45,750 --> 00:04:52,860
client right but you might have heard

00:04:48,630 --> 00:04:55,470
that gvfs and Eden and Twitter have a

00:04:52,860 --> 00:04:58,530
solution forget right and mercurial also

00:04:55,470 --> 00:05:01,590
solves this problem at scale that's true

00:04:58,530 --> 00:05:05,100
but none of these solutions are hunt

00:05:01,590 --> 00:05:06,720
percent there now I have to say that I

00:05:05,100 --> 00:05:09,480
think that in a year to two years time

00:05:06,720 --> 00:05:12,510
this will be a soft problem and the

00:05:09,480 --> 00:05:15,390
entry the barrier entry to using a one

00:05:12,510 --> 00:05:17,880
repo at scale will be accessible to many

00:05:15,390 --> 00:05:20,730
more companies but for now this isn't

00:05:17,880 --> 00:05:22,620
really a solved problem if you want to

00:05:20,730 --> 00:05:24,360
talk and hear a bit more about the data

00:05:22,620 --> 00:05:27,930
then I'm happy to talk to you offline

00:05:24,360 --> 00:05:31,050
afterwards ok so we said many repo on a

00:05:27,930 --> 00:05:34,440
repo what second party so second party

00:05:31,050 --> 00:05:36,810
is code that your organization owns but

00:05:34,440 --> 00:05:38,610
you do not operate or maintain so it can

00:05:36,810 --> 00:05:41,340
be assured library it can be an API

00:05:38,610 --> 00:05:43,260
right this is as opposed to third party

00:05:41,340 --> 00:05:47,280
code that your organization does not own

00:05:43,260 --> 00:05:50,430
and maintain and about the first party

00:05:47,280 --> 00:05:53,390
code that you actually maintain so what

00:05:50,430 --> 00:05:56,820
second party had dependency this is

00:05:53,390 --> 00:05:58,740
having a shared version which is

00:05:56,820 --> 00:06:00,540
relatively up-to-date that everyone in

00:05:58,740 --> 00:06:02,940
the organization is using right it can

00:06:00,540 --> 00:06:05,300
be just using a global version but this

00:06:02,940 --> 00:06:07,980
means that everyone is using the same

00:06:05,300 --> 00:06:10,830
version of the code why would you want

00:06:07,980 --> 00:06:13,380
to do that so first because you want to

00:06:10,830 --> 00:06:15,570
minimize the number of code paths needed

00:06:13,380 --> 00:06:19,080
for backward compatibility if I need to

00:06:15,570 --> 00:06:21,420
maintain a library that supports clients

00:06:19,080 --> 00:06:24,060
from five versions three versions and

00:06:21,420 --> 00:06:26,760
the latest version I have much I have

00:06:24,060 --> 00:06:29,540
many more code paths than I need to take

00:06:26,760 --> 00:06:32,880
into account whenever I do a code change

00:06:29,540 --> 00:06:37,140
additionally we want to find integration

00:06:32,880 --> 00:06:39,810
issues earlier so for example let's say

00:06:37,140 --> 00:06:41,430
I'm now will I be a user and I'm using

00:06:39,810 --> 00:06:44,190
version 5 and I favor

00:06:41,430 --> 00:06:46,830
b-but then I find that version 10

00:06:44,190 --> 00:06:47,340
actually has a critical bug fix I want

00:06:46,830 --> 00:06:49,220
to upgrade

00:06:47,340 --> 00:06:52,370
but then I find that version 8

00:06:49,220 --> 00:06:54,960
introduced an incompatible change now

00:06:52,370 --> 00:06:57,600
someone's after this incompatible change

00:06:54,960 --> 00:07:00,180
I'm now stuck so either the library

00:06:57,600 --> 00:07:02,970
maintainer has to do like a version 11

00:07:00,180 --> 00:07:04,530
with some kind of hack to allow version

00:07:02,970 --> 00:07:06,780
8 you know because this is an

00:07:04,530 --> 00:07:10,710
organization and we work for the same

00:07:06,780 --> 00:07:12,480
cause or I need to somehow swallow the

00:07:10,710 --> 00:07:14,430
version 8 change even though I did not

00:07:12,480 --> 00:07:17,550
prepare for it if we were at a

00:07:14,430 --> 00:07:19,860
dependency we've found that out much

00:07:17,550 --> 00:07:21,960
earlier right once that commit was

00:07:19,860 --> 00:07:23,850
pushed the library maintainer would file

00:07:21,960 --> 00:07:27,530
would have found out that they broke me

00:07:23,850 --> 00:07:27,530
and then we would have a discussion

00:07:27,860 --> 00:07:31,590
additionally you want to increase the

00:07:29,970 --> 00:07:34,320
usage of shared code and minimize

00:07:31,590 --> 00:07:36,720
repetition now you might think how is

00:07:34,320 --> 00:07:40,260
that related to hed dependency so first

00:07:36,720 --> 00:07:42,990
if I can just use all of the

00:07:40,260 --> 00:07:45,900
organization's code without worrying

00:07:42,990 --> 00:07:48,240
about okay do-do I have access to that

00:07:45,900 --> 00:07:50,880
feature do I need to upgrade maybe this

00:07:48,240 --> 00:07:53,550
is just accessible to me then I'm more

00:07:50,880 --> 00:07:55,130
likely to use it and literally if you

00:07:53,550 --> 00:07:58,230
think about the use case from before

00:07:55,130 --> 00:08:00,990
what people might often do is they might

00:07:58,230 --> 00:08:03,240
just fork out that they would say you

00:08:00,990 --> 00:08:05,700
know what I'll take the code that I was

00:08:03,240 --> 00:08:09,600
using I'll just share pic version 10 and

00:08:05,700 --> 00:08:11,970
I'll some time at some time I will do

00:08:09,600 --> 00:08:13,280
the version 8 upgrade and then we have

00:08:11,970 --> 00:08:17,310
repetition

00:08:13,280 --> 00:08:19,200
okay so reproducible I'm guessing that

00:08:17,310 --> 00:08:21,300
reproducible is is pretty clear to this

00:08:19,200 --> 00:08:23,520
crowd but still let's agree that

00:08:21,300 --> 00:08:25,380
reproducible means that I can run the

00:08:23,520 --> 00:08:27,300
build again and if the inputs have not

00:08:25,380 --> 00:08:30,750
changed then the outputs will be the

00:08:27,300 --> 00:08:32,520
same why would you want to do that so

00:08:30,750 --> 00:08:34,560
first it allows us to debug production

00:08:32,520 --> 00:08:37,650
we can just build whatever is on

00:08:34,560 --> 00:08:39,720
production again and be able to stress

00:08:37,650 --> 00:08:41,940
that and see what's happening there it

00:08:39,720 --> 00:08:44,850
allows us to debug specific CI build so

00:08:41,940 --> 00:08:46,740
if you think something is flaky we can

00:08:44,850 --> 00:08:49,500
rerun that and see exactly what's

00:08:46,740 --> 00:08:51,420
happening and it allows us that they

00:08:49,500 --> 00:08:54,750
stabilize the developers feedback loop

00:08:51,420 --> 00:08:56,730
so for example if there

00:08:54,750 --> 00:08:59,190
if they're actually working on a

00:08:56,730 --> 00:09:00,900
short-lived branch and they just want to

00:08:59,190 --> 00:09:03,030
see that their code has changed they

00:09:00,900 --> 00:09:04,680
don't want to see other things that are

00:09:03,030 --> 00:09:07,950
thrashing currently the organization's

00:09:04,680 --> 00:09:09,600
code if they have reproducibility they

00:09:07,950 --> 00:09:10,550
can get this in the feedback for what

00:09:09,600 --> 00:09:14,250
they're doing

00:09:10,550 --> 00:09:19,260
okay so Doohan dependency and

00:09:14,250 --> 00:09:21,450
reproducible go together so if you're

00:09:19,260 --> 00:09:25,140
using a mono repo we're all good right

00:09:21,450 --> 00:09:27,630
because the identifier of let's say get

00:09:25,140 --> 00:09:30,150
is the reproduce key so you just have

00:09:27,630 --> 00:09:31,560
the identifier and there you get a

00:09:30,150 --> 00:09:34,200
dependency because everything is the

00:09:31,560 --> 00:09:35,930
same code and you check it out and you

00:09:34,200 --> 00:09:38,370
run the build and everything is okay

00:09:35,930 --> 00:09:42,510
assuming that you have correct rule sets

00:09:38,370 --> 00:09:44,730
and so on and so on right okay so if you

00:09:42,510 --> 00:09:47,430
use versioning and main repo and

00:09:44,730 --> 00:09:49,980
reproducible we're also good because you

00:09:47,430 --> 00:09:52,110
can take a specific repo take that

00:09:49,980 --> 00:09:54,660
commit and inside of it everything is

00:09:52,110 --> 00:09:57,750
versioned so it's a reproducible right

00:09:54,660 --> 00:09:59,820
the dependencies are just versioned if

00:09:57,750 --> 00:10:01,770
you want to say you know what let's

00:09:59,820 --> 00:10:04,190
relax the repo disability let's say many

00:10:01,770 --> 00:10:07,140
repo had dependency and unreproducible

00:10:04,190 --> 00:10:08,880
also works you just resolve every build

00:10:07,140 --> 00:10:13,890
you resolve the latest version and you

00:10:08,880 --> 00:10:15,420
get a dependency but many repo had a

00:10:13,890 --> 00:10:17,430
dependency plus we put those over dog

00:10:15,420 --> 00:10:21,030
makes that one and tell the story that

00:10:17,430 --> 00:10:22,650
how I came to realize that so we we were

00:10:21,030 --> 00:10:27,510
building like I said you know built big

00:10:22,650 --> 00:10:29,670
big system all kinds of challenges and

00:10:27,510 --> 00:10:32,610
we're saying you know what no problem

00:10:29,670 --> 00:10:34,620
we will just have the commits in in the

00:10:32,610 --> 00:10:37,290
workspace file of the other repositories

00:10:34,620 --> 00:10:39,270
and we will update them automatically

00:10:37,290 --> 00:10:42,780
whenever a commit happens like yeah this

00:10:39,270 --> 00:10:45,510
will work and we were doing a design

00:10:42,780 --> 00:10:46,920
meeting good few months ago saying ok

00:10:45,510 --> 00:10:49,080
let's let's understand the details let's

00:10:46,920 --> 00:10:50,970
see that we have this working and we

00:10:49,080 --> 00:10:55,410
start saying you know what we're not

00:10:50,970 --> 00:10:56,760
sure this actually works because because

00:10:55,410 --> 00:10:58,860
actually we will have race conditions

00:10:56,760 --> 00:11:00,600
what if two repository is actually now

00:10:58,860 --> 00:11:01,950
updated and now they need to go and

00:11:00,600 --> 00:11:05,420
update the third one with the pointers

00:11:01,950 --> 00:11:07,120
what will happen you also might have

00:11:05,420 --> 00:11:09,370
infinite loops

00:11:07,120 --> 00:11:11,170
I updated your repo for the pointers now

00:11:09,370 --> 00:11:13,300
this triggers everyone else to also

00:11:11,170 --> 00:11:15,790
update so we somehow need to break the

00:11:13,300 --> 00:11:17,860
loop right not rocket science but still

00:11:15,790 --> 00:11:19,740
more and more complexity but everything

00:11:17,860 --> 00:11:23,650
the first part of the race conditions of

00:11:19,740 --> 00:11:25,870
seeing how we can have every repo and

00:11:23,650 --> 00:11:29,140
again think about many commits streaming

00:11:25,870 --> 00:11:31,540
in and we need to f2 to update all of

00:11:29,140 --> 00:11:34,570
the pointer files in all of the repos to

00:11:31,540 --> 00:11:36,190
get the head dependency and I remember I

00:11:34,570 --> 00:11:38,890
was sitting in the meeting and my

00:11:36,190 --> 00:11:42,190
colleagues were looking at me and I felt

00:11:38,890 --> 00:11:45,370
the wind got knocked out of me so I was

00:11:42,190 --> 00:11:47,440
just you know sitting there I wasn't

00:11:45,370 --> 00:11:49,089
clear on how we're going to proceed I'm

00:11:47,440 --> 00:11:53,520
saying like I've been building this

00:11:49,089 --> 00:11:56,200
system for more than a year and maybe

00:11:53,520 --> 00:11:58,660
maybe it's lost yeah maybe there's

00:11:56,200 --> 00:11:59,890
nothing to do and for two days I was

00:11:58,660 --> 00:12:02,890
walking around trying to think what to

00:11:59,890 --> 00:12:06,820
do and I went to my manager we have to

00:12:02,890 --> 00:12:09,820
talk and I don't know I know what to do

00:12:06,820 --> 00:12:12,940
like let's talk and he listened and he

00:12:09,820 --> 00:12:15,850
told me you know what can we somehow we

00:12:12,940 --> 00:12:17,680
put like

00:12:15,850 --> 00:12:20,080
just relax we put the stability I know

00:12:17,680 --> 00:12:22,600
what's basil and so on so on but say can

00:12:20,080 --> 00:12:24,790
we relax reproducibility and get many

00:12:22,600 --> 00:12:27,520
repo plus a dependency let's solve that

00:12:24,790 --> 00:12:30,370
later on and I was like you know what I

00:12:27,520 --> 00:12:33,520
don't know but it's worth a shot

00:12:30,370 --> 00:12:36,430
so let me try that out and this was our

00:12:33,520 --> 00:12:38,980
first step in our journey to get many

00:12:36,430 --> 00:12:41,529
repos with a dependency and be

00:12:38,980 --> 00:12:44,440
reproducible at the end so what did we

00:12:41,529 --> 00:12:47,020
do our initial plantation actually

00:12:44,440 --> 00:12:49,510
heavily relied on a feature of beta that

00:12:47,020 --> 00:12:52,420
you might know that when the user calls

00:12:49,510 --> 00:12:55,150
basil it doesn't actually run basil it

00:12:52,420 --> 00:12:57,130
wants a script that the script takes a

00:12:55,150 --> 00:12:59,080
look at the tools at your workspace

00:12:57,130 --> 00:13:01,779
tools basil if there is a script there

00:12:59,080 --> 00:13:04,540
it will run it if not it will run basil

00:13:01,779 --> 00:13:08,650
real and your script can also call basil

00:13:04,540 --> 00:13:11,560
wheel what we use it for so we have a

00:13:08,650 --> 00:13:14,080
rapper script there the script gets a

00:13:11,560 --> 00:13:16,440
list of repos and wakes world it fetches

00:13:14,080 --> 00:13:20,529
the head commits with gate Ellis remote

00:13:16,440 --> 00:13:23,860
writes git repository instances in bzl

00:13:20,529 --> 00:13:25,899
and then that mesial is loaded in the

00:13:23,860 --> 00:13:28,810
workspace file and later on we call

00:13:25,899 --> 00:13:30,550
basil wheel now the bzl is of course you

00:13:28,810 --> 00:13:32,860
can get ignore because the versions keep

00:13:30,550 --> 00:13:34,329
on changing and it's created only if

00:13:32,860 --> 00:13:36,610
it's not there so you don't actually

00:13:34,329 --> 00:13:40,449
have to pay the compare the cost every

00:13:36,610 --> 00:13:43,660
time what are the pros so first it's

00:13:40,449 --> 00:13:47,139
simple right it's pretty simple it was

00:13:43,660 --> 00:13:48,790
fast to get up and running and it very

00:13:47,139 --> 00:13:51,249
much resembled workspace dot result

00:13:48,790 --> 00:13:53,290
which i think is now obsolete right I

00:13:51,249 --> 00:13:55,480
think it was changed dramatically but

00:13:53,290 --> 00:13:57,129
back at the day it was the thing to be

00:13:55,480 --> 00:13:58,990
which was all resolved it was very very

00:13:57,129 --> 00:14:00,339
similar we talked with me and said you

00:13:58,990 --> 00:14:03,610
know what this this sounds like a good

00:14:00,339 --> 00:14:06,879
direction what are the cons so it

00:14:03,610 --> 00:14:08,800
reintroduced voodoo okay what is that

00:14:06,879 --> 00:14:11,499
point is filed what does it contain

00:14:08,800 --> 00:14:14,350
when does it change when you switch

00:14:11,499 --> 00:14:16,029
branches what what what are the contents

00:14:14,350 --> 00:14:18,639
oh you know what maybe try to delete the

00:14:16,029 --> 00:14:20,589
file let's see what happens now maybe

00:14:18,639 --> 00:14:22,480
you know a colleague tells you hey I

00:14:20,589 --> 00:14:24,610
need an either help with with my branch

00:14:22,480 --> 00:14:26,500
you check it out nothing works because

00:14:24,610 --> 00:14:29,889
the branch is older you delete the file

00:14:26,500 --> 00:14:33,600
your file you run it maybe it works then

00:14:29,889 --> 00:14:37,180
you can't come back to your file right

00:14:33,600 --> 00:14:39,160
you have state pointers because maybe

00:14:37,180 --> 00:14:40,149
you run it you right now and and then

00:14:39,160 --> 00:14:43,120
you rebased

00:14:40,149 --> 00:14:45,100
a few hours later nothing works because

00:14:43,120 --> 00:14:49,290
the pointers have changed on master but

00:14:45,100 --> 00:14:49,290
you still have an old file and

00:14:49,529 --> 00:14:55,059
auditability right this ties into this

00:14:53,019 --> 00:14:58,300
you don't know what you're running with

00:14:55,059 --> 00:14:59,350
on anywhere last the performance so

00:14:58,300 --> 00:15:01,540
we're doing it again

00:14:59,350 --> 00:15:07,179
LS free mode this is concurrently but

00:15:01,540 --> 00:15:08,949
still it took a fair amount okay so we

00:15:07,179 --> 00:15:11,199
we need we understood that we need to go

00:15:08,949 --> 00:15:13,029
back to the drawing board and the key

00:15:11,199 --> 00:15:14,679
thing is to track branches separately

00:15:13,029 --> 00:15:17,319
because we want to enable people to

00:15:14,679 --> 00:15:20,439
switch branches and to be able to know

00:15:17,319 --> 00:15:22,240
what's actually going on with what

00:15:20,439 --> 00:15:24,100
they're working on so we said you know

00:15:22,240 --> 00:15:26,379
what it's build a custom micro service

00:15:24,100 --> 00:15:29,679
and that will just hold all of the

00:15:26,379 --> 00:15:31,809
versions right so basically that script

00:15:29,679 --> 00:15:33,879
will tell if a this will be PI my own

00:15:31,809 --> 00:15:34,449
this is a branch and it will get all of

00:15:33,879 --> 00:15:37,389
the point

00:15:34,449 --> 00:15:40,269
that the branch is using the micro

00:15:37,389 --> 00:15:42,929
service we'll get at least the the git

00:15:40,269 --> 00:15:46,959
commits of master from webhooks

00:15:42,929 --> 00:15:49,209
and we'll be good

00:15:46,959 --> 00:15:52,480
we'll save it again in a local cache in

00:15:49,209 --> 00:15:57,759
a gate ignore and we will be will just

00:15:52,480 --> 00:15:59,949
run it okay so the pros are that we get

00:15:57,759 --> 00:16:01,509
all info in one call from the server so

00:15:59,949 --> 00:16:03,819
you don't need to do a lot of get Alice

00:16:01,509 --> 00:16:05,799
remote we have less logic in the client

00:16:03,819 --> 00:16:10,329
code which means it's much easier to

00:16:05,799 --> 00:16:12,160
distribute and and update this it

00:16:10,329 --> 00:16:15,069
enables shall of sense which is a huge

00:16:12,160 --> 00:16:16,959
get optimization get does not allow

00:16:15,069 --> 00:16:18,819
shallow clone but there are a few

00:16:16,959 --> 00:16:22,089
workarounds one of them is shallow sense

00:16:18,819 --> 00:16:24,069
and if you do get LS remote you don't

00:16:22,089 --> 00:16:25,720
have the timestamps that you need if the

00:16:24,069 --> 00:16:29,230
the server is a source of truth then it

00:16:25,720 --> 00:16:31,359
can hold that local cache allows for

00:16:29,230 --> 00:16:35,259
offline work and it's average round-trip

00:16:31,359 --> 00:16:37,359
for every basil build additionally this

00:16:35,259 --> 00:16:39,369
allows for various tracking strategies

00:16:37,359 --> 00:16:41,499
so the server the source of true so it

00:16:39,369 --> 00:16:43,269
can decide for example that we don't

00:16:41,499 --> 00:16:46,809
want to do head dependency maybe want to

00:16:43,269 --> 00:16:48,789
do stable maybe we wanted a stable only

00:16:46,809 --> 00:16:50,709
for a few serve or only for a few

00:16:48,789 --> 00:16:52,660
infrared posit or ease that we want to

00:16:50,709 --> 00:16:55,509
make sure that don't impact all of the

00:16:52,660 --> 00:16:58,629
things but let's have all like v for you

00:16:55,509 --> 00:17:02,529
know like 40 of the 50 repos be high

00:16:58,629 --> 00:17:04,269
dependency what are the cons so the

00:17:02,529 --> 00:17:07,319
second party versions are out of sync

00:17:04,269 --> 00:17:10,240
with VCS right it's just in the server

00:17:07,319 --> 00:17:12,429
now building a system to manage the

00:17:10,240 --> 00:17:15,279
state of all branches in re post is not

00:17:12,429 --> 00:17:17,260
that nice but more importantly exposing

00:17:15,279 --> 00:17:19,389
it to developers with the UI and telling

00:17:17,260 --> 00:17:21,669
them hey you know what go to that UI to

00:17:19,389 --> 00:17:23,740
update the pointers and play around at

00:17:21,669 --> 00:17:28,329
that is not something any developer

00:17:23,740 --> 00:17:30,159
wants to do additionally it requires

00:17:28,329 --> 00:17:31,960
online connectivity for many more use

00:17:30,159 --> 00:17:34,659
case you open a new branch and now the

00:17:31,960 --> 00:17:37,600
server needs to tell you to create it

00:17:34,659 --> 00:17:39,580
and so on and so on and we really like

00:17:37,600 --> 00:17:41,169
coding on the airplane it wakes

00:17:39,580 --> 00:17:43,629
so we basically send people just on the

00:17:41,169 --> 00:17:46,510
airplane just to code oh this is shorty

00:17:43,629 --> 00:17:47,890
requirement at us okay so we said you

00:17:46,510 --> 00:17:50,080
know what let's

00:17:47,890 --> 00:17:51,910
let's think about get because maybe that

00:17:50,080 --> 00:17:54,490
can help us and store all that

00:17:51,910 --> 00:17:57,850
information so they said you know okay

00:17:54,490 --> 00:18:01,090
so how would that look we'll just have

00:17:57,850 --> 00:18:03,010
the version files tracked by gate and if

00:18:01,090 --> 00:18:06,910
you create a new branch then we'll

00:18:03,010 --> 00:18:09,640
create a new file using it hooks so

00:18:06,910 --> 00:18:12,190
let's say you check out you do a git

00:18:09,640 --> 00:18:14,400
checkout my mail - B then you check out

00:18:12,190 --> 00:18:18,100
from a branch write that branch has

00:18:14,400 --> 00:18:20,260
versions we'll just take that and this

00:18:18,100 --> 00:18:21,610
is a local operation so we create the

00:18:20,260 --> 00:18:26,200
first you find for you and you can just

00:18:21,610 --> 00:18:27,970
run and this is tracked so you can get

00:18:26,200 --> 00:18:31,720
commit and get diff and so on and so on

00:18:27,970 --> 00:18:33,430
and we have a good talk another gate

00:18:31,720 --> 00:18:35,830
hook a different one that manages the

00:18:33,430 --> 00:18:37,600
same link so basically remember the

00:18:35,830 --> 00:18:39,970
workspace file it still loads one bzl

00:18:37,600 --> 00:18:41,530
file and we have the github that changes

00:18:39,970 --> 00:18:45,010
the same link according to the current

00:18:41,530 --> 00:18:48,970
branch okay and that's also in get

00:18:45,010 --> 00:18:51,220
ignore now you might ask okay but how do

00:18:48,970 --> 00:18:53,290
you populate it once so we have a micro

00:18:51,220 --> 00:18:56,860
service for other reasons also that has

00:18:53,290 --> 00:18:58,330
a list of repos and we do get get a

00:18:56,860 --> 00:19:01,360
lustrum oh this is to build the first

00:18:58,330 --> 00:19:03,940
time ever master version additionally

00:19:01,360 --> 00:19:05,980
this is something that is used by CLI

00:19:03,940 --> 00:19:09,930
tool for developers right because if

00:19:05,980 --> 00:19:14,770
they want to reset the versions okay so

00:19:09,930 --> 00:19:16,540
what's good about that so mainly it's

00:19:14,770 --> 00:19:18,850
solving the problems of the customer

00:19:16,540 --> 00:19:20,950
service so the second party versions are

00:19:18,850 --> 00:19:24,160
in sync with VCS there are they are in

00:19:20,950 --> 00:19:28,630
VCS managing the state is easy it's in

00:19:24,160 --> 00:19:32,560
gate all right we all know get to diff

00:19:28,630 --> 00:19:35,560
it to commit and to see exactly what's

00:19:32,560 --> 00:19:37,240
happening and every change and gate is

00:19:35,560 --> 00:19:41,350
decentralized so many of the use cases

00:19:37,240 --> 00:19:44,170
are now can be local and it allowed us

00:19:41,350 --> 00:19:47,080
to have issue of second party versions

00:19:44,170 --> 00:19:50,050
per branch per commits okay but what are

00:19:47,080 --> 00:19:52,330
the cons it's the only one but a huge

00:19:50,050 --> 00:19:54,400
one the second party versions can be

00:19:52,330 --> 00:19:57,760
very very volatile especially on master

00:19:54,400 --> 00:20:00,520
so now if you want developers to

00:19:57,760 --> 00:20:01,390
manually maintain the master file then

00:20:00,520 --> 00:20:03,910
you first have

00:20:01,390 --> 00:20:06,670
because I don't really want to maintain

00:20:03,910 --> 00:20:09,429
it so will usually you to have

00:20:06,670 --> 00:20:12,059
dependency and more importantly I would

00:20:09,429 --> 00:20:16,150
have merge conflicts because let's say

00:20:12,059 --> 00:20:18,820
George and I go from the same commit now

00:20:16,150 --> 00:20:21,370
we both change the same file the same

00:20:18,820 --> 00:20:23,340
master versions now when I go to commit

00:20:21,370 --> 00:20:26,350
after him I have I have a merge conflict

00:20:23,340 --> 00:20:27,520
so that's not really a viable option but

00:20:26,350 --> 00:20:30,010
then you can say you know what let's

00:20:27,520 --> 00:20:31,750
automatically maintain it but then we go

00:20:30,010 --> 00:20:33,790
back to the same original problem of

00:20:31,750 --> 00:20:37,809
race conditions and infinite loop

00:20:33,790 --> 00:20:40,330
breaking so at this point we realized

00:20:37,809 --> 00:20:43,690
that treating master and other branch is

00:20:40,330 --> 00:20:47,470
the same is just wrong and we need to

00:20:43,690 --> 00:20:50,440
somehow mix both solutions so how does

00:20:47,470 --> 00:20:52,299
this look okay so we still have a micro

00:20:50,440 --> 00:20:55,510
service and it stores the latest version

00:20:52,299 --> 00:20:57,880
of master in all repositories so again

00:20:55,510 --> 00:21:02,710
get gets webhooks from gate it knows

00:20:57,880 --> 00:21:04,900
this is the master version the script

00:21:02,710 --> 00:21:07,410
calls the micro service to get the

00:21:04,900 --> 00:21:10,390
master versions of second party and

00:21:07,410 --> 00:21:12,220
those are not tracked by git so those

00:21:10,390 --> 00:21:14,650
are resolved every time you work on

00:21:12,220 --> 00:21:17,950
master a good use case for working on

00:21:14,650 --> 00:21:20,440
master is CI so basically on CI we

00:21:17,950 --> 00:21:23,410
resolve the versions each time from the

00:21:20,440 --> 00:21:26,500
micro service we just get a response

00:21:23,410 --> 00:21:28,620
with the star lock file yes I wasn't

00:21:26,500 --> 00:21:35,590
sure I was going to say star lock

00:21:28,620 --> 00:21:36,940
definitely a mouthful okay so so that's

00:21:35,590 --> 00:21:39,850
automatically resolved and the content

00:21:36,940 --> 00:21:43,090
isn't get ignored and the non master

00:21:39,850 --> 00:21:46,419
branches are tracked in git now they are

00:21:43,090 --> 00:21:50,799
manually curated and we just added hooks

00:21:46,419 --> 00:21:53,290
to yeah we still have hooks but they are

00:21:50,799 --> 00:21:57,580
different their purpose is to help you

00:21:53,290 --> 00:22:00,040
as a developer is to manually the manual

00:21:57,580 --> 00:22:04,090
creation so for example let's say you

00:22:00,040 --> 00:22:05,860
rebase you pull origin and now you want

00:22:04,090 --> 00:22:07,900
to rebase if you're amazing you're

00:22:05,860 --> 00:22:10,000
taking the code right you're taking the

00:22:07,900 --> 00:22:13,600
code from origin the code probably

00:22:10,000 --> 00:22:14,429
depends on other code also on master so

00:22:13,600 --> 00:22:16,409
if you

00:22:14,429 --> 00:22:19,379
rebase we also want to rebase your

00:22:16,409 --> 00:22:22,590
pointers so we have hooks to correlate

00:22:19,379 --> 00:22:27,119
between the code and the pointers now we

00:22:22,590 --> 00:22:29,999
we sharp we curve that out so that this

00:22:27,119 --> 00:22:32,369
is still semantics very similar to get

00:22:29,999 --> 00:22:34,259
so when get is on line we will be on

00:22:32,369 --> 00:22:37,769
line when get is local we will be local

00:22:34,259 --> 00:22:39,769
and the verb we will not will not really

00:22:37,769 --> 00:22:44,129
notice and we still have the get hook

00:22:39,769 --> 00:22:46,679
that you know from before okay so what

00:22:44,129 --> 00:22:48,629
are the pros of this so we don't get

00:22:46,679 --> 00:22:50,759
merge conflicts we don't get version

00:22:48,629 --> 00:22:52,610
drift and we don't get race conditions

00:22:50,759 --> 00:22:55,769
really big pains

00:22:52,610 --> 00:22:58,350
additionally we get all info in one call

00:22:55,769 --> 00:23:00,450
so just on a small scale right if like

00:22:58,350 --> 00:23:02,940
five repositories that that we played

00:23:00,450 --> 00:23:04,470
around with given now it's it's on a

00:23:02,940 --> 00:23:07,019
developer machine and not on CI

00:23:04,470 --> 00:23:09,809
so networking does change but we got it

00:23:07,019 --> 00:23:12,059
down from ten seconds to one second so

00:23:09,809 --> 00:23:15,990
ten seconds with the LS remote one

00:23:12,059 --> 00:23:19,230
second with the server sorry still

00:23:15,990 --> 00:23:21,360
enable shadow sense because the thing

00:23:19,230 --> 00:23:24,450
that promotes all of this is is the

00:23:21,360 --> 00:23:28,259
server and we still don't need to pay

00:23:24,450 --> 00:23:31,049
the roundtrip lastly the second party

00:23:28,259 --> 00:23:32,369
version that VCS are mostly synced so

00:23:31,049 --> 00:23:35,039
not for master but for all other

00:23:32,369 --> 00:23:37,639
branches still allows for offline work

00:23:35,039 --> 00:23:41,220
and still supports tracking strategies

00:23:37,639 --> 00:23:43,139
what are the cons so we need to clean up

00:23:41,220 --> 00:23:45,259
old second party versions right because

00:23:43,139 --> 00:23:47,820
we just keep on committing those files

00:23:45,259 --> 00:23:50,999
okay but that's actually a problem also

00:23:47,820 --> 00:23:53,190
with git branches so just happen so

00:23:50,999 --> 00:23:55,830
happens that we have a service that

00:23:53,190 --> 00:23:58,470
actually prunes out all branches that

00:23:55,830 --> 00:24:00,710
aren't really needed and we just made

00:23:58,470 --> 00:24:05,179
that service also clean up those files

00:24:00,710 --> 00:24:08,129
okay the client is not that thin right

00:24:05,179 --> 00:24:09,299
price of doing business right that's

00:24:08,129 --> 00:24:12,899
just the cost of doing business

00:24:09,299 --> 00:24:17,789
we will find ways to distribute that

00:24:12,899 --> 00:24:19,409
which will be relatively cheap auditing

00:24:17,789 --> 00:24:21,389
master so you say you know what but

00:24:19,409 --> 00:24:24,740
you're not tracking master what do

00:24:21,389 --> 00:24:28,050
people do so what we do is we just

00:24:24,740 --> 00:24:31,530
output in the build we output the

00:24:28,050 --> 00:24:34,290
file and we store that as part of the

00:24:31,530 --> 00:24:36,570
build output so for our use case this is

00:24:34,290 --> 00:24:38,790
part of this is just a target in Basel

00:24:36,570 --> 00:24:41,910
and then the developer if they want to

00:24:38,790 --> 00:24:44,130
reproduce a build of Master they can go

00:24:41,910 --> 00:24:47,450
they download that file and they run it

00:24:44,130 --> 00:24:50,010
and that's it they just get reproducible

00:24:47,450 --> 00:24:52,830
disability also a master so it's not

00:24:50,010 --> 00:24:56,040
tracked by git and it's like two clicks

00:24:52,830 --> 00:24:58,380
away but they but they have it lastly

00:24:56,040 --> 00:25:00,630
people some people might need to

00:24:58,380 --> 00:25:05,160
understand this master versus non master

00:25:00,630 --> 00:25:08,630
logic but I think that the the the the

00:25:05,160 --> 00:25:11,040
main takeaway is that these cons are

00:25:08,630 --> 00:25:13,320
operational and small-scale they are not

00:25:11,040 --> 00:25:15,300
functional previously all of our

00:25:13,320 --> 00:25:17,430
iterations were you know what this will

00:25:15,300 --> 00:25:19,830
not work you know what this will usually

00:25:17,430 --> 00:25:24,930
work and sometimes people will be really

00:25:19,830 --> 00:25:28,830
really mad and saying hey get your stuff

00:25:24,930 --> 00:25:30,930
together so all in all net we are really

00:25:28,830 --> 00:25:36,060
happy to get it down to operational

00:25:30,930 --> 00:25:38,790
issues yeah some more thoughts this is

00:25:36,060 --> 00:25:42,150
like the advanced I'm not sure I'll

00:25:38,790 --> 00:25:44,850
touch on everything because I think it's

00:25:42,150 --> 00:25:48,480
a bit too much but so first of all

00:25:44,850 --> 00:25:50,910
what's the version because you have many

00:25:48,480 --> 00:25:52,710
repos so there is not really a version

00:25:50,910 --> 00:25:55,230
right there is not if you have mana repo

00:25:52,710 --> 00:25:58,080
you have version so for us the version

00:25:55,230 --> 00:26:00,750
is the aggregate of all commits so this

00:25:58,080 --> 00:26:02,520
version list is the version that you

00:26:00,750 --> 00:26:05,660
want to speak about because this

00:26:02,520 --> 00:26:08,310
represents the code that that was used

00:26:05,660 --> 00:26:10,680
what what should the server's respond

00:26:08,310 --> 00:26:13,590
should they respond a JSON star lark

00:26:10,680 --> 00:26:15,660
both so we saw the JSON but then we said

00:26:13,590 --> 00:26:18,630
you know what this means that the client

00:26:15,660 --> 00:26:21,090
is again like a lot wiser because it

00:26:18,630 --> 00:26:22,470
needs to format the git repository if we

00:26:21,090 --> 00:26:24,510
want to change to a cheaper archive

00:26:22,470 --> 00:26:26,100
which we're actually considering then

00:26:24,510 --> 00:26:28,620
the card needs to be changed so we said

00:26:26,100 --> 00:26:31,350
you know what we'll just return both we

00:26:28,620 --> 00:26:34,320
the StarTAC file is is taken by the

00:26:31,350 --> 00:26:36,420
script and is used by basil and with the

00:26:34,320 --> 00:26:40,260
JSON for other stuff on our CI that's

00:26:36,420 --> 00:26:41,850
propagated and basically this again is

00:26:40,260 --> 00:26:43,860
the lock this

00:26:41,850 --> 00:26:47,640
is not a locker this is the identifier

00:26:43,860 --> 00:26:50,039
of the code the JSON response or doing

00:26:47,640 --> 00:26:54,780
how do you do ordering in many repo had

00:26:50,039 --> 00:26:56,429
dependency like what's first so so we

00:26:54,780 --> 00:26:59,370
said you know what let's just take the

00:26:56,429 --> 00:27:01,440
commit a time but then we said welcome

00:26:59,370 --> 00:27:02,880
at the time of what of the repo but

00:27:01,440 --> 00:27:05,250
maybe you were triggered by another repo

00:27:02,880 --> 00:27:07,910
right because they merged master now you

00:27:05,250 --> 00:27:12,059
were triggered you're chimes not change

00:27:07,910 --> 00:27:13,710
okay so we just took the maxed commit a

00:27:12,059 --> 00:27:16,320
time of our repos because that's the

00:27:13,710 --> 00:27:19,890
latest one but then we found out that

00:27:16,320 --> 00:27:22,110
actually commit a time is not that good

00:27:19,890 --> 00:27:23,669
because when you do rebase commit the

00:27:22,110 --> 00:27:25,380
time changes we need to merge commit the

00:27:23,669 --> 00:27:28,220
time changes when you get cherry-pick

00:27:25,380 --> 00:27:31,289
commit a time does not change so

00:27:28,220 --> 00:27:34,860
thankfully we use github github has a

00:27:31,289 --> 00:27:36,960
pushed at timestamp so we just use the

00:27:34,860 --> 00:27:39,720
push stat and this max pushed at

00:27:36,960 --> 00:27:42,270
timestamp is what we use for ordering I

00:27:39,720 --> 00:27:47,330
hope their time the clock will not get

00:27:42,270 --> 00:27:53,669
out of sync or we will have problems but

00:27:47,330 --> 00:27:55,890
yeah I think one last one last thing is

00:27:53,669 --> 00:28:01,080
basically why we chose to encode all of

00:27:55,890 --> 00:28:03,600
which repositories in in the same in

00:28:01,080 --> 00:28:06,750
that file because maybe not everything

00:28:03,600 --> 00:28:08,640
needs everything right so we actually

00:28:06,750 --> 00:28:11,039
didn't in our current system we don't do

00:28:08,640 --> 00:28:13,080
that and we built a separate system that

00:28:11,039 --> 00:28:15,960
tries to understand the dependencies

00:28:13,080 --> 00:28:20,190
between modules here it's is

00:28:15,960 --> 00:28:23,130
repositories and we did not want to go

00:28:20,190 --> 00:28:26,610
into that Avenue of saying what repo

00:28:23,130 --> 00:28:28,620
needs what repo because the whole

00:28:26,610 --> 00:28:31,860
external positive story works we stopped

00:28:28,620 --> 00:28:35,789
resolved and recursive workspaces is

00:28:31,860 --> 00:28:38,640
very much I think it's not in the dark

00:28:35,789 --> 00:28:39,870
now but it was like six months ago

00:28:38,640 --> 00:28:42,360
someone said oh it was much more in the

00:28:39,870 --> 00:28:45,750
dark and we said you know what we don't

00:28:42,360 --> 00:28:48,330
want to build a system that might not be

00:28:45,750 --> 00:28:50,549
relevant so we will just use that and we

00:28:48,330 --> 00:28:54,960
will optimize along the way because

00:28:50,549 --> 00:28:57,090
basically this is just cloning and all

00:28:54,960 --> 00:29:01,420
only happen if you know if you actually

00:28:57,090 --> 00:29:06,749
need it thank you

00:29:01,420 --> 00:29:06,749

YouTube URL: https://www.youtube.com/watch?v=2gNlTegwQD4


