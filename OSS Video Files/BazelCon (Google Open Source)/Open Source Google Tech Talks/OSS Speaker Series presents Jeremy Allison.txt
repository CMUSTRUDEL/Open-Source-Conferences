Title: OSS Speaker Series presents Jeremy Allison
Publication date: 2010-10-27
Playlist: Open Source Google Tech Talks
Description: 
	The Future of Samba
Captions: 
	00:00:00,000 --> 00:00:00,000


00:00:00,000 --> 00:00:02,420
LESLIE HAWTHORN: Good evening ladies and gentleman, except I

00:00:02,420 --> 00:00:04,260
appear to be the only lady, so good evening, gentlemen.

00:00:04,260 --> 00:00:06,340
My name is Leslie Hawthorn and I work for Google's Open

00:00:06,340 --> 00:00:08,390
Source Program Office, and it's my privilege this evening

00:00:08,390 --> 00:00:11,500
to introduce Mr. Jeremy Allison, Samba maintainer, and

00:00:11,500 --> 00:00:13,570
he will be discussing with us this evening the

00:00:13,570 --> 00:00:14,430
current state of Samba.

00:00:14,430 --> 00:00:15,680
Take it away, Jeremy.

00:00:15,680 --> 00:00:17,860
JEREMY ALLISON: Thanks very much.

00:00:17,860 --> 00:00:21,190
I also work with Leslie in Google's Open

00:00:21,190 --> 00:00:23,250
Source Program Office.

00:00:23,250 --> 00:00:26,330
So before I start, I always like to ask because you never

00:00:26,330 --> 00:00:27,710
know, people may have wandered into the

00:00:27,710 --> 00:00:29,040
wrong talk by mistake.

00:00:29,040 --> 00:00:31,120
Is there one here who doesn't know what Samba

00:00:31,120 --> 00:00:33,360
is or what it does?

00:00:33,360 --> 00:00:34,630
OK, cool.

00:00:34,630 --> 00:00:37,570
You're in the right talk, by the way.

00:00:37,570 --> 00:00:41,330
So the other thing I like to do is I'm not one of these

00:00:41,330 --> 00:00:44,520
people, especially with a small group, who likes to say,

00:00:44,520 --> 00:00:47,450
no, you must wait until the official end of the talk to

00:00:47,450 --> 00:00:50,110
ask questions, especially as I often make

00:00:50,110 --> 00:00:51,410
mistakes in my talks.

00:00:51,410 --> 00:00:56,690
So some deliberate, some just because I'm sloppy.

00:00:56,690 --> 00:00:59,760
But it would be very cool if you have any questions,

00:00:59,760 --> 00:01:03,320
comments, or you just thought I was plain wrong, stick your

00:01:03,320 --> 00:01:06,970
hand up and we'll discuss it in the middle of the talk.

00:01:06,970 --> 00:01:08,870
If it's going down a rat hole, we can always

00:01:08,870 --> 00:01:10,120
push it to the end.

00:01:10,120 --> 00:01:15,120


00:01:15,120 --> 00:01:17,940
What I'm going to talk about today is the

00:01:17,940 --> 00:01:19,120
current state of Samba.

00:01:19,120 --> 00:01:21,880
Oh, and by the way, don't feel constrained by the

00:01:21,880 --> 00:01:23,270
scope of this talk.

00:01:23,270 --> 00:01:25,890
If there's any weird things about Samba that you ever

00:01:25,890 --> 00:01:29,970
wanted to know or history or stuff, I can always branch out

00:01:29,970 --> 00:01:36,370
and go into infinite funny stories, of which that man

00:01:36,370 --> 00:01:38,920
will probably play a very large part.

00:01:38,920 --> 00:01:40,170
Hello, Mark.

00:01:40,170 --> 00:01:42,430


00:01:42,430 --> 00:01:47,630
So I'm one of the original authors of Samba.

00:01:47,630 --> 00:01:51,820
Essentially, I'm the person who sent Andrew Tridgell the

00:01:51,820 --> 00:01:52,980
very first patches.

00:01:52,980 --> 00:01:56,010
So Tridge came out with the original vision of Samba.

00:01:56,010 --> 00:01:58,810
I was actually working on something similar in C++

00:01:58,810 --> 00:02:02,300
which, as everyone knows, is a far superior language.

00:02:02,300 --> 00:02:04,990
But as he came out first and he's already worked with it

00:02:04,990 --> 00:02:08,790
within C, I canned what I had, threw my lot in with him and

00:02:08,790 --> 00:02:10,020
started sending in patches.

00:02:10,020 --> 00:02:13,730
And essentially, we've been working on it ever since.

00:02:13,730 --> 00:02:18,120
So what I'm going to talk about today is where we are

00:02:18,120 --> 00:02:23,510
with Samba, where we're going, what works, what doesn't, and

00:02:23,510 --> 00:02:25,690
essentially anything that you guys would like to ask

00:02:25,690 --> 00:02:29,300
questions about because this is your talk.

00:02:29,300 --> 00:02:31,120
True open source fashion.

00:02:31,120 --> 00:02:35,340
So I like to think of Samba as a three-legged stool that

00:02:35,340 --> 00:02:37,450
wobbles when you sit on it.

00:02:37,450 --> 00:02:40,010
As I was saying to someone earlier on at the back of the

00:02:40,010 --> 00:02:43,980
room, for me samba is always broken because I only ever see

00:02:43,980 --> 00:02:45,900
the bugs and the things that it doesn't have. The features

00:02:45,900 --> 00:02:49,880
that work I tend to ignore because they work.

00:02:49,880 --> 00:02:54,500
So Samba basically rests on three things that people

00:02:54,500 --> 00:02:55,860
really like to use it for.

00:02:55,860 --> 00:02:59,980
Obviously file service, authentication, which is a

00:02:59,980 --> 00:03:02,910
growing and getting more important part of the Samba

00:03:02,910 --> 00:03:07,180
functionality, and I'll talk a lot more about that, and also

00:03:07,180 --> 00:03:10,340
the print service, which I would rather talk as little as

00:03:10,340 --> 00:03:12,380
possible about if I could.

00:03:12,380 --> 00:03:14,500
I do have to talk about it some.

00:03:14,500 --> 00:03:17,390
I actually have another talk which is completely on the

00:03:17,390 --> 00:03:19,060
printing service which I haven't given

00:03:19,060 --> 00:03:20,130
in about five years.

00:03:20,130 --> 00:03:22,110
I'm very glad about that.

00:03:22,110 --> 00:03:24,250
It mainly just works these days.

00:03:24,250 --> 00:03:25,540
We've put a lot of work in on that.

00:03:25,540 --> 00:03:27,450
Anyway, I'll talk about that in a little while.

00:03:27,450 --> 00:03:30,920


00:03:30,920 --> 00:03:34,340
File service, this is essentially

00:03:34,340 --> 00:03:35,540
Samba's bread and butter.

00:03:35,540 --> 00:03:38,700
This is why we exist, really.

00:03:38,700 --> 00:03:43,120
Even after 15 years, you would think that we actually knew

00:03:43,120 --> 00:03:46,460
how this stuff worked, but we're still fixing bugs and

00:03:46,460 --> 00:03:51,030
still actually discovering new and interesting fundamental

00:03:51,030 --> 00:03:54,900
parts of the CIFS protocol because, as you may know, the

00:03:54,900 --> 00:03:59,480
CIFS protocol isn't exactly an official RFC specification

00:03:59,480 --> 00:04:02,180
like NFS where you can look at it and say, well, this is how

00:04:02,180 --> 00:04:04,120
it's supposed to work.

00:04:04,120 --> 00:04:07,690
CIFS very much historically has been referred to as

00:04:07,690 --> 00:04:11,760
Windows on the wire and as Windows has developed, it's

00:04:11,760 --> 00:04:13,595
become moreso, essentially.

00:04:13,595 --> 00:04:16,670


00:04:16,670 --> 00:04:20,980
By the way, CIFS stands for Common Internet File System

00:04:20,980 --> 00:04:24,430
because it's nothing to do with the internet, it's not a

00:04:24,430 --> 00:04:28,850
file system, but it is very, very common because it's the

00:04:28,850 --> 00:04:31,540
protocol that the Windows clients use.

00:04:31,540 --> 00:04:33,660
It was actually originally known as SMB,

00:04:33,660 --> 00:04:35,670
Server Message Block.

00:04:35,670 --> 00:04:37,580
It was invented by a guy called Barry

00:04:37,580 --> 00:04:40,070
Feigenbaum at IBM.

00:04:40,070 --> 00:04:42,340
Tridge actually got to come to one of the conferences, which

00:04:42,340 --> 00:04:45,267
was great to meet him, and stand there and say, why the

00:04:45,267 --> 00:04:48,110
hell did you do this and what stupid idea was that?

00:04:48,110 --> 00:04:49,590
It was great.

00:04:49,590 --> 00:04:53,680
He got bricks thrown at him even after all these years.

00:04:53,680 --> 00:04:58,570
And it was renamed CIFS probably about 20 minutes

00:04:58,570 --> 00:05:02,540
after Sun came out with a stellar world-changing

00:05:02,540 --> 00:05:04,180
protocol called WebNFS.

00:05:04,180 --> 00:05:06,810
Does anyone remember that?

00:05:06,810 --> 00:05:10,310
Yes, yes, yes, that did really well, didn't it?

00:05:10,310 --> 00:05:14,460
So after Sun came out with that, Microsoft essentially

00:05:14,460 --> 00:05:16,040
said, we have to have one of those.

00:05:16,040 --> 00:05:19,500
So they renamed SMB into CIFS and here we are today.

00:05:19,500 --> 00:05:23,000


00:05:23,000 --> 00:05:28,650
It's an interesting protocol, somewhat well-described as a

00:05:28,650 --> 00:05:29,750
wart that grew.

00:05:29,750 --> 00:05:32,430
There are, I think, six different ways of opening a

00:05:32,430 --> 00:05:36,410
file, three different ways of closing it.

00:05:36,410 --> 00:05:39,790
There's just lots of fun things because it originally

00:05:39,790 --> 00:05:44,550
started off as DOS on the wire and then as DOS went along, it

00:05:44,550 --> 00:05:47,280
developed into OS/2, it became OS/2 on the wire.

00:05:47,280 --> 00:05:50,880
And then as OS/2 became Windows, it became

00:05:50,880 --> 00:05:52,140
Windows on the wire.

00:05:52,140 --> 00:05:55,800
And now it's essentially Windows XP on the wire, is the

00:05:55,800 --> 00:05:59,020
best way to describe it.

00:05:59,020 --> 00:06:04,210
So our authentication service really was actually somewhat

00:06:04,210 --> 00:06:07,370
better developed than the original DOS authentication

00:06:07,370 --> 00:06:11,570
service because when the original DOS SMB protocol came

00:06:11,570 --> 00:06:14,670
out, essentially all you had was passwords

00:06:14,670 --> 00:06:16,040
associated with shares.

00:06:16,040 --> 00:06:17,830
There was no such concept of users.

00:06:17,830 --> 00:06:20,790
Well, Samba was always more sophisticated than that

00:06:20,790 --> 00:06:24,530
because we were written on top of POSIX and Unix systems,

00:06:24,530 --> 00:06:27,000
which, of course, have the idea of separate uses.

00:06:27,000 --> 00:06:30,560
So we always had methods of mapping the incoming requests

00:06:30,560 --> 00:06:34,350
into a specific user on the box.

00:06:34,350 --> 00:06:37,110
And that actually led to some very interesting design

00:06:37,110 --> 00:06:41,320
decisions which we were very lucky about over the years,

00:06:41,320 --> 00:06:43,690
which I can talk about if you're interested.

00:06:43,690 --> 00:06:46,700
This is one of the main reasons why Samba never became

00:06:46,700 --> 00:06:51,380
a multithreaded daemon because we need to have a separate

00:06:51,380 --> 00:06:56,260
user context per incoming connection and with POSIX

00:06:56,260 --> 00:06:58,790
threads, it's very difficult to do that.

00:06:58,790 --> 00:07:02,770
And because of that, we actually scale much, much

00:07:02,770 --> 00:07:05,910
better than most of the competing CIFS servers that

00:07:05,910 --> 00:07:07,490
were out there that people wrote.

00:07:07,490 --> 00:07:10,310
I think IBM has written about five or six different versions

00:07:10,310 --> 00:07:12,760
of CIFS servers.

00:07:12,760 --> 00:07:15,100
And because we have the monolithic,

00:07:15,100 --> 00:07:18,370
one-process-per-connection model, and Unix is really,

00:07:18,370 --> 00:07:21,750
really good at scaling processes, we actually scale

00:07:21,750 --> 00:07:27,780
somewhat better than most of the threaded versions of CIFS.

00:07:27,780 --> 00:07:31,820
And really, all we originally wanted to do with

00:07:31,820 --> 00:07:33,920
authentication was to make sure that someone had the

00:07:33,920 --> 00:07:39,670
rights to access the files that they were accessing, and

00:07:39,670 --> 00:07:41,870
when we started to get sophisticated with

00:07:41,870 --> 00:07:45,870
authentication was right about the time of Windows NT when

00:07:45,870 --> 00:07:49,800
Windows had access control lists associated with it.

00:07:49,800 --> 00:07:52,200
That was when things started to get interesting in the

00:07:52,200 --> 00:07:53,870
authentication space, and I'll talk a little

00:07:53,870 --> 00:07:55,180
bit more about that.

00:07:55,180 --> 00:07:59,240
Printing, essentially originally it was open a

00:07:59,240 --> 00:08:03,850
printer as a file, dump data into it and close.

00:08:03,850 --> 00:08:06,260
It's gotten a lot more sophisticated than that now

00:08:06,260 --> 00:08:09,540
with driver download, there's a whole RPC-based

00:08:09,540 --> 00:08:11,170
subsystem which is--

00:08:11,170 --> 00:08:16,570
I actually know and have met and had very cross words with

00:08:16,570 --> 00:08:20,080
the person at Microsoft who is responsible for actually

00:08:20,080 --> 00:08:21,980
writing that subsystem.

00:08:21,980 --> 00:08:24,510
He's now quit and he's working for an open source startup,

00:08:24,510 --> 00:08:27,410
and he's donating lots and lots of code to Samba, which I

00:08:27,410 --> 00:08:31,100
think is just poetic justice for his previous sins.

00:08:31,100 --> 00:08:35,200


00:08:35,200 --> 00:08:42,590
So the file service, we understand most of what we see

00:08:42,590 --> 00:08:43,299
on the wire.

00:08:43,299 --> 00:08:45,870
I wouldn't say that we understand 100% of it, but I

00:08:45,870 --> 00:08:50,150
think we're probably in the 97% to 99%.

00:08:50,150 --> 00:08:53,410
Some of the I/O controls are still a little interesting,

00:08:53,410 --> 00:08:58,780
and SMB2 is another kettle of fish, which I'll talk about.

00:08:58,780 --> 00:09:01,670
But the thing is, some of the verbs that Windows sends on

00:09:01,670 --> 00:09:05,700
the wire don't really make sense in a POSIX world, and

00:09:05,700 --> 00:09:09,740
some of them are just insane and essentially what they are

00:09:09,740 --> 00:09:13,590
is bleeding through Windows internal kernel semantics into

00:09:13,590 --> 00:09:15,650
the file system protocol.

00:09:15,650 --> 00:09:20,590
So things like separate data streams per file.

00:09:20,590 --> 00:09:22,790
Has anyone ever played with separate data streams per file

00:09:22,790 --> 00:09:23,800
on Windows?

00:09:23,800 --> 00:09:25,450
Yeah, a few people.

00:09:25,450 --> 00:09:27,980
Most people sort of play with it for a bit and then say, oh

00:09:27,980 --> 00:09:30,800
yeah, this is a way to break security on web servers, which

00:09:30,800 --> 00:09:35,740
is about all it's really used for, and then stop.

00:09:35,740 --> 00:09:38,150
The interesting thing and the nice thing--

00:09:38,150 --> 00:09:40,110
because we don't support this, basically.

00:09:40,110 --> 00:09:43,870
I was pushing for a long time to support this.

00:09:43,870 --> 00:09:47,360
I had big arguments with Ted Cho, who was one of the

00:09:47,360 --> 00:09:49,200
primary Linux file system people.

00:09:49,200 --> 00:09:52,050
I was arguing with him that this was a good idea that we

00:09:52,050 --> 00:09:55,210
should support it, and he came up with all the arguments that

00:09:55,210 --> 00:09:57,330
I now use against it.

00:09:57,330 --> 00:09:59,855
Things like, well, how would you tar this file up, how

00:09:59,855 --> 00:10:03,095
would copy a file with all these alternate data streams?

00:10:03,095 --> 00:10:05,960
In case you're not aware, an alternate data stream is

00:10:05,960 --> 00:10:10,050
essentially turning a file into a miniature directory.

00:10:10,050 --> 00:10:13,490
So you can actually open separate named what are called

00:10:13,490 --> 00:10:18,680
streams within a file, which are completely separate

00:10:18,680 --> 00:10:20,330
streams of bytes within a file.

00:10:20,330 --> 00:10:23,540
So there's the primary unnamed stream, which is called

00:10:23,540 --> 00:10:27,040
::$data, which essentially when you open a file, that's

00:10:27,040 --> 00:10:28,270
the primary one you get.

00:10:28,270 --> 00:10:33,260
But you can actually create new ones and name them.

00:10:33,260 --> 00:10:36,350
Now what made me finally realize that this was a

00:10:36,350 --> 00:10:41,500
terrible, terrible idea was a security paper maybe a couple

00:10:41,500 --> 00:10:50,490
of years ago where somebody showed a wonderful image of

00:10:50,490 --> 00:10:54,260
the Windows system task viewer, and it showed, as a

00:10:54,260 --> 00:10:56,180
running process, myfile.txt.

00:10:56,180 --> 00:10:59,560


00:10:59,560 --> 00:11:02,500
And if you know anything about Windows, you know that only

00:11:02,500 --> 00:11:07,130
file names ending in .exe can be invoked, or .com and maybe

00:11:07,130 --> 00:11:12,970
.dll for some of the older DOS-style processes.

00:11:12,970 --> 00:11:16,220
But essentially, what someone had done was they had written

00:11:16,220 --> 00:11:20,680
a virus that hid itself in an alternate data stream that had

00:11:20,680 --> 00:11:22,720
a name that ended in .exe.

00:11:22,720 --> 00:11:27,580
And it turns out the Windows command line processor that

00:11:27,580 --> 00:11:30,800
starts processes doesn't care whether you give it a stream

00:11:30,800 --> 00:11:32,890
name or an actual file name.

00:11:32,890 --> 00:11:35,890
So long as it ends in .exe and it looks like an executable

00:11:35,890 --> 00:11:37,270
file, it will run it.

00:11:37,270 --> 00:11:41,620
So what this means is that in an environment where you have

00:11:41,620 --> 00:11:44,590
streams, not even your text files are safe from being

00:11:44,590 --> 00:11:48,780
infected with potentially malicious code that can run as

00:11:48,780 --> 00:11:50,060
executable binaries.

00:11:50,060 --> 00:11:56,350
And that just really terrified me, and at that point I became

00:11:56,350 --> 00:11:59,650
very much an advocate against streams, especially going into

00:11:59,650 --> 00:12:08,050
Linux, because I used to trust people to set things up, but

00:12:08,050 --> 00:12:10,700
after seeing years and years of misconfigured Samba

00:12:10,700 --> 00:12:14,490
servers, I realized that nobody can set anything up and

00:12:14,490 --> 00:12:16,960
everybody writes very bad code all the time.

00:12:16,960 --> 00:12:21,420
So to give a feature like that out is kind of like--

00:12:21,420 --> 00:12:23,530
it's not just giving people loaded guns.

00:12:23,530 --> 00:12:26,180
It's giving them hand grenades.

00:12:26,180 --> 00:12:26,870
It really is.

00:12:26,870 --> 00:12:28,610
They're going to hurt themselves with that, you

00:12:28,610 --> 00:12:30,610
really don't want to do it.

00:12:30,610 --> 00:12:34,340
Other things that we don't yet understand are the per-file

00:12:34,340 --> 00:12:36,980
encryption and compression.

00:12:36,980 --> 00:12:41,320
Essentially, that's the ability for the Windows client

00:12:41,320 --> 00:12:43,900
to read a compressed file, decrypt on the client.

00:12:43,900 --> 00:12:46,550
We've not had much request that feature.

00:12:46,550 --> 00:12:49,010
If we really needed to do it, we would look into it.

00:12:49,010 --> 00:12:54,230
I'm a little concerned, possibly, compression is one

00:12:54,230 --> 00:12:56,640
of those minefield areas where there's hideous software

00:12:56,640 --> 00:12:59,920
patents that are waiting in the bushes for you to fall

00:12:59,920 --> 00:13:01,860
over and get bitten by.

00:13:01,860 --> 00:13:03,410
So I'm not sure what techniques they

00:13:03,410 --> 00:13:04,880
actually use for that.

00:13:04,880 --> 00:13:08,150
But as I said, this isn't something that we've had a lot

00:13:08,150 --> 00:13:09,180
of requests for.

00:13:09,180 --> 00:13:13,170
So we haven't really gone into it in great detail.

00:13:13,170 --> 00:13:16,650
Actually, one of the things that I had just been working

00:13:16,650 --> 00:13:18,475
on before I came up here, actually, which is why I'm

00:13:18,475 --> 00:13:21,410
trying to switch my mind back into general Samba from the

00:13:21,410 --> 00:13:24,360
specific thing I've been working on, is actually

00:13:24,360 --> 00:13:26,490
transport encryption on the wire.

00:13:26,490 --> 00:13:28,870
And I'll talk a little bit about that in the new features

00:13:28,870 --> 00:13:30,910
that we're doing.

00:13:30,910 --> 00:13:33,310
Another thing that we don't do which would be very expensive

00:13:33,310 --> 00:13:38,860
and ugly is open by inode, and that's mainly for search-type

00:13:38,860 --> 00:13:40,040
operations.

00:13:40,040 --> 00:13:44,440
So essentially, there's a verb that says, here's an inode

00:13:44,440 --> 00:13:46,020
number of the file system.

00:13:46,020 --> 00:13:48,250
I don't know the name of it, just open the file by that.

00:13:48,250 --> 00:13:51,870
And that's used for indexing indexes that go around and

00:13:51,870 --> 00:13:53,520
actually find files.

00:13:53,520 --> 00:13:55,570
And they don't cache their names because they can move,

00:13:55,570 --> 00:13:58,350
they cache their inodes.

00:13:58,350 --> 00:14:00,660
So POSIX is actually pretty good.

00:14:00,660 --> 00:14:05,520
It's able to map most Windows requirements with a little bit

00:14:05,520 --> 00:14:08,430
of help and brute forcing at times.

00:14:08,430 --> 00:14:10,940
One of the strange things that we can't quite do is the

00:14:10,940 --> 00:14:14,560
Windows delete and re-creation semantics.

00:14:14,560 --> 00:14:16,980
So it turns out that if you delete a Windows file and

00:14:16,980 --> 00:14:19,900
recreate it very soon afterwards,

00:14:19,900 --> 00:14:21,070
it's not a new file.

00:14:21,070 --> 00:14:23,480
It actually has the creation date of the original file that

00:14:23,480 --> 00:14:27,880
you deleted, which is one of those things where when people

00:14:27,880 --> 00:14:29,320
discovered it, they went, what?

00:14:29,320 --> 00:14:31,540
So it's essentially just declared, no I'm sorry, that's

00:14:31,540 --> 00:14:32,640
just the way it works.

00:14:32,640 --> 00:14:34,790
Which means that it was an implementation detail they

00:14:34,790 --> 00:14:37,610
didn't want to change.

00:14:37,610 --> 00:14:40,280
So locking is another interesting area.

00:14:40,280 --> 00:14:42,940
I have a whole talk on how Windows locking works.

00:14:42,940 --> 00:14:46,380
Windows locking is kind of interesting.

00:14:46,380 --> 00:14:49,770
You can emulate Windows locking semantics.

00:14:49,770 --> 00:14:52,480
This is byte-range lock semantics.

00:14:52,480 --> 00:14:55,220
Take a lock on region 0 to 10 on a file.

00:14:55,220 --> 00:14:58,160
You can implement that in POSIX.

00:14:58,160 --> 00:15:01,220
Interestingly enough, just given the Windows primitives,

00:15:01,220 --> 00:15:03,950
you cannot implement POSIX locking with the Windows

00:15:03,950 --> 00:15:07,070
primitive, which is my personal feeling why Windows

00:15:07,070 --> 00:15:10,690
boxes make terrible, terrible NFS servers, because there's

00:15:10,690 --> 00:15:12,900
some things that they just can't do without changing

00:15:12,900 --> 00:15:14,160
significant parts of the kernel.

00:15:14,160 --> 00:15:18,280


00:15:18,280 --> 00:15:22,290
3BSD is actually pushing this, and Mac OS X. They're actually

00:15:22,290 --> 00:15:26,230
starting to add some more metadata into the file system

00:15:26,230 --> 00:15:27,830
that makes mapping things easier.

00:15:27,830 --> 00:15:31,890
So for instance, UNIX has no create time.

00:15:31,890 --> 00:15:35,870
It has the inode modification time, the file write time and

00:15:35,870 --> 00:15:38,280
the file access time, but you don't know when a file was

00:15:38,280 --> 00:15:41,470
created, whereas Windows actually has a create time.

00:15:41,470 --> 00:15:46,890
Now in the BSDs, that's now been named birth time, and you

00:15:46,890 --> 00:15:48,930
can get access to it by the stat structure.

00:15:48,930 --> 00:15:52,430
So we've had some patches from Apple, because Apple ships

00:15:52,430 --> 00:15:55,820
Samba as their main file server, that actually give

00:15:55,820 --> 00:15:57,620
access to fields like this.

00:15:57,620 --> 00:16:01,150
We're getting very modular internally, and able to map

00:16:01,150 --> 00:16:04,370
these things onto Windows semantics.

00:16:04,370 --> 00:16:09,590
We're now down to the utterly ridiculous 100 nanoseconds

00:16:09,590 --> 00:16:14,410
since the year 1601 timestamps that Windows uses.

00:16:14,410 --> 00:16:17,030
So if the Unix file system supports those, we can

00:16:17,030 --> 00:16:20,550
actually give valid dates back.

00:16:20,550 --> 00:16:23,160


00:16:23,160 --> 00:16:28,750
So I feel responsible, I'm kind of pleased, getting draft

00:16:28,750 --> 00:16:35,320
POSIX ACLs into the Linux kernel, mainly because I

00:16:35,320 --> 00:16:38,410
really wanted to have an ACL control system in Samba.

00:16:38,410 --> 00:16:40,620
I knew I would have to make it portable, I didn't want to do

00:16:40,620 --> 00:16:44,680
something in user space that would be inherently racy, and

00:16:44,680 --> 00:16:47,400
so what happened was, essentially, I coded it up

00:16:47,400 --> 00:16:51,960
based on an implementation on Solaris and put the code out

00:16:51,960 --> 00:16:54,960
there in a production version of Samba and then started

00:16:54,960 --> 00:16:57,300
saying to our users on the mailing list, of course if you

00:16:57,300 --> 00:17:00,090
want a real file server, you'll have to run Solaris.

00:17:00,090 --> 00:17:03,910
And a month or a month and a half later, Linux decided to

00:17:03,910 --> 00:17:08,010
put the draft POSIX ACLs into the kernel.

00:17:08,010 --> 00:17:13,079
The nice thing now is that NFSv4 ACLs are going into all

00:17:13,079 --> 00:17:14,730
sorts of different kernels.

00:17:14,730 --> 00:17:16,670
Now, NFSv4 ACLs are very interesting.

00:17:16,670 --> 00:17:20,589
How many people here know much about NFSv4.

00:17:20,589 --> 00:17:21,569
Not really.

00:17:21,569 --> 00:17:28,680
NFSv4 is a horrible blunder which I intend to replace, at

00:17:28,680 --> 00:17:32,160
least for desktop file sharing.

00:17:32,160 --> 00:17:35,010
And one of the horrible blunders they did was they

00:17:35,010 --> 00:17:38,290
needed to have an ACL model, so rather than picking the

00:17:38,290 --> 00:17:41,900
draft POSIX ACL model, which everyone had implemented, they

00:17:41,900 --> 00:17:43,690
listened to the people who wanted to

00:17:43,690 --> 00:17:45,630
run Windows NFS clients.

00:17:45,630 --> 00:17:50,820
And so they took a description of how Windows ACLs works from

00:17:50,820 --> 00:17:54,250
the Microsoft MSDN documentation site, and they

00:17:54,250 --> 00:17:57,330
essentially wrote it up in RFC form and said, OK, we're going

00:17:57,330 --> 00:18:00,020
to do that as our ACL model.

00:18:00,020 --> 00:18:02,950
Now the problem is, of course, the way that Windows ACLs

00:18:02,950 --> 00:18:06,350
actually work isn't quite the same as the way they're

00:18:06,350 --> 00:18:07,210
written up in MSDN.

00:18:07,210 --> 00:18:11,360
It's close, but it's not close enough to be right.

00:18:11,360 --> 00:18:14,660
So now they have an ACL model that's almost, but not quite

00:18:14,660 --> 00:18:16,820
the same, as the Windows one.

00:18:16,820 --> 00:18:19,650
And it also breaks POSIX.

00:18:19,650 --> 00:18:22,820
And the other massive pain for Samba, of course, is that none

00:18:22,820 --> 00:18:27,000
of the competing, squabbling Unix vendors can decide on any

00:18:27,000 --> 00:18:31,530
common user-level API for this at all.

00:18:31,530 --> 00:18:35,270
Apple has one, Sun has one, Linux will probably have a

00:18:35,270 --> 00:18:36,410
different one.

00:18:36,410 --> 00:18:40,160
So I've pondered on that one, and we expanded Samba's

00:18:40,160 --> 00:18:43,160
virtual file system layer essentially to allow vendors

00:18:43,160 --> 00:18:48,300
to plug in the insane ACL API model of their choice.

00:18:48,300 --> 00:18:51,680
The reason I'm a fan of POSIX ACLs here-- how many people

00:18:51,680 --> 00:18:55,380
have actually manipulated Windows ACLs in anger?

00:18:55,380 --> 00:18:58,360
Yeah, a few people.

00:18:58,360 --> 00:19:01,580
Essentially, my beef with Windows ACLs is that they are

00:19:01,580 --> 00:19:04,860
beyond the limits of normal admin comprehension.

00:19:04,860 --> 00:19:07,810


00:19:07,810 --> 00:19:09,510
I have another talk about this.

00:19:09,510 --> 00:19:11,180
What most people do with Windows ACLs is

00:19:11,180 --> 00:19:13,380
they say, oh OK--

00:19:13,380 --> 00:19:15,530
there is one nice feature about Windows ACLs, which I'll

00:19:15,530 --> 00:19:17,470
mention in a minute-- but what most people do with Windows

00:19:17,470 --> 00:19:21,350
ACLs is they say, I'm going to set a default ACL on this

00:19:21,350 --> 00:19:25,230
share or this directory, I'm going to give access to the

00:19:25,230 --> 00:19:28,580
people who own this stuff so that they can modify their own

00:19:28,580 --> 00:19:31,940
ACLs, I'm going to set it to inherit down underneath, and

00:19:31,940 --> 00:19:33,400
I'm going to leave it alone.

00:19:33,400 --> 00:19:36,250
So at that point, you can just blame the people who were

00:19:36,250 --> 00:19:38,340
administering it for themselves.

00:19:38,340 --> 00:19:41,470
So it's kind of what I call the delegate and forget model,

00:19:41,470 --> 00:19:43,560
because it's far too complex for anyone to actually do

00:19:43,560 --> 00:19:46,600
anything with individually, so what you do is you say, oh,

00:19:46,600 --> 00:19:47,930
that's accounting's share.

00:19:47,930 --> 00:19:49,830
Fred in accounting, he does the ACLs on

00:19:49,830 --> 00:19:53,050
that one, not my fault.

00:19:53,050 --> 00:19:57,040
Whereas POSIX ACLs are actually--

00:19:57,040 --> 00:19:59,870
Ted Cho just said it best when he said they are only just

00:19:59,870 --> 00:20:03,470
beyond the limits of admin comprehension, which makes

00:20:03,470 --> 00:20:04,450
them a lot easier.

00:20:04,450 --> 00:20:07,380
Maybe a little more dangerous.

00:20:07,380 --> 00:20:09,870
So I'm a big fan of mapping the Windows

00:20:09,870 --> 00:20:11,720
ACLs into POSIX ACLs.

00:20:11,720 --> 00:20:14,980
It's a complicated procedure.

00:20:14,980 --> 00:20:17,960
There's some things that you have to do statistically that

00:20:17,960 --> 00:20:19,880
should be dynamic, but you can get a

00:20:19,880 --> 00:20:21,180
reasonably close mapping.

00:20:21,180 --> 00:20:25,620
The only problem is some of the detail semantics where

00:20:25,620 --> 00:20:28,550
Windows has features that POSIX doesn't, because

00:20:28,550 --> 00:20:30,230
obviously POSIX just has read-write.

00:20:30,230 --> 00:20:33,020
It doesn't have bits to control, attributes, et

00:20:33,020 --> 00:20:35,160
cetera, et cetera.

00:20:35,160 --> 00:20:38,920
As I said, create time and sub-second timestamps are

00:20:38,920 --> 00:20:40,360
being standardized.

00:20:40,360 --> 00:20:43,570
And the other really nice thing it is-- we've had this

00:20:43,570 --> 00:20:46,400
in Linux for a while, but I'm hoping NFSv4 will drive this

00:20:46,400 --> 00:20:48,490
into every Unix--

00:20:48,490 --> 00:20:51,070
is file leasing, opportunistic locks.

00:20:51,070 --> 00:20:54,640
Is there anyone here who knows what oplocks are?

00:20:54,640 --> 00:20:56,260
OK, again, some.

00:20:56,260 --> 00:21:00,330
Oplocks are extremely useful are exactly what you want in a

00:21:00,330 --> 00:21:02,850
desktop file sharing protocol.

00:21:02,850 --> 00:21:05,230
You don't want them in a server-to-server protocol.

00:21:05,230 --> 00:21:08,800
You don't want them in any place where you really, really

00:21:08,800 --> 00:21:11,410
care about losing the data other than stuff that's just

00:21:11,410 --> 00:21:13,450
on your desktop.

00:21:13,450 --> 00:21:16,270
But for your desktop, they are a massive win.

00:21:16,270 --> 00:21:19,960
Essentially what it allows you to do is it allows you to lie

00:21:19,960 --> 00:21:20,930
to the server.

00:21:20,930 --> 00:21:23,470
So what you do is you open a file on the server, and the

00:21:23,470 --> 00:21:25,180
server gives you back a token.

00:21:25,180 --> 00:21:30,200
And you say to the server, if anyone else opens this file,

00:21:30,200 --> 00:21:32,830
block them and let me know.

00:21:32,830 --> 00:21:35,490
And that means you can essentially cache all of your

00:21:35,490 --> 00:21:38,480
modifications locally on your client, which means

00:21:38,480 --> 00:21:40,950
essentially, you're reading and writing at memory speed

00:21:40,950 --> 00:21:44,450
which means that everything is really, really fast until

00:21:44,450 --> 00:21:46,890
somebody actually tells you no, I really need that file.

00:21:46,890 --> 00:21:49,540
And at that point, you have to flush it out to the server.

00:21:49,540 --> 00:21:52,340
But it allows client writers a lot more choice.

00:21:52,340 --> 00:21:55,660
They can dribble out the file in chunks, they can leave it

00:21:55,660 --> 00:21:57,200
to the end to do one massive write.

00:21:57,200 --> 00:22:01,390
But essentially, it means that you can cache most things

00:22:01,390 --> 00:22:04,000
locally, which is exactly what you need.

00:22:04,000 --> 00:22:07,840
In fact, this is why, on the standard Windows benchmarks

00:22:07,840 --> 00:22:13,140
that people Net-Bench, you find that you can get transfer

00:22:13,140 --> 00:22:15,630
speeds that are greater than the physical capacity of the

00:22:15,630 --> 00:22:17,590
wire between the clients and server, because essentially

00:22:17,590 --> 00:22:20,120
what you're measuring is client memory bandwidth.

00:22:20,120 --> 00:22:22,240
It's also why, if you want really good Net-Bench numbers,

00:22:22,240 --> 00:22:23,490
you buy faster clients.

00:22:23,490 --> 00:22:25,120
I mean clients with faster

00:22:25,120 --> 00:22:27,440
processors, not faster network.

00:22:27,440 --> 00:22:28,680
So it's a terrible benchmark.

00:22:28,680 --> 00:22:33,520
But anyway, NFSv4 actually has a similar mechanism built into

00:22:33,520 --> 00:22:37,940
it, and so the nice thing is we get to use that for free,

00:22:37,940 --> 00:22:42,660
as long as they expose a sensible API for it.

00:22:42,660 --> 00:22:47,790
Now if you'll think about it, in order to do this safely,

00:22:47,790 --> 00:22:52,490
you have to have kernel support because you can't open

00:22:52,490 --> 00:22:56,120
a file and promise to a client that you are going to be the

00:22:56,120 --> 00:22:58,920
only accesser if you have local processes running on the

00:22:58,920 --> 00:23:01,320
file system that can come in behind your back.

00:23:01,320 --> 00:23:05,380
I mean, Samba can do this between all Samba clients

00:23:05,380 --> 00:23:09,890
because, essentially, we use our own messaging mechanism

00:23:09,890 --> 00:23:12,820
internally to block a client and message the

00:23:12,820 --> 00:23:13,960
person who has it.

00:23:13,960 --> 00:23:17,050
But if anyone came in via NFS or another protocol, they

00:23:17,050 --> 00:23:20,330
would be able to violate the lease, the oplock that we've

00:23:20,330 --> 00:23:21,690
given on that file.

00:23:21,690 --> 00:23:27,380
Now NFSv4, obviously being a kernel server, will actually

00:23:27,380 --> 00:23:30,470
have to have that built into the kernel.

00:23:30,470 --> 00:23:33,500
That will make our job of supporting that on many

00:23:33,500 --> 00:23:34,640
systems a lot easier.

00:23:34,640 --> 00:23:37,510
Previously, we only had it on IRIX, which has kind of gone

00:23:37,510 --> 00:23:39,650
away, being as we're now standing in SGI's

00:23:39,650 --> 00:23:43,040
old campus, and Linux.

00:23:43,040 --> 00:23:44,920
I'm hoping Solaris will get this soon.

00:23:44,920 --> 00:23:47,970


00:23:47,970 --> 00:23:51,040
One thing we've just fixed finally is the

00:23:51,040 --> 00:23:52,230
notification mechanism.

00:23:52,230 --> 00:23:53,940
Windows tends to use this a lot.

00:23:53,940 --> 00:23:58,320
There's been a longstanding bug against Samba with IIS

00:23:58,320 --> 00:24:00,100
where this was broken.

00:24:00,100 --> 00:24:03,470
Essentially what this is is a synchronous notification of

00:24:03,470 --> 00:24:05,580
any change in a directory.

00:24:05,580 --> 00:24:08,260
Now you can fake it by periodically scanning a

00:24:08,260 --> 00:24:11,210
directory computing a hash over various metadata

00:24:11,210 --> 00:24:13,930
attributes so that you know when something's changed, but

00:24:13,930 --> 00:24:17,360
it's resource-intensive and it sucks.

00:24:17,360 --> 00:24:20,100
So Robert Love wrote this thing for

00:24:20,100 --> 00:24:21,730
Linux called inotify.

00:24:21,730 --> 00:24:24,190
We had a previous version called de-notify, which

00:24:24,190 --> 00:24:25,440
sucked, basically.

00:24:25,440 --> 00:24:27,500


00:24:27,500 --> 00:24:30,080
I'm hoping that the inotify user space will be adopted

00:24:30,080 --> 00:24:33,200
across most of the modern Unixes.

00:24:33,200 --> 00:24:36,030
And we now have an implementation of that that

00:24:36,030 --> 00:24:39,520
will be coming out in Samba 3025, which we're hoping to

00:24:39,520 --> 00:24:42,590
ship maybe next month.

00:24:42,590 --> 00:24:45,170


00:24:45,170 --> 00:24:50,380
The other thing that we do is we do async I/O. We do this

00:24:50,380 --> 00:24:52,120
using the POSIX mechanism.

00:24:52,120 --> 00:24:54,830
Right now, Linus is having lots of arguments with lots of

00:24:54,830 --> 00:24:58,260
people on the mailing list about having a new Linux-only

00:24:58,260 --> 00:25:02,750
way of doing this, which is interesting but essentially is

00:25:02,750 --> 00:25:03,550
pointless for me.

00:25:03,550 --> 00:25:07,850
I need a standards-based API that I can use for this.

00:25:07,850 --> 00:25:11,640
It was little used previously, even though the code has been

00:25:11,640 --> 00:25:14,870
in there probably for about a couple years because Windows

00:25:14,870 --> 00:25:16,330
clients didn't do it.

00:25:16,330 --> 00:25:18,650
So asynchronous I/O is essentially where you have

00:25:18,650 --> 00:25:22,170
more than one read or write in flight at once.

00:25:22,170 --> 00:25:24,790
In fact, the only thing that will do this is the Samba

00:25:24,790 --> 00:25:27,270
client library, and it essentially pipelines reads

00:25:27,270 --> 00:25:31,980
and writes to fill up, essentially, the TCP piping in

00:25:31,980 --> 00:25:34,110
one direction or another.

00:25:34,110 --> 00:25:37,270
So the Samba client libraries use it.

00:25:37,270 --> 00:25:42,360
Interestingly enough, Windows Vista it now seems does proper

00:25:42,360 --> 00:25:47,470
async I/O. But I was actually reading on Slashdot today that

00:25:47,470 --> 00:25:51,140
a massive bug has appeared where copying a file in Vista

00:25:51,140 --> 00:25:54,720
is incredibly slow and Microsoft is having to put out

00:25:54,720 --> 00:25:56,030
a hotfix for this.

00:25:56,030 --> 00:25:57,690
Now, I haven't looked into this yet.

00:25:57,690 --> 00:26:00,430
I'm going to do that once I get the hotfix on my Vista

00:26:00,430 --> 00:26:02,100
test machine.

00:26:02,100 --> 00:26:05,990
It may be that they screwed up the async I/O and it might be

00:26:05,990 --> 00:26:07,430
that that's what they've had to remove.

00:26:07,430 --> 00:26:09,040
I'm not sure.

00:26:09,040 --> 00:26:12,440
This is just my gut feeling based on years and years of

00:26:12,440 --> 00:26:15,886
experience with things going wrong with Windows.

00:26:15,886 --> 00:26:16,369
Yes?

00:26:16,369 --> 00:26:17,619
MARK: [INAUDIBLE].

00:26:17,619 --> 00:26:23,131


00:26:23,131 --> 00:26:26,090
JEREMY ALLISON: So Mark's comment was, is it slow

00:26:26,090 --> 00:26:28,340
because they're actually checking for DRM?

00:26:28,340 --> 00:26:30,920
I don't believe so.

00:26:30,920 --> 00:26:33,660
People speculated about that, but I don't think that

00:26:33,660 --> 00:26:35,630
information has come out yet.

00:26:35,630 --> 00:26:42,010
So what I'm going to do is we have a test scenario that

00:26:42,010 --> 00:26:45,250
causes Vista to use async I/O. What I'm going to do is I'm

00:26:45,250 --> 00:26:47,490
going to put the hotfix on and see if I can reproduce it

00:26:47,490 --> 00:26:48,950
again after I use the hotfix.

00:26:48,950 --> 00:26:51,920


00:26:51,920 --> 00:26:57,500
There were similar things where they with terminal

00:26:57,500 --> 00:27:01,830
server, they broke the ability to use multiple TCP

00:27:01,830 --> 00:27:04,330
connections and they had to put it back after they ended

00:27:04,330 --> 00:27:07,050
up breaking something else.

00:27:07,050 --> 00:27:11,650
There have been similar kinds of bugs in the past. That one

00:27:11,650 --> 00:27:15,560
was actually done to screw Samba, but that's one of the

00:27:15,560 --> 00:27:19,380
rare ones that was actually true.

00:27:19,380 --> 00:27:23,520
As I said, I much prefer to use the POSIX interface

00:27:23,520 --> 00:27:27,890
because of the nonstandard variants on different Unix

00:27:27,890 --> 00:27:29,400
implementations.

00:27:29,400 --> 00:27:32,510
The funny thing was of course when the Linux people started

00:27:32,510 --> 00:27:34,910
talking about kevents I was like, oh, I'm delighted.

00:27:34,910 --> 00:27:36,150
Wonderful.

00:27:36,150 --> 00:27:37,920
And then I looked at it and I realized that even though they

00:27:37,920 --> 00:27:39,170
were both called kevent, they were

00:27:39,170 --> 00:27:40,240
both completely different.

00:27:40,240 --> 00:27:40,930
Great.

00:27:40,930 --> 00:27:46,050
So typical Unix vendor behavior of standing in a

00:27:46,050 --> 00:27:47,910
circle with guns pointed at each other's heads.

00:27:47,910 --> 00:27:50,710


00:27:50,710 --> 00:27:58,010
So we have an interesting user space layer that is getting

00:27:58,010 --> 00:28:01,270
more and more modular, and this is pushing towards Samba4

00:28:01,270 --> 00:28:04,720
and I'll talk about that in a little while.

00:28:04,720 --> 00:28:08,360
And this is the layer that we map the Windows semantics

00:28:08,360 --> 00:28:09,660
above the POSIX layer.

00:28:09,660 --> 00:28:14,630
So for instance, the Windows file locking is done in that

00:28:14,630 --> 00:28:18,020
space because Windows file locks have to conflict on read

00:28:18,020 --> 00:28:21,020
and write, they have to be stackable.

00:28:21,020 --> 00:28:24,680
We have an entire test suite that allows us to probe the

00:28:24,680 --> 00:28:27,390
behavior of the Windows lock mechanism.

00:28:27,390 --> 00:28:32,430
The delete and close semantics are great.

00:28:32,430 --> 00:28:36,820
I think after 15 years, we can finally say yes, we think we

00:28:36,820 --> 00:28:37,800
understand this.

00:28:37,800 --> 00:28:40,032
We have a test suite for it and it hasn't failed at least

00:28:40,032 --> 00:28:42,240
in a month.

00:28:42,240 --> 00:28:45,030
And the delete and close semantics are in Unix, when

00:28:45,030 --> 00:28:47,590
you have an open file and you unlink it, essentially it goes

00:28:47,590 --> 00:28:50,400
away, disappears from the directory listing, and will

00:28:50,400 --> 00:28:53,110
stay around while there's any handles referencing it.

00:28:53,110 --> 00:28:55,350
Windows has sort of the same thing,

00:28:55,350 --> 00:28:57,160
except that it's different.

00:28:57,160 --> 00:28:59,390
Windows has something called delete on close, because I

00:28:59,390 --> 00:29:02,520
really wanted to implement it using that Unix mechanism.

00:29:02,520 --> 00:29:05,450
Turns out that won't work because for Windows, when you

00:29:05,450 --> 00:29:10,380
set the delete on close bit, what happens is you can't open

00:29:10,380 --> 00:29:13,000
the file, you can't do anything with the file, it's

00:29:13,000 --> 00:29:17,800
essentially identical to the Unix disappeared file except

00:29:17,800 --> 00:29:19,050
for one important thing.

00:29:19,050 --> 00:29:21,280
It still stays in the directory, and if you do a

00:29:21,280 --> 00:29:23,300
directory listing, you can still see it.

00:29:23,300 --> 00:29:27,320
So we had to implement this entire unbelievably complex

00:29:27,320 --> 00:29:30,340
layer to make that work.

00:29:30,340 --> 00:29:34,850
And then the other one are share modes, which is the

00:29:34,850 --> 00:29:38,760
reason why no one has yet done a really efficient clustered

00:29:38,760 --> 00:29:40,640
Windows file server.

00:29:40,640 --> 00:29:42,820
Share modes are the bane of my life.

00:29:42,820 --> 00:29:44,960
We actually implement them, we think,

00:29:44,960 --> 00:29:47,010
completely correctly now.

00:29:47,010 --> 00:29:49,760
So share modes are when you open a file and you say I'm

00:29:49,760 --> 00:29:52,700
opening this file for write, and I don't want anyone else

00:29:52,700 --> 00:29:55,600
to be able to open it for write at the same time or for

00:29:55,600 --> 00:29:57,200
Anyone else to open them for read.

00:29:57,200 --> 00:30:00,770
But the problem with this is they are global state across--

00:30:00,770 --> 00:30:03,240
imagine that you had a clustered file system with

00:30:03,240 --> 00:30:08,620
multiple CIFS servers sharing the same back end clustered

00:30:08,620 --> 00:30:10,450
file system.

00:30:10,450 --> 00:30:13,560
The issue is if one of the clients comes in and says I'm

00:30:13,560 --> 00:30:17,180
opening myfile.doc and I want no one else to be able to read

00:30:17,180 --> 00:30:20,670
from this, that state has to be replicated across every

00:30:20,670 --> 00:30:23,180
node in the cluster to stop another client from coming in

00:30:23,180 --> 00:30:24,900
and opening the same file.

00:30:24,900 --> 00:30:28,020
This global state problem is one of the reasons why cluster

00:30:28,020 --> 00:30:31,370
CIFS is really hard and really ugly.

00:30:31,370 --> 00:30:33,820
Tridge actually thinks he's solved that problem now, but

00:30:33,820 --> 00:30:37,090
I'll go into that in a little while.

00:30:37,090 --> 00:30:39,210
That's one of the main things he's been working on for about

00:30:39,210 --> 00:30:40,770
the past year, he's making that work

00:30:40,770 --> 00:30:42,360
and making it efficient.

00:30:42,360 --> 00:30:43,990
So I would say the file serving code is

00:30:43,990 --> 00:30:45,590
probably our best code.

00:30:45,590 --> 00:30:48,670
It's the most well-tested code for things that if it breaks,

00:30:48,670 --> 00:30:51,180
people scream at it louder and harder than just about

00:30:51,180 --> 00:30:53,420
anything else.

00:30:53,420 --> 00:30:56,700
The other thing is we have a wonderful torture suite, which

00:30:56,700 --> 00:30:58,670
I believe that Microsoft used.

00:30:58,670 --> 00:31:01,840
I'm not 100% sure, I know they've submitted some patches

00:31:01,840 --> 00:31:04,960
for it in the past. The nice thing about the Samba4 torture

00:31:04,960 --> 00:31:08,770
suite is that we have a build farm of machines that are

00:31:08,770 --> 00:31:11,620
run-- people donate idle cycles on their machines, they

00:31:11,620 --> 00:31:12,730
set up a bunch of scripts.

00:31:12,730 --> 00:31:14,520
They don't have to run as root.

00:31:14,520 --> 00:31:17,600
And what happens is it just checks out subversion versions

00:31:17,600 --> 00:31:21,500
of Samba and builds it and runs the test suite and

00:31:21,500 --> 00:31:24,920
occasionally, people actually look at it and see what broke

00:31:24,920 --> 00:31:27,330
on lots of different machines.

00:31:27,330 --> 00:31:31,510
The Samba4 torture suite is very, very nice because it

00:31:31,510 --> 00:31:32,830
like I say, there are six different ways

00:31:32,830 --> 00:31:33,720
of opening a file.

00:31:33,720 --> 00:31:37,280
The Samba4 torture suite will actually open a file using all

00:31:37,280 --> 00:31:40,300
six mechanisms and then actually check to see that the

00:31:40,300 --> 00:31:43,070
metadata is consistent between all the opens, and it will

00:31:43,070 --> 00:31:45,850
modify the data on one and check that it's consistent.

00:31:45,850 --> 00:31:51,210
We also have a very interesting layer that checks

00:31:51,210 --> 00:31:52,570
error codes as well.

00:31:52,570 --> 00:31:55,310
And then the we have the ultimate test, which is called

00:31:55,310 --> 00:32:01,975
gentest, which is actually a program that you point at two

00:32:01,975 --> 00:32:03,190
servers, essentially.

00:32:03,190 --> 00:32:06,590
What it does is it generates a random sequence of file system

00:32:06,590 --> 00:32:10,220
operations, fires them at both servers, factors out the

00:32:10,220 --> 00:32:13,000
things that it expects to be different like handle IDs,

00:32:13,000 --> 00:32:16,520
timestamps or whatever, and it essentially looks at the data

00:32:16,520 --> 00:32:20,340
stream for differences in error codes, anything that

00:32:20,340 --> 00:32:21,030
might be different.

00:32:21,030 --> 00:32:24,230
So it's really, really a fantastic check because our

00:32:24,230 --> 00:32:27,180
CIFS is essentially defined as what does the current version

00:32:27,180 --> 00:32:31,360
of Windows 2003 Release 2 do?

00:32:31,360 --> 00:32:34,180
The other thing that it's very useful for is if we find a

00:32:34,180 --> 00:32:36,940
strange behavior and we're not sure whether it's the Windows

00:32:36,940 --> 00:32:40,950
bug, we run gentest between Windows 2000 and Windows 2003

00:32:40,950 --> 00:32:44,250
and we see if it matches because Microsoft also has

00:32:44,250 --> 00:32:47,090
regression tests and therefore, if they didn't

00:32:47,090 --> 00:32:49,420
think it was worth fixing in their regression tests, then

00:32:49,420 --> 00:32:51,580
we know that that behavior, weird though it may be,

00:32:51,580 --> 00:32:53,800
doesn't actually matter.

00:32:53,800 --> 00:32:56,320
So yeah, we're getting pretty good at testing.

00:32:56,320 --> 00:32:59,290


00:32:59,290 --> 00:33:04,310
As I discovered when I came here, testing is king.

00:33:04,310 --> 00:33:07,050
Any line of code that you test you don't have to fix

00:33:07,050 --> 00:33:08,300
bugs in later on.

00:33:08,300 --> 00:33:11,410


00:33:11,410 --> 00:33:12,820
CIFS is in your future, and this is

00:33:12,820 --> 00:33:14,070
why MS sucks, basically.

00:33:14,070 --> 00:33:18,440


00:33:18,440 --> 00:33:22,200
I was rather mean to someone, I fussed him on this slide.

00:33:22,200 --> 00:33:24,170
So my theory goes like this.

00:33:24,170 --> 00:33:25,780
Everybody has Windows, right?

00:33:25,780 --> 00:33:26,850
Is there anyone here in an

00:33:26,850 --> 00:33:29,480
organization that has no Windows?

00:33:29,480 --> 00:33:30,795
OK, where do you work?

00:33:30,795 --> 00:33:32,400
AUDIENCE: Here.

00:33:32,400 --> 00:33:33,585
JEREMY ALLISON: We have Windows.

00:33:33,585 --> 00:33:34,630
AUDIENCE: I don't have Windows.

00:33:34,630 --> 00:33:36,070
JEREMY ALLISON: No, I'm talking about the

00:33:36,070 --> 00:33:36,760
organization.

00:33:36,760 --> 00:33:39,910
Yes, yes, I don't have Windows other than VMware at my home,

00:33:39,910 --> 00:33:41,600
but that's not part of the point, is it?

00:33:41,600 --> 00:33:42,460
All right, what about you?

00:33:42,460 --> 00:33:43,366
AUDIENCE: [INAUDIBLE].

00:33:43,366 --> 00:33:44,616
JEREMY ALLISON: OK, so yeah.

00:33:44,616 --> 00:33:47,670


00:33:47,670 --> 00:33:49,480
As I like to say to people when they come into Google,

00:33:49,480 --> 00:33:51,120
welcome to fantasy island.

00:33:51,120 --> 00:33:54,470


00:33:54,470 --> 00:33:57,480
Walk around marketing, you will find that Google uses

00:33:57,480 --> 00:34:01,520
probably more Windows than most companies I've seen.

00:34:01,520 --> 00:34:02,770
Everybody uses Windows.

00:34:02,770 --> 00:34:05,300


00:34:05,300 --> 00:34:07,666
The guy I was mean to was basically one of these oh, I'm

00:34:07,666 --> 00:34:09,900
a self-consultant and I only do GNU Linux stuff.

00:34:09,900 --> 00:34:12,820
And I'm like well, OK, outside of your parents' basement, is

00:34:12,820 --> 00:34:14,638
there anyone who actually--

00:34:14,638 --> 00:34:17,286
but he was a bit offended by that, nevermind.

00:34:17,286 --> 00:34:19,020
But everybody has Windows, right?

00:34:19,020 --> 00:34:20,139
It's the law, it's the rules.

00:34:20,139 --> 00:34:22,750
Everybody uses Windows at least for something.

00:34:22,750 --> 00:34:25,600
So you're going to have Windows on your desktop, and

00:34:25,600 --> 00:34:29,230
Windows simply doesn't do NFS or any other file sharing

00:34:29,230 --> 00:34:32,389
protocol that isn't nailed into the thing by Microsoft

00:34:32,389 --> 00:34:35,699
because that's the way they designed it.

00:34:35,699 --> 00:34:37,199
You can't add stuff in.

00:34:37,199 --> 00:34:39,300
People have been trained over the years, you only ever run

00:34:39,300 --> 00:34:41,400
Microsoft code on Windows because if you run anything

00:34:41,400 --> 00:34:44,320
else, it's going to break for the next service pack.

00:34:44,320 --> 00:34:47,820
So essentially, you're going to have to use CIFS, right?

00:34:47,820 --> 00:34:53,020
So if you want Linux and Mac OS X to live in that world,

00:34:53,020 --> 00:34:54,480
they're going to have to use CIFS, too.

00:34:54,480 --> 00:34:55,370
Yes, question.

00:34:55,370 --> 00:34:56,850
Hurray, my first question.

00:34:56,850 --> 00:34:58,300
If I had a bean bag or something I

00:34:58,300 --> 00:34:58,830
would throw it at you.

00:34:58,830 --> 00:35:02,600
AUDIENCE: I take it you're not taking WebDev seriously.

00:35:02,600 --> 00:35:04,750
JEREMY ALLISON: The question was, you're not taking WebDev

00:35:04,750 --> 00:35:05,570
seriously enough.

00:35:05,570 --> 00:35:09,460
As far as I can tell, nobody takes WebDev seriously.

00:35:09,460 --> 00:35:12,110
So no, I'm not taking WebDev seriously.

00:35:12,110 --> 00:35:13,790
Everybody uses CIFS.

00:35:13,790 --> 00:35:17,130
Linux and Mac OS X need to live in that world.

00:35:17,130 --> 00:35:19,520
Everybody has Active Directory.

00:35:19,520 --> 00:35:22,190
Unfortunate fact of life, but it's true.

00:35:22,190 --> 00:35:25,070
The last numbers I saw was that Active Directory had

00:35:25,070 --> 00:35:28,900
something like 70% to 80% of the authentication market.

00:35:28,900 --> 00:35:32,270
So you have to fit into that world.

00:35:32,270 --> 00:35:34,700
If you want Linux to be successful on the desktop, if

00:35:34,700 --> 00:35:38,190
you want Mac OS X, it has to live in that world.

00:35:38,190 --> 00:35:41,396
So they have to have good CIFS client implementations.

00:35:41,396 --> 00:35:43,970


00:35:43,970 --> 00:35:47,970
So IBM has full-time coders working on the CIFS client,

00:35:47,970 --> 00:35:51,120
the Linux kernel, that's Steve French, Andy

00:35:51,120 --> 00:35:52,400
and some other people.

00:35:52,400 --> 00:35:56,460
So essentially, Apple has two people, full-time coders who

00:35:56,460 --> 00:36:00,350
are local here, we collaborate.

00:36:00,350 --> 00:36:02,880
CIFS to the desktop will dominate.

00:36:02,880 --> 00:36:05,860
I'm not talking about the back end server farms that are

00:36:05,860 --> 00:36:11,020
going to run GFS or GPFS or Red Hat GFS, or even, god

00:36:11,020 --> 00:36:12,880
forbid, NFSv4.

00:36:12,880 --> 00:36:16,760
But to the desktop, people only want to have one file

00:36:16,760 --> 00:36:18,210
sharing protocol.

00:36:18,210 --> 00:36:27,340
So if we can make CIFS work in a Unix-to-Unix world as well

00:36:27,340 --> 00:36:29,920
as it does in a Windows-to-Windows or

00:36:29,920 --> 00:36:33,680
Windows-to-Samba world, we can start to infiltrate this with

00:36:33,680 --> 00:36:35,700
our desktop clients.

00:36:35,700 --> 00:36:38,610
And the more desktop clients that are out there that aren't

00:36:38,610 --> 00:36:43,050
Windows, the less control there is over the future of

00:36:43,050 --> 00:36:44,690
CIFS in the hands of Microsoft.

00:36:44,690 --> 00:36:50,120
So therefore, it becomes a lot harder for new changes to

00:36:50,120 --> 00:36:51,990
break functionality.

00:36:51,990 --> 00:36:56,930
So essentially, everybody collaborates on--

00:36:56,930 --> 00:36:58,415
let me just check my next slide, because I can't

00:36:58,415 --> 00:37:00,350
remember what it is--

00:37:00,350 --> 00:37:01,850
I think this is, yes, hooray.

00:37:01,850 --> 00:37:04,660


00:37:04,660 --> 00:37:13,600
So what happened about seven or eight years ago, SCO, back

00:37:13,600 --> 00:37:17,030
when this was the non-insane SCO, the one that became

00:37:17,030 --> 00:37:22,960
Tarantella, actually came up with some ideas to make CIFS--

00:37:22,960 --> 00:37:26,070
because they had a CIFS server and they wanted to fit in a

00:37:26,070 --> 00:37:29,320
Windows world-- they wanted to make CIFS work Unix-to-Unix.

00:37:29,320 --> 00:37:32,050
So they came up with this document they called the CIFS

00:37:32,050 --> 00:37:33,610
Unix Extensions.

00:37:33,610 --> 00:37:37,310
And Microsoft blessed a very small area of the CIFS space,

00:37:37,310 --> 00:37:40,800
but it was enough, a very small area of the CIFS space

00:37:40,800 --> 00:37:44,000
that essentially they said, this is the CIFS UNIX area.

00:37:44,000 --> 00:37:46,800
We will not introduce any new upcodes in this area.

00:37:46,800 --> 00:37:49,530
This is yours to define.

00:37:49,530 --> 00:37:52,170
HP then took it over because HP was very interested in

00:37:52,170 --> 00:37:54,770
making HP-UX.

00:37:54,770 --> 00:37:58,260
HP-UX has this interesting little NFS-to-CIFS gateway

00:37:58,260 --> 00:38:00,550
that allows HP-UX boxes to play well in a

00:38:00,550 --> 00:38:02,950
Windows-CIFS world.

00:38:02,950 --> 00:38:09,180
And then obviously, the CIFSFS came along, the Thursby people

00:38:09,180 --> 00:38:12,230
created a Mac client which essentially Apple

00:38:12,230 --> 00:38:14,020
then did their own.

00:38:14,020 --> 00:38:19,630
There's now a version called SMBFS which is different from

00:38:19,630 --> 00:38:21,920
the Linux SMBFS.

00:38:21,920 --> 00:38:23,550
How many people get confused between the

00:38:23,550 --> 00:38:25,015
CIFS SF and the SMBFS?

00:38:25,015 --> 00:38:27,050
Is there anyone here actually running SMBFS

00:38:27,050 --> 00:38:29,300
on their Linus systems?

00:38:29,300 --> 00:38:31,120
Stop.

00:38:31,120 --> 00:38:33,640
It's unsupported and it should die.

00:38:33,640 --> 00:38:35,550
I'm trying to get it out of the kernel.

00:38:35,550 --> 00:38:38,110
Essentially, it's old, it has millions of bugs, it doesn't

00:38:38,110 --> 00:38:39,350
do any of the modern things.

00:38:39,350 --> 00:38:42,900
What we're trying to do is standardize on CIFS in the

00:38:42,900 --> 00:38:47,650
Linux kernel in Mac OS X, and what we are trying to do is,

00:38:47,650 --> 00:38:54,190
on my next slide, add these Unix extensions to make CIFS

00:38:54,190 --> 00:38:58,520
work as a Unix-to-Unix file sharing protocol.

00:38:58,520 --> 00:39:03,350
So the goal was not to mess with CIFS because it's already

00:39:03,350 --> 00:39:05,600
complicated and ugly enough.

00:39:05,600 --> 00:39:10,450
So make minimal changes to make the semantics match POSIX

00:39:10,450 --> 00:39:12,460
as well as we possibly can.

00:39:12,460 --> 00:39:17,610
The reason you design by SCO, it was not very well done

00:39:17,610 --> 00:39:18,570
originally.

00:39:18,570 --> 00:39:21,510
For instance, they defined fields and then didn't define

00:39:21,510 --> 00:39:26,490
the units that those fields were actually defined in.

00:39:26,490 --> 00:39:30,815
So they just assumed that all stats produced the same block

00:39:30,815 --> 00:39:32,330
size, which is not true.

00:39:32,330 --> 00:39:34,490
I ended up having an argument with Linus over that.

00:39:34,490 --> 00:39:38,870
So we've since expanded it out, and we

00:39:38,870 --> 00:39:40,640
now do POSIX locking.

00:39:40,640 --> 00:39:45,830
And when I mean POSIX locking I mean we can pass any POSIX

00:39:45,830 --> 00:39:50,490
locking file test. Try that with NFS.

00:39:50,490 --> 00:39:52,620
Everything actually works.

00:39:52,620 --> 00:39:57,580
Interruptible locks, blocking locks, non-blocking locks, the

00:39:57,580 --> 00:40:01,670
insane locking semantics where you dupe a file to scripture

00:40:01,670 --> 00:40:02,360
and it goes away.

00:40:02,360 --> 00:40:05,970
Basically, we do everything on the wire and it all works.

00:40:05,970 --> 00:40:09,530
We do POSIX ACLs, we have an extension that will do POSIX

00:40:09,530 --> 00:40:11,470
ACLs on the wire.

00:40:11,470 --> 00:40:14,010
We do Linux-style extended attributes.

00:40:14,010 --> 00:40:18,190
The only difference there is they're case insensitive.

00:40:18,190 --> 00:40:21,370
That's the only thing that you could notice there.

00:40:21,370 --> 00:40:24,200


00:40:24,200 --> 00:40:24,560
Question.

00:40:24,560 --> 00:40:27,542
AUDIENCE: I was just curious with the POSIX ACLs.

00:40:27,542 --> 00:40:34,997
Are there plans to allow multiple users access to a

00:40:34,997 --> 00:40:39,470
single CIFS mount, similar to NFS?

00:40:39,470 --> 00:40:41,600
You know what I mean?

00:40:41,600 --> 00:40:43,120
[INAUDIBLE].

00:40:43,120 --> 00:40:46,720
JEREMY ALLISON: So the comment is, are there plans to make

00:40:46,720 --> 00:40:49,920
multi-user access to CIFS mounts work.

00:40:49,920 --> 00:40:52,890
That is part of the CIFS protocol.

00:40:52,890 --> 00:40:55,920
That's something that needs to be put in the CIFSSF client.

00:40:55,920 --> 00:40:58,700
I think Steve has an experimental

00:40:58,700 --> 00:41:00,170
implementation of that.

00:41:00,170 --> 00:41:01,940
Essentially, what has to happen-- and this is where it

00:41:01,940 --> 00:41:02,710
gets difficult--

00:41:02,710 --> 00:41:10,400
is when you traverse into that mounts point, because CIFS

00:41:10,400 --> 00:41:12,600
doesn't believe the client when it tells it the

00:41:12,600 --> 00:41:14,070
client's user ID.

00:41:14,070 --> 00:41:16,250
You have to actually authenticate as

00:41:16,250 --> 00:41:17,560
that incoming user.

00:41:17,560 --> 00:41:21,410
So any process with that user ID that traverses into that

00:41:21,410 --> 00:41:24,470
mount point, and that point has to do another session set

00:41:24,470 --> 00:41:27,620
up and get another user ID token that will then represent

00:41:27,620 --> 00:41:28,870
it on the wire.

00:41:28,870 --> 00:41:31,330


00:41:31,330 --> 00:41:34,900
This is essentially similar to a Kerberos file system in that

00:41:34,900 --> 00:41:36,620
you can't do this anonymously.

00:41:36,620 --> 00:41:39,200
So if you have a process running a root and you just

00:41:39,200 --> 00:41:41,890
change the user ID to any arbitrary user ID and then you

00:41:41,890 --> 00:41:44,680
try and traverse into that mount point, you will be

00:41:44,680 --> 00:41:47,090
denied even though you are legitimately running as that

00:41:47,090 --> 00:41:51,070
UID, because you don't have that user's credentials.

00:41:51,070 --> 00:41:52,620
You don't have a Kerberos ticket or you don't have a

00:41:52,620 --> 00:41:54,170
password for that user.

00:41:54,170 --> 00:41:54,810
Yeah, question.

00:41:54,810 --> 00:41:57,210
AUDIENCE: Don't you have the SUID credentials?

00:41:57,210 --> 00:41:58,840
JEREMY ALLISON: So the question is, don't you have

00:41:58,840 --> 00:42:00,630
the credentials from SUID?

00:42:00,630 --> 00:42:03,610
Well no, if you think about it, when you root, you can

00:42:03,610 --> 00:42:07,570
arbitrarily change your effective user ID to any user

00:42:07,570 --> 00:42:08,510
ID on the system.

00:42:08,510 --> 00:42:11,390
That doesn't mean you have their credentials.

00:42:11,390 --> 00:42:13,990
Remember, when you're traversing into a CIFS mount

00:42:13,990 --> 00:42:17,260
point, you're actually accessing the remote server

00:42:17,260 --> 00:42:20,290
and you can't just put a UID on the wire and say oh, I'm

00:42:20,290 --> 00:42:21,690
now user ID 100.

00:42:21,690 --> 00:42:23,920
We don't believe you.

00:42:23,920 --> 00:42:25,420
You have to authenticate correctly.

00:42:25,420 --> 00:42:28,710
So you have to get a Kerberos ticket for that or you have to

00:42:28,710 --> 00:42:33,570
have a cached password in some way and do MTOM

00:42:33,570 --> 00:42:34,700
authentication.

00:42:34,700 --> 00:42:38,100
So there are some issues there, but they're exactly the

00:42:38,100 --> 00:42:39,930
same issues that you would get with Kerberized NFS.

00:42:39,930 --> 00:42:45,140


00:42:45,140 --> 00:42:47,600
There's experimental code there, I don't how widely used

00:42:47,600 --> 00:42:49,480
that is right now.

00:42:49,480 --> 00:42:52,060
To be honest, mostly we're concentrating on the

00:42:52,060 --> 00:42:55,810
single-user laptop, desktop system that doesn't have a lot

00:42:55,810 --> 00:42:58,180
of different processes running as different users on it.

00:42:58,180 --> 00:43:00,180
So you mount this one user.

00:43:00,180 --> 00:43:01,910
So that's the best tester code, at

00:43:01,910 --> 00:43:05,110
least in the CIFS client.

00:43:05,110 --> 00:43:09,710
So the other thing we recently added to save round trips was

00:43:09,710 --> 00:43:12,440
POSIX open [UNINTELLIGIBLE] and on-link.

00:43:12,440 --> 00:43:17,180
And in fact, I've got to do this next month because I'm

00:43:17,180 --> 00:43:22,000
giving a talk on it in Germany, the really difficult

00:43:22,000 --> 00:43:26,100
part of this is working out and writing down the semantics

00:43:26,100 --> 00:43:29,240
of what happens when you have a Windows client and a

00:43:29,240 --> 00:43:35,530
POSIX-based client, we calling this the POSIX extensions,

00:43:35,530 --> 00:43:38,520
accessing the same file at the same time.

00:43:38,520 --> 00:43:42,670
I actually thought I had this reasonably well-specified

00:43:42,670 --> 00:43:46,480
because once a client had switched into POSIX mode,

00:43:46,480 --> 00:43:47,000
essentially--

00:43:47,000 --> 00:43:51,380
so you get case sensitive path names and the separatory slash

00:43:51,380 --> 00:43:53,800
and all the rest of the things you would expect--

00:43:53,800 --> 00:43:59,580
once a client has flipped into POSIX mode, I assume that it

00:43:59,580 --> 00:44:01,690
would never need any Windows semantics again.

00:44:01,690 --> 00:44:05,410
And then the Mac OS X bastards basically came up and said, we

00:44:05,410 --> 00:44:09,630
have this subsystem, Cocoa Puffs or whatever, and they

00:44:09,630 --> 00:44:12,880
want partly Windows semantics and partly POSIX.

00:44:12,880 --> 00:44:16,500
So we're going to make cool lock codes that will look like

00:44:16,500 --> 00:44:17,690
Windows locks.

00:44:17,690 --> 00:44:19,890
So we have to go back and rewrite this thing again to

00:44:19,890 --> 00:44:23,670
essentially work out precisely how the semantics of the

00:44:23,670 --> 00:44:29,430
different operations would mix on the same TCP connection, so

00:44:29,430 --> 00:44:30,680
that's going to be fun.

00:44:30,680 --> 00:44:34,030
And the goal is essentially to write this up as an RFC.

00:44:34,030 --> 00:44:36,440
And I think when we're done what we'll do is we'll submit

00:44:36,440 --> 00:44:39,260
it back to Microsoft to put into their documentation that

00:44:39,260 --> 00:44:44,160
they make available under licensing for CIFS vendors.

00:44:44,160 --> 00:44:49,590
The goal would be to get Network Appliance and EMC to

00:44:49,590 --> 00:44:52,010
adopt these Unix extensions as well.

00:44:52,010 --> 00:44:55,970
So at that point, we have a fairly vibrant server and

00:44:55,970 --> 00:44:58,730
client community so that Samba isn't the only server that

00:44:58,730 --> 00:45:00,550
supports these.

00:45:00,550 --> 00:45:03,150
And essentially at that point, CIFS start to take over the

00:45:03,150 --> 00:45:07,530
desktop, even for Unix environments, and NFS before

00:45:07,530 --> 00:45:10,190
is banished into the dungeons of the server room where it

00:45:10,190 --> 00:45:12,790
belongs, in my opinion.

00:45:12,790 --> 00:45:18,030
The other really cool thing that I finished recently is to

00:45:18,030 --> 00:45:23,560
transport level encryption, because essentially, this is

00:45:23,560 --> 00:45:26,120
one of those, NFS has it, so we must, too.

00:45:26,120 --> 00:45:30,980
So NFS can essentially have Kerberized transport

00:45:30,980 --> 00:45:37,530
encryption for just basic file service, so I've extended the

00:45:37,530 --> 00:45:41,260
Unix extensions to be able to negotiate an encrypted

00:45:41,260 --> 00:45:44,220
communication using GSF API.

00:45:44,220 --> 00:45:48,740
The nice thing about the design that we've done is that

00:45:48,740 --> 00:45:51,390
for big organizations like Google that tend to use

00:45:51,390 --> 00:45:54,640
Kerberos, this will just be another Kerberized transport.

00:45:54,640 --> 00:45:56,110
So it'll just fit into whatever Kerberos

00:45:56,110 --> 00:45:57,240
infrastructure you've got.

00:45:57,240 --> 00:45:59,080
It'll fit into any Active Directory Kerberized

00:45:59,080 --> 00:46:00,120
infrastructure.

00:46:00,120 --> 00:46:03,540
But the really cool thing is for the little NAS boxes

00:46:03,540 --> 00:46:05,030
because, I don't know whether you realize,

00:46:05,030 --> 00:46:06,670
but you go to Fry's.

00:46:06,670 --> 00:46:11,300
any little NAS box that's under $5,000 is Samba and

00:46:11,300 --> 00:46:14,500
Linux inside, almost guaranteed.

00:46:14,500 --> 00:46:16,460
It colonizes that space.

00:46:16,460 --> 00:46:19,230
Well the great thing is once those guys start picking up

00:46:19,230 --> 00:46:23,470
the newer versions of Samba, you can actually do encrypted

00:46:23,470 --> 00:46:26,760
file transport essentially based on standard MTOM

00:46:26,760 --> 00:46:30,860
encryption, and it will just use the same encryption

00:46:30,860 --> 00:46:34,870
mechanisms that Microsoft uses for that RPC transport, except

00:46:34,870 --> 00:46:37,000
that it'll be using it for CIFS instead.

00:46:37,000 --> 00:46:39,030
So essentially, your home network will have an

00:46:39,030 --> 00:46:44,740
alternative to SSH FS, and it will be CIFS.

00:46:44,740 --> 00:46:48,130
And the Mac OS guys want to get this into Mac OS X, and

00:46:48,130 --> 00:46:51,730
obviously Steve is kind of keen to get into Linux.

00:46:51,730 --> 00:46:56,810
So at that point, the era of the plain text file sharing

00:46:56,810 --> 00:47:00,070
transport will be over.

00:47:00,070 --> 00:47:03,580
The cool thing about the MTOM version of it is no, it won't

00:47:03,580 --> 00:47:06,540
be very secure and no, I wouldn't recommend using it in

00:47:06,540 --> 00:47:09,330
a large commercial environment, but the great

00:47:09,330 --> 00:47:11,300
thing is it's trivial to set up.

00:47:11,300 --> 00:47:13,750
You don't have to worry about Kerberos clock skew, you don't

00:47:13,750 --> 00:47:16,910
have to worry about having machine principles.

00:47:16,910 --> 00:47:19,750
If you can authenticate, you get encrypted transport.

00:47:19,750 --> 00:47:23,430
So that's the really cool thing about it.

00:47:23,430 --> 00:47:25,205
So in fact, let's go onto authentication.

00:47:25,205 --> 00:47:27,910


00:47:27,910 --> 00:47:30,920
The original authentication, as I said, was hey, who does

00:47:30,920 --> 00:47:34,070
this Windows user map to on the Unix box?

00:47:34,070 --> 00:47:37,450
And with a little help from a Microsoft engineer who shall

00:47:37,450 --> 00:47:40,120
remain nameless but is one of the unsung heroes of Samba--

00:47:40,120 --> 00:47:44,610


00:47:44,610 --> 00:47:46,170
here's one of those interesting historical

00:47:46,170 --> 00:47:51,870
stories-- the original specifications four CIFS,

00:47:51,870 --> 00:47:53,840
there's essentially a cryptographic constant that

00:47:53,840 --> 00:47:57,210
you need that in the specification that we had,

00:47:57,210 --> 00:48:01,760
that I bought from X/Open said you need the eight-byte magic

00:48:01,760 --> 00:48:04,290
constant of, and then it was eight question marks.

00:48:04,290 --> 00:48:06,440
So we tried that and it didn't work.

00:48:06,440 --> 00:48:07,830
So it was like, hmm.

00:48:07,830 --> 00:48:12,450
What this actually turned out was that Microsoft had refused

00:48:12,450 --> 00:48:15,420
to give it to X/Open when they were standardizing it on

00:48:15,420 --> 00:48:18,600
basically legal advice that it was so insecure that if they

00:48:18,600 --> 00:48:20,530
did that, they were going to get sued.

00:48:20,530 --> 00:48:23,700
So X/Open didn't know what it was.

00:48:23,700 --> 00:48:25,400
So rather than saying, and this is a value

00:48:25,400 --> 00:48:25,920
that we don't know--

00:48:25,920 --> 00:48:31,808
[ADJUSTING MICROPHONE]

00:48:31,808 --> 00:48:33,150
JEREMY ALLISON: Hello?

00:48:33,150 --> 00:48:36,230
They put question marks there.

00:48:36,230 --> 00:48:40,920
So with some help at our Microsoft Professional

00:48:40,920 --> 00:48:47,660
Development Conference, a Microsoft engineer actually

00:48:47,660 --> 00:48:51,320
did help us out in getting this information.

00:48:51,320 --> 00:48:55,770
Now originally, we had absolutely no desires or goals

00:48:55,770 --> 00:48:58,330
to be in domain control, and we couldn't care.

00:48:58,330 --> 00:48:59,360
We're a file server, we're happy.

00:48:59,360 --> 00:49:02,640
If Microsoft want to be domain controllers, let them.

00:49:02,640 --> 00:49:07,940
Now what happened was Windows NT came out.

00:49:07,940 --> 00:49:11,800
Windows NT had access control lists.

00:49:11,800 --> 00:49:15,080
They're essentially similar to POSIX user grouping world.

00:49:15,080 --> 00:49:17,780
I thought, hey, i can do a mapping of this.

00:49:17,780 --> 00:49:21,720
I created the mapping, and what happens is Windows makes

00:49:21,720 --> 00:49:24,710
the request that says, show me the ACLs.

00:49:24,710 --> 00:49:27,340
You send the ACLs back, and what you send back instead of

00:49:27,340 --> 00:49:29,920
user IDs is you send these things called SIDS, which are

00:49:29,920 --> 00:49:33,730
essentially 128-bit GUIDs representing the user.

00:49:33,730 --> 00:49:35,130
But then at that point, something really

00:49:35,130 --> 00:49:36,740
evil and ugly happened.

00:49:36,740 --> 00:49:39,880
The client said, oh, well if you're giving me this stuff,

00:49:39,880 --> 00:49:41,240
then you must be able to--

00:49:41,240 --> 00:49:44,520
I'm going to talk to you, I'm going to stop trying to do RPC

00:49:44,520 --> 00:49:49,030
transport to you and I'm going to essentially expect an

00:49:49,030 --> 00:49:52,500
entire new infrastructure, which we didn't have, and I'm

00:49:52,500 --> 00:49:57,000
going to say OK, and all this was to map the SID into a

00:49:57,000 --> 00:49:58,330
displayable name.

00:49:58,330 --> 00:50:02,310
And if you didn't do that, you got the S-1-5.whatever that

00:50:02,310 --> 00:50:04,470
you get in the Windows ACL when it can't resolve a SID,

00:50:04,470 --> 00:50:05,145
which is ugly.

00:50:05,145 --> 00:50:07,340
And we didn't like ugly.

00:50:07,340 --> 00:50:11,510
So this spurred various people--

00:50:11,510 --> 00:50:14,160
I think Luke Leighton, Paul Ashton was another, no longer

00:50:14,160 --> 00:50:15,580
working on Samba--

00:50:15,580 --> 00:50:18,510
to essentially investigate what this was.

00:50:18,510 --> 00:50:21,970
And they did an immense amount of work and they actually

00:50:21,970 --> 00:50:26,400
realize that what it was was DCRPC and essentially they

00:50:26,400 --> 00:50:27,960
worked out how this was done.

00:50:27,960 --> 00:50:31,580
It turned out that once you had this, you'd got most of

00:50:31,580 --> 00:50:34,950
the core of what a domain controller was.

00:50:34,950 --> 00:50:36,720
Essentially, the domain controller authentication

00:50:36,720 --> 00:50:40,290
pieces were simply new RPCs.

00:50:40,290 --> 00:50:43,450
So we ended up essentially implementing an NT 4.

00:50:43,450 --> 00:50:44,640
domain controller by accident.

00:50:44,640 --> 00:50:47,390
Not that it's finished yet, but it's complete enough

00:50:47,390 --> 00:50:50,120
within all that back end that it's very usable as a

00:50:50,120 --> 00:50:52,710
replacement for NT 4.

00:50:52,710 --> 00:50:55,350
Problem is, nobody uses NT 4 anymore.

00:50:55,350 --> 00:50:58,220
Everybody's moved to Active Directory.

00:50:58,220 --> 00:51:01,690
Now we fit in extremely well into an Active Directory

00:51:01,690 --> 00:51:04,750
environment, as you may know.

00:51:04,750 --> 00:51:08,470
Samba3 file servers are mainly deployed as Active Directory

00:51:08,470 --> 00:51:10,940
member servers, and this is where Samba4 comes in.

00:51:10,940 --> 00:51:16,400


00:51:16,400 --> 00:51:18,130
Before I get to Samba4.

00:51:18,130 --> 00:51:20,670
By the way, I don't know how much time I've got here so I'm

00:51:20,670 --> 00:51:22,740
just going to keep talking until I run out of material or

00:51:22,740 --> 00:51:24,820
people stop asking questions.

00:51:24,820 --> 00:51:28,650
If you're bored or fed up, just go.

00:51:28,650 --> 00:51:31,160
I'll leave when they turn the lights out or something.

00:51:31,160 --> 00:51:36,290
So the other piece that we have, which is incredibly cool

00:51:36,290 --> 00:51:40,110
and probably the best implementation out there in

00:51:40,110 --> 00:51:44,240
the field right now is in Novell's SLED to the Linux

00:51:44,240 --> 00:51:49,040
Desktop is winbindd, which--

00:51:49,040 --> 00:51:51,260
I wish I had a whiteboard.

00:51:51,260 --> 00:51:54,430
You really need a whiteboard for doing winbindd work.

00:51:54,430 --> 00:51:59,350
What winbindd does is it allows you to join a domain

00:51:59,350 --> 00:52:03,860
and to allow Windows clients to connect to you or you to

00:52:03,860 --> 00:52:08,240
even log in using NSS and Pam, log it onto that machine with

00:52:08,240 --> 00:52:09,920
Windows credentials.

00:52:09,920 --> 00:52:12,630
And you never have to create a Unix user on that box.

00:52:12,630 --> 00:52:15,610
winbindd essentially does that magic for you.

00:52:15,610 --> 00:52:18,160


00:52:18,160 --> 00:52:20,160
So we've had that working for quite a while.

00:52:20,160 --> 00:52:22,600
One of the things we extended it to do, which is extremely

00:52:22,600 --> 00:52:27,070
cool, is we now do offline authentication.

00:52:27,070 --> 00:52:32,910
So one of the big deals that we won while I was there was

00:52:32,910 --> 00:52:37,010
for a bunch of people who wanted to run SLED on their

00:52:37,010 --> 00:52:40,370
IBM laptops, and they had a complete Windows domain

00:52:40,370 --> 00:52:41,500
infrastructure.

00:52:41,500 --> 00:52:42,660
And they were managers.

00:52:42,660 --> 00:52:44,030
These were not technical people.

00:52:44,030 --> 00:52:49,160
They wanted to basically log in, do some stuff, suspend, go

00:52:49,160 --> 00:52:53,640
home, unsuspend, and log in using cached credentials on

00:52:53,640 --> 00:52:57,560
their screensaver and carry on doing work.

00:52:57,560 --> 00:53:01,035
So we did a lot of work in winbindd to make that work.

00:53:01,035 --> 00:53:03,730
So essentially, winbindd, if anyone is familiar with

00:53:03,730 --> 00:53:08,640
Windows, has become the LSA of Unix.

00:53:08,640 --> 00:53:13,580
In fact, there's an NSS back end, there's a pam back end to

00:53:13,580 --> 00:53:17,370
it, it's actually an extremely capable and flexible solution

00:53:17,370 --> 00:53:20,580
for doing offline authentication.

00:53:20,580 --> 00:53:23,110
There's no reason why you can't use this in a purely

00:53:23,110 --> 00:53:24,360
Unix-only network.

00:53:24,360 --> 00:53:27,240


00:53:27,240 --> 00:53:29,850
It's horribly difficult to set up, and this is one of that

00:53:29,850 --> 00:53:32,620
the main things that Novell did correctly, was they made

00:53:32,620 --> 00:53:35,580
it so that you have YaST module where you just say,

00:53:35,580 --> 00:53:37,950
please join me in this domain, and I want this domain to do

00:53:37,950 --> 00:53:39,420
all my authentication.

00:53:39,420 --> 00:53:42,050
At that point, when you log in you get a request for a user

00:53:42,050 --> 00:53:42,960
and a domain.

00:53:42,960 --> 00:53:47,060
You get two different boxes on login.

00:53:47,060 --> 00:53:50,760
And it's easy and it works.

00:53:50,760 --> 00:53:55,620
So the only issues with it are the scalability problems. In

00:53:55,620 --> 00:53:56,540
fact, do I have a slide on that?

00:53:56,540 --> 00:53:59,320
Or should I talk about it here?

00:53:59,320 --> 00:54:01,580
Yes, I have a slide about it.

00:54:01,580 --> 00:54:08,600
So this is a place where Linux and POSIX sucks, sucks, sucks,

00:54:08,600 --> 00:54:11,020
absolutely and completely.

00:54:11,020 --> 00:54:15,130
How many people here actually code C stuff on a system

00:54:15,130 --> 00:54:17,770
interface level on Unix?

00:54:17,770 --> 00:54:18,510
Not many.

00:54:18,510 --> 00:54:19,550
OK, nevermind.

00:54:19,550 --> 00:54:21,070
I'll try and explain.

00:54:21,070 --> 00:54:25,800
Essentially, Unix and Linux come from the old, venerable,

00:54:25,800 --> 00:54:28,180
local password file heritage.

00:54:28,180 --> 00:54:30,950
Now that's been modified greatly so that you have

00:54:30,950 --> 00:54:34,500
network implementations of that and you can have

00:54:34,500 --> 00:54:36,930
something called NSS that can be back ended onto anything.

00:54:36,930 --> 00:54:40,790
It can be LDAP, it can be SQL databases, who cares.

00:54:40,790 --> 00:54:43,570
In that respect, it's much more flexible and easy to use

00:54:43,570 --> 00:54:46,590
in the windows equivalent, but there's one

00:54:46,590 --> 00:54:48,390
fatal flaw with it.

00:54:48,390 --> 00:54:53,870
It still is limited to the APIs that you would use if you

00:54:53,870 --> 00:54:57,370
had a local password file with a couple hundred users in it.

00:54:57,370 --> 00:55:02,540
So if you want to find a particular user, you open the

00:55:02,540 --> 00:55:06,500
thing, you start pw ent, you walk through it one by one

00:55:06,500 --> 00:55:09,360
until you find the user, and then you're done.

00:55:09,360 --> 00:55:11,320
If you want to know what groups you're in, when you

00:55:11,320 --> 00:55:14,690
look up a group, for instance, it will come back with a text

00:55:14,690 --> 00:55:17,630
list of all members of that group because, hey, it's so

00:55:17,630 --> 00:55:18,820
easy to find.

00:55:18,820 --> 00:55:24,800
The problem is go to the kind of world that Windows is now

00:55:24,800 --> 00:55:27,570
being deployed in where you have domain controllers in

00:55:27,570 --> 00:55:31,970
Seattle, Bangalore, Europe, all for different--

00:55:31,970 --> 00:55:34,040
some of them, child domains, they're all in the same

00:55:34,040 --> 00:55:36,170
organization--

00:55:36,170 --> 00:55:41,270
if you want to look up a user, you can't enumerate anymore.

00:55:41,270 --> 00:55:45,610
You might have 200,000 users spread globally on servers

00:55:45,610 --> 00:55:49,400
that are linked together with 128 k pieces

00:55:49,400 --> 00:55:52,760
of wet string, basically.

00:55:52,760 --> 00:55:55,400
This is one of the things that caused me to really shout at

00:55:55,400 --> 00:55:59,580
the GNOME people, because this is actually bleeds through

00:55:59,580 --> 00:56:01,810
into many real applications.

00:56:01,810 --> 00:56:04,110
So the GNOME people in Nautilus came

00:56:04,110 --> 00:56:05,850
up with an ACL editor.

00:56:05,850 --> 00:56:08,670
And the ACL editor is great, you right click on a file, you

00:56:08,670 --> 00:56:09,980
say, I want to add an ACL to this.

00:56:09,980 --> 00:56:13,420
It says, oh, who do you want to add for the ACL?

00:56:13,420 --> 00:56:18,030
And it brings up a pop-up menu, which expects

00:56:18,030 --> 00:56:21,380
instantaneously to be able to show every single user on the

00:56:21,380 --> 00:56:22,700
system in a pop-up.

00:56:22,700 --> 00:56:25,580
Stupid, stupid, stupid.

00:56:25,580 --> 00:56:29,050
Windows, if you may have noticed using a modern Windows

00:56:29,050 --> 00:56:32,680
system, has moved completely to a search-based interface.

00:56:32,680 --> 00:56:35,800
It's almost impossible to get a list of users on Windows

00:56:35,800 --> 00:56:39,550
anymore without putting in some kind of LDAP or wild

00:56:39,550 --> 00:56:40,700
card-able search string.

00:56:40,700 --> 00:56:43,740
And that's what we have to do, that's what POSIX has to do.

00:56:43,740 --> 00:56:46,680
The problem with that is, of course, the typical

00:56:46,680 --> 00:56:49,510
standardization problem that you have to get everybody

00:56:49,510 --> 00:56:52,000
agreed to agree to do that.

00:56:52,000 --> 00:56:54,430
But right now, the main problem with winbindd

00:56:54,430 --> 00:56:59,670
scalability in this area is this incredibly stupid old

00:56:59,670 --> 00:57:03,430
style interface of enumerating every single thing, getting

00:57:03,430 --> 00:57:05,410
lots of information you don't need.

00:57:05,410 --> 00:57:09,210
We cache aggressively, we lie to applications all the time

00:57:09,210 --> 00:57:11,970
because mostly they don't care what other people are in the

00:57:11,970 --> 00:57:13,930
group, they only care if you're in that group.

00:57:13,930 --> 00:57:16,610
So we'll do things like you can set winbindd in a mode

00:57:16,610 --> 00:57:19,560
where you say, get me a group list, and it will basically

00:57:19,560 --> 00:57:21,780
say, are you in that group, and return you as the only

00:57:21,780 --> 00:57:26,010
member, because usually all that you care about.

00:57:26,010 --> 00:57:30,520
So it's a bad design, it needs fixing.

00:57:30,520 --> 00:57:32,870
There are things like groups within groups.

00:57:32,870 --> 00:57:36,450
So Windows has this horrible hierarchy of local groups,

00:57:36,450 --> 00:57:39,390
domain groups, domain local groups, god, I can never

00:57:39,390 --> 00:57:40,230
remember them.

00:57:40,230 --> 00:57:42,760
I sit down, I read it up, and then it falls out of my head

00:57:42,760 --> 00:57:43,820
10 minutes later.

00:57:43,820 --> 00:57:46,610
But people use that stuff because it's very useful for

00:57:46,610 --> 00:57:49,040
delegating administration, to say, well I'm putting you in

00:57:49,040 --> 00:57:52,770
this group, that group of people can do this thing.

00:57:52,770 --> 00:57:58,200
So winbindd will actually unroll local groups.

00:57:58,200 --> 00:57:59,320
They always [UNINTELLIGIBLE] domain.

00:57:59,320 --> 00:58:02,260
Basically, if you have nested groups, winbindd can unroll

00:58:02,260 --> 00:58:04,600
those behind the covers so you still get the correct group

00:58:04,600 --> 00:58:05,720
memberships.

00:58:05,720 --> 00:58:08,430
So it's very instructive to watch a Windows client when

00:58:08,430 --> 00:58:11,680
you join it to an Active Directory domain and it first

00:58:11,680 --> 00:58:13,640
boots up and you say, I want to join this domain.

00:58:13,640 --> 00:58:18,270
So what you will see is no less than I believe the number

00:58:18,270 --> 00:58:23,590
is six different protocols being used in order to do that

00:58:23,590 --> 00:58:24,700
domain join.

00:58:24,700 --> 00:58:28,270
You will see DNS updates, you will see secure DNS updates,

00:58:28,270 --> 00:58:32,120
you will see connection-less LDAP, you will see LDAP, you

00:58:32,120 --> 00:58:37,310
will see CIFS, you will see DCE/RPC.

00:58:37,310 --> 00:58:40,900
And all of these are done in a specific order, and if any of

00:58:40,900 --> 00:58:45,075
those steps fail, the Windows client will fail and say, I

00:58:45,075 --> 00:58:45,960
can't join that domain.

00:58:45,960 --> 00:58:49,400
I'm sorry, this can't be a real domain, can it?

00:58:49,400 --> 00:58:52,270
Hey, my connection-less LDAP query failed.

00:58:52,270 --> 00:58:54,180
It doesn't matter if any of the other pieces

00:58:54,180 --> 00:58:56,590
worked, it will fail.

00:58:56,590 --> 00:59:00,240
So you can't implement this in pieces.

00:59:00,240 --> 00:59:01,810
Kerberos was another one, of course.

00:59:01,810 --> 00:59:04,550
You can't say, well I'll do the Kerberos piece, but the

00:59:04,550 --> 00:59:09,330
LDAP piece I'll leave, because it simply won't talk to you.

00:59:09,330 --> 00:59:12,340
It will do things like it will update information in LDAP and

00:59:12,340 --> 00:59:16,820
expect to see that information when it does a Kerberos query.

00:59:16,820 --> 00:59:20,365
Everything has to be connected together or it simply fails.

00:59:20,365 --> 00:59:23,230


00:59:23,230 --> 00:59:26,670
This is a list of protocols that has to share a common

00:59:26,670 --> 00:59:31,030
back end, and all of them have to work all in the same way.

00:59:31,030 --> 00:59:35,160
Essentially, this is what the EU case is about.

00:59:35,160 --> 00:59:37,700
If you're going to boil it down to its barest essentials,

00:59:37,700 --> 00:59:41,310
this is what the European Union case is about.

00:59:41,310 --> 00:59:43,620
Essentially, all of these pieces tied together and

00:59:43,620 --> 00:59:47,290
clients expecting them to work in a particular way.

00:59:47,290 --> 00:59:49,000
There's also server-to-server stuff, but this

00:59:49,000 --> 00:59:51,370
is the core of it.

00:59:51,370 --> 00:59:57,870
And of course, it not being documented, how it works.

00:59:57,870 --> 01:00:00,670
None of these protocols in and of themselves are new,

01:00:00,670 --> 01:00:02,740
interesting, and difficult.

01:00:02,740 --> 01:00:04,890
They're all well-known, standardized protocols, they

01:00:04,890 --> 01:00:06,940
just have weird little twists on them that means that they

01:00:06,940 --> 01:00:08,810
don't work in standard ways.

01:00:08,810 --> 01:00:10,930
Like the Kerberos packs, for instance.

01:00:10,930 --> 01:00:13,900


01:00:13,900 --> 01:00:16,530
So you have all these pieces out there in the

01:00:16,530 --> 01:00:17,080
free software world.

01:00:17,080 --> 01:00:19,720
Well, you've got OpenLDAP, you've got MIT and Heimdal

01:00:19,720 --> 01:00:24,160
Kerberos, you've got BIND, you've got Samba, you've got

01:00:24,160 --> 01:00:26,150
the DCE/RPC code.

01:00:26,150 --> 01:00:28,400
None of these things are integrated.

01:00:28,400 --> 01:00:31,250
They're all separate pieces, they're all a kit of parts,

01:00:31,250 --> 01:00:34,070
and it's extremely difficult to put them all together.

01:00:34,070 --> 01:00:38,560
I know one person who's done it and he sold his domain

01:00:38,560 --> 01:00:41,105
controller to Novell, and Novell is now selling that.

01:00:41,105 --> 01:00:44,150


01:00:44,150 --> 01:00:46,030
Samba4 is trying to solve this problem.

01:00:46,030 --> 01:00:52,420


01:00:52,420 --> 01:00:55,500
I understand why they're doing it, I'm not sure I agree.

01:00:55,500 --> 01:00:57,370
Essentially, they're re-implementing much of this

01:00:57,370 --> 01:00:57,840
from scratch.

01:00:57,840 --> 01:00:59,880
So they have their own LDAP server, they have their own

01:00:59,880 --> 01:01:02,180
DCE/RPC server, so essentially they're

01:01:02,180 --> 01:01:04,050
rewriting all this stuff.

01:01:04,050 --> 01:01:07,210
Now, one of the reasons for doing it that way is that you

01:01:07,210 --> 01:01:09,900
don't know what you don't know until you've tried to

01:01:09,900 --> 01:01:10,840
implement it.

01:01:10,840 --> 01:01:13,697
So if you take all these very large, complex projects and

01:01:13,697 --> 01:01:15,910
you try and integrate them together with bits of glue and

01:01:15,910 --> 01:01:19,195
string and the usual open source bit of chewing gum here

01:01:19,195 --> 01:01:22,360
and I'll link this thing together, then essentially

01:01:22,360 --> 01:01:25,000
you'll get random failures and you won't really know why.

01:01:25,000 --> 01:01:27,340
Is it the interconnection, is it the way they're talking to

01:01:27,340 --> 01:01:28,230
each other?

01:01:28,230 --> 01:01:31,830
So what essentially Samba4 is doing is to say, right, we're

01:01:31,830 --> 01:01:34,050
going to start with a clean base of nothing and we're

01:01:34,050 --> 01:01:35,580
going to build this up from scratch, and we're going to

01:01:35,580 --> 01:01:38,190
see what it is that we need.

01:01:38,190 --> 01:01:41,140
But it's a lot of work.

01:01:41,140 --> 01:01:47,310
So right now, Samba4, and it's been like this for a while,

01:01:47,310 --> 01:01:50,580
Samba4 can have Windows clients join to it and think

01:01:50,580 --> 01:01:53,420
it's a domain controller, but it doesn't do a lot of the

01:01:53,420 --> 01:01:54,700
things that you would expect.

01:01:54,700 --> 01:01:57,470
So it doesn't do member serving, it doesn't do a lot

01:01:57,470 --> 01:01:58,660
of the things that you need.

01:01:58,660 --> 01:02:03,690
So probably what I expect is that you will see people who

01:02:03,690 --> 01:02:06,580
really want to run a non-Microsoft Active Directory

01:02:06,580 --> 01:02:08,990
domain controller will probably end up running

01:02:08,990 --> 01:02:13,410
isolated Samba4 pieces with Samba3 member service attached

01:02:13,410 --> 01:02:16,450
to them to get the basic file and print and the bread and

01:02:16,450 --> 01:02:18,190
butter stuff working.

01:02:18,190 --> 01:02:20,770
So that's less of a big bang of having to change

01:02:20,770 --> 01:02:22,020
everything at once.

01:02:22,020 --> 01:02:24,850


01:02:24,850 --> 01:02:27,000
So here's a bit I'm going to skip over as rapidly as

01:02:27,000 --> 01:02:28,980
possible unless anyone asks.

01:02:28,980 --> 01:02:30,540
So Windows printing, yeah.

01:02:30,540 --> 01:02:32,210
Sucks, horrible.

01:02:32,210 --> 01:02:33,460
Three different methods of doing it.

01:02:33,460 --> 01:02:37,340


01:02:37,340 --> 01:02:40,740
So it's all built on top of DCE/RPC.

01:02:40,740 --> 01:02:42,050
Poor HP.

01:02:42,050 --> 01:02:46,250
I worked for HP for a few years and they originally

01:02:46,250 --> 01:02:50,230
hired us because someone had a nice sample implementation of

01:02:50,230 --> 01:02:51,630
how point and print would work.

01:02:51,630 --> 01:02:56,620
And of course, you have to realize with HP, it's all

01:02:56,620 --> 01:02:57,650
about printing.

01:02:57,650 --> 01:02:59,540
The more ink they sell--

01:02:59,540 --> 01:03:01,820
computers are a method of getting people to print more

01:03:01,820 --> 01:03:05,340
documents because the more ink you sell the

01:03:05,340 --> 01:03:06,010
more money they make.

01:03:06,010 --> 01:03:08,120
That stuff is gold.

01:03:08,120 --> 01:03:10,450
So printing is very important, so they hired as many Samba

01:03:10,450 --> 01:03:12,790
people as they could and said, finish this and we'll have a

01:03:12,790 --> 01:03:14,040
print appliance.

01:03:14,040 --> 01:03:15,760
And we did do that.

01:03:15,760 --> 01:03:18,990
Unfortunately, it took us like two years of effort because it

01:03:18,990 --> 01:03:22,710
turns out going from the sample implementation to an

01:03:22,710 --> 01:03:25,470
actual production-quality, working implementation was,

01:03:25,470 --> 01:03:28,880
let's just say, a little harder than expected.

01:03:28,880 --> 01:03:31,820
My guess is about 10 to 15 person years worth of effort

01:03:31,820 --> 01:03:34,780
going into this.

01:03:34,780 --> 01:03:36,900
It's also tied into the registry, as well.

01:03:36,900 --> 01:03:39,760
So the nice thing, at least on Unix these

01:03:39,760 --> 01:03:41,440
days, it CUPS as one.

01:03:41,440 --> 01:03:47,575
There's no more SCR LP mechanisms. Just make it talk

01:03:47,575 --> 01:03:51,340
to CUPS and you're kind of done.

01:03:51,340 --> 01:03:53,540
And the nice thing is Michael Sweet actually does the Samba

01:03:53,540 --> 01:03:58,080
code, he sends the Samba patches, the CUPS, himself.

01:03:58,080 --> 01:04:01,710
The only difficulty we have left are the server-side and

01:04:01,710 --> 01:04:02,610
client-side rendering.

01:04:02,610 --> 01:04:05,820
But I'm not as worried about that as I was.

01:04:05,820 --> 01:04:09,180
So it turns out that for Vista and Longhorn, there was going

01:04:09,180 --> 01:04:10,560
to be this big change.

01:04:10,560 --> 01:04:13,440
I don't know whether you realize that one of the

01:04:13,440 --> 01:04:18,380
reasons that Windows NT on architectures other than x86

01:04:18,380 --> 01:04:24,020
was a miserable failure at least of serving printing, is

01:04:24,020 --> 01:04:28,390
that when you serve a printer on Windows, when you install

01:04:28,390 --> 01:04:30,820
the driver, even when you're installing it on a remote

01:04:30,820 --> 01:04:34,940
server, it expects to be able to run that driver as binary

01:04:34,940 --> 01:04:37,230
code in many cases.

01:04:37,230 --> 01:04:39,260
Especially if you're going to do so server-side rendering.

01:04:39,260 --> 01:04:40,860
You have a choice.

01:04:40,860 --> 01:04:42,230
When you want to print something, you can either

01:04:42,230 --> 01:04:43,950
render it on the client where you've got lots and lots of

01:04:43,950 --> 01:04:47,490
CPU cycles, or you can send it as a metafile over to the

01:04:47,490 --> 01:04:49,930
server and have the server render it for you where you

01:04:49,930 --> 01:04:52,180
can do some sophisticated things like watermarking or

01:04:52,180 --> 01:04:54,700
whatever that you don't trust the client to do.

01:04:54,700 --> 01:04:57,540
But essentially, what it does is it sucks up all your CPU

01:04:57,540 --> 01:04:59,130
cycles on the server.

01:04:59,130 --> 01:05:01,440
And originally, they were pushing much more towards

01:05:01,440 --> 01:05:04,600
doing server-side rendering until, I think, it was

01:05:04,600 --> 01:05:05,660
benchmarked.

01:05:05,660 --> 01:05:09,210
At least the print-server appliance that we created for

01:05:09,210 --> 01:05:12,680
HP, we could have a couple hundred Windows boxes

01:05:12,680 --> 01:05:17,690
connected to this thing, everybody printing, and the

01:05:17,690 --> 01:05:20,240
hardware that we were using was so small that you couldn't

01:05:20,240 --> 01:05:21,960
even install windows on it.

01:05:21,960 --> 01:05:23,745
No version of Windows would install on the hardware we

01:05:23,745 --> 01:05:25,500
were using for that appliance.

01:05:25,500 --> 01:05:28,150
And so when you move to a Windows server to do that,

01:05:28,150 --> 01:05:32,390
they were supporting half as many users with having to have

01:05:32,390 --> 01:05:34,795
gigahertz processors whereas I think we were using a 500

01:05:34,795 --> 01:05:37,500
megahertz processor.

01:05:37,500 --> 01:05:41,730
So pushing more rendering onto the server is a very bad idea,

01:05:41,730 --> 01:05:43,820
and it also relies on-- you have to have

01:05:43,820 --> 01:05:46,400
x86 dll code running.

01:05:46,400 --> 01:05:49,630
So that mostly just works and we try and leave it alone as

01:05:49,630 --> 01:05:52,350
much as possible because it's so ugly, but the funny thing

01:05:52,350 --> 01:05:54,960
is I think Microsoft do the same.

01:05:54,960 --> 01:05:57,070
I really do, because I don't think they like

01:05:57,070 --> 01:06:00,240
that code much either.

01:06:00,240 --> 01:06:03,130
Oh yeah, so we have the fourth wobbly leg that sticks out of

01:06:03,130 --> 01:06:06,860
the other legs, which is the OPC Transport.

01:06:06,860 --> 01:06:08,420
So the secret of Windows.

01:06:08,420 --> 01:06:12,020
How many people here have done RPC programming?

01:06:12,020 --> 01:06:13,500
Some, OK.

01:06:13,500 --> 01:06:18,480
So I cut my teeth originally on ONC/RPC, which is the Sun

01:06:18,480 --> 01:06:22,610
RPC, which is the thing that NFS uses, and it's sane and

01:06:22,610 --> 01:06:26,180
it's easy and you can download the libraries.

01:06:26,180 --> 01:06:29,760
I once spent a miserable summer in England when my mum

01:06:29,760 --> 01:06:32,900
was ill multithreading the ONC/RPC libraries because they

01:06:32,900 --> 01:06:36,230
were all BSD licensed source code and putting compression

01:06:36,230 --> 01:06:38,860
in and stuff like that.

01:06:38,860 --> 01:06:40,500
And that was really easy to do.

01:06:40,500 --> 01:06:43,550
Then you look at the hideous, stinking nightmare that is

01:06:43,550 --> 01:06:48,280
DCE/RPC and you think, oh no, the wrong thing won.

01:06:48,280 --> 01:06:50,950
The problem is, of course, most RPC in the world is now

01:06:50,950 --> 01:06:54,160
Windows RPC, DCE/RPC.

01:06:54,160 --> 01:06:55,690
But it really is disgusting.

01:06:55,690 --> 01:06:57,760
For instance, it has the concept of receiver makes

01:06:57,760 --> 01:07:02,210
right, where rather than standardizing on a standard

01:07:02,210 --> 01:07:05,040
byte order on the network, you can actually send it in

01:07:05,040 --> 01:07:06,070
arbitrary byte order.

01:07:06,070 --> 01:07:08,545
And you set a flag in the header that says, oh, you're

01:07:08,545 --> 01:07:10,920
the receiver, you sort it out.

01:07:10,920 --> 01:07:13,630
And this was basically done because Intel objected to

01:07:13,630 --> 01:07:15,850
using network byte order, which was big-endian.

01:07:15,850 --> 01:07:19,750


01:07:19,750 --> 01:07:22,320
And yet the 68,000 people wanted to use big-endian and

01:07:22,320 --> 01:07:24,040
the Intel people wanted to use little-endian.

01:07:24,040 --> 01:07:26,230
So they couldn't decide, so the big standards committee

01:07:26,230 --> 01:07:30,570
said well, we'll have both and then set a flag.

01:07:30,570 --> 01:07:33,670
It's just horrible, it's really, really disgusting.

01:07:33,670 --> 01:07:37,550
At least mainly in Windows, it's tunneled over SMB.

01:07:37,550 --> 01:07:40,720
So actual OPC transport is done by opening a special

01:07:40,720 --> 01:07:42,880
share called the IPC$ share.

01:07:42,880 --> 01:07:46,630
In fact, all named pipes programming in Windows is done

01:07:46,630 --> 01:07:47,410
using this.

01:07:47,410 --> 01:07:51,000
So if you look at what's called a named pipe, it's

01:07:51,000 --> 01:07:54,380
opened on the IPC$ share, and a lot of it is actually done

01:07:54,380 --> 01:07:56,880
over DCE/RPC.

01:07:56,880 --> 01:07:59,760
It's horribly complex, horribly over-designed, it had

01:07:59,760 --> 01:08:02,380
its own threading model built in.

01:08:02,380 --> 01:08:04,630
It's a disgusting, hideous mess, but we have

01:08:04,630 --> 01:08:05,590
to live with it.

01:08:05,590 --> 01:08:07,980
And at least in Samba4, we have a very nice, clean

01:08:07,980 --> 01:08:08,880
implementation of it.

01:08:08,880 --> 01:08:11,660
It's actually better in many ways than the one that's in

01:08:11,660 --> 01:08:15,840
Microsoft because RPC is defined by what's called an

01:08:15,840 --> 01:08:19,040
Interface Definition Language, IDL, which is a description of

01:08:19,040 --> 01:08:20,479
what the packets look like.

01:08:20,479 --> 01:08:24,430
Now it turns out that in the original IDL compilers and

01:08:24,430 --> 01:08:27,770
also the ones that Microsoft use, you can't describe the

01:08:27,770 --> 01:08:31,200
RPC itself in terms of IDL because their

01:08:31,200 --> 01:08:32,779
IDL compiler is broken.

01:08:32,779 --> 01:08:36,840
So at least for the Samba4 IDL compiler, we made some

01:08:36,840 --> 01:08:39,729
extensions and so now the whole thing itself, including

01:08:39,729 --> 01:08:41,545
the protocol, is defined in IDL, which

01:08:41,545 --> 01:08:43,729
is much, much cleaner.

01:08:43,729 --> 01:08:47,080
So Samba3 right now only supports CIFS tunnel

01:08:47,080 --> 01:08:48,784
transport of CIFS.

01:08:48,784 --> 01:08:51,500


01:08:51,500 --> 01:08:54,229
There's a role port 135--

01:08:54,229 --> 01:08:56,700
if anyone is familiar with ONC/RPC, there's a thing

01:08:56,700 --> 01:09:00,380
called a port mapper where services register a TCP or UDP

01:09:00,380 --> 01:09:04,909
port there and clients ask the port mapper, what port

01:09:04,909 --> 01:09:05,649
shall I talk to?

01:09:05,649 --> 01:09:06,620
And then they talk to it.

01:09:06,620 --> 01:09:11,200
The same thing happened as an endpoint mapper in DCE lives

01:09:11,200 --> 01:09:14,520
on port 135.

01:09:14,520 --> 01:09:17,609
Remember, that's one where many years ago, if you

01:09:17,609 --> 01:09:19,370
telnetted to it and hit return, it would

01:09:19,370 --> 01:09:22,580
spin, eating 100% CPU.

01:09:22,580 --> 01:09:26,390
There's a bug in that parser.

01:09:26,390 --> 01:09:29,970
So we have horrible handwritten marshalling code.

01:09:29,970 --> 01:09:34,770
We are finally transitioning over to auto-generated code,

01:09:34,770 --> 01:09:38,189
something called PIDL, Perl IDL compiler, our IDL compiler

01:09:38,189 --> 01:09:39,370
is written in Perl.

01:09:39,370 --> 01:09:43,149
So we're finally turning into auto-generated code and this

01:09:43,149 --> 01:09:46,430
is really nice because with our hand-generated code, every

01:09:46,430 --> 01:09:49,340
single field you parse you have to do a security check.

01:09:49,340 --> 01:09:50,700
Have I run off the end of the buffer?

01:09:50,700 --> 01:09:52,149
Have I run off the end of the buffer?

01:09:52,149 --> 01:09:53,550
We have to check everywhere.

01:09:53,550 --> 01:09:55,600
And this will essentially all go away because it will be

01:09:55,600 --> 01:09:56,340
auto-generated.

01:09:56,340 --> 01:09:58,920
In my life, it will be a lot easier when we do that.

01:09:58,920 --> 01:10:00,200
So that's slowly being done.

01:10:00,200 --> 01:10:08,620


01:10:08,620 --> 01:10:10,760
So here are some of the things that you can do with RPC.

01:10:10,760 --> 01:10:11,520
Oh, question.

01:10:11,520 --> 01:10:12,770
AUDIENCE: [INAUDIBLE].

01:10:12,770 --> 01:10:24,966


01:10:24,966 --> 01:10:27,980
JEREMY ALLISON: So the comment was, wasn't that the same smug

01:10:27,980 --> 01:10:33,410
comment that the ASN.1 people made about ASN.1, until

01:10:33,410 --> 01:10:35,310
somebody found a bug in their compiler.

01:10:35,310 --> 01:10:39,495
Well, yes it is, but you see, the difference is ASN.1 is

01:10:39,495 --> 01:10:46,840
unreadable shit and is, in fact, a write-only language.

01:10:46,840 --> 01:10:48,635
And it is also an unparsable language.

01:10:48,635 --> 01:10:51,900


01:10:51,900 --> 01:10:56,770
I remember doing some SNMP work a long, long time ago and

01:10:56,770 --> 01:11:00,430
to actually get people's MIBs to compile, I had to use a

01:11:00,430 --> 01:11:02,910
combination of three different compilers from three different

01:11:02,910 --> 01:11:08,270
sources because it's complete crap and it's possibly the

01:11:08,270 --> 01:11:10,950
worst protocol description.

01:11:10,950 --> 01:11:12,280
Yeah.

01:11:12,280 --> 01:11:15,120
The nice thing about Samba is we just looked at this mess

01:11:15,120 --> 01:11:16,760
and said, screw you.

01:11:16,760 --> 01:11:22,340
We're still using our hand-generated BER encoding

01:11:22,340 --> 01:11:24,900
and decoding, because we can trust that.

01:11:24,900 --> 01:11:26,970
Because you can't trust any of the shit that comes out of

01:11:26,970 --> 01:11:29,790
those compilers because, as you pointed out, they're all

01:11:29,790 --> 01:11:31,040
horribly buggy.

01:11:31,040 --> 01:11:33,980


01:11:33,980 --> 01:11:37,910
Our auto-generated code is small enough that you can

01:11:37,910 --> 01:11:41,770
actually understand what it's doing and it's not a horribly

01:11:41,770 --> 01:11:42,570
buggy piece of shit.

01:11:42,570 --> 01:11:45,600
Well, at least, we don't think so.

01:11:45,600 --> 01:11:48,440
Obviously, time will tell and if you see another Samba

01:11:48,440 --> 01:11:52,840
security hole based on the odd PIDL compiler, but we have

01:11:52,840 --> 01:11:55,215
built into it things like integer wrap already.

01:11:55,215 --> 01:11:58,390


01:11:58,390 --> 01:12:00,900
Allocation problems when you're adding this field and

01:12:00,900 --> 01:12:04,730
this field, we have all that stuff tested.

01:12:04,730 --> 01:12:06,390
We don't think we have any bugs.

01:12:06,390 --> 01:12:07,590
But hey.

01:12:07,590 --> 01:12:09,060
I'm sure we're going to have bugs, but we don't think we

01:12:09,060 --> 01:12:12,050
have any massive, horrible, buffer overrun security-type

01:12:12,050 --> 01:12:14,880
bugs that the ASN.1 people are infested with.

01:12:14,880 --> 01:12:17,700
Anyway, moving on.

01:12:17,700 --> 01:12:19,290
Not that I have any bad feelings

01:12:19,290 --> 01:12:22,240
about ASN.1 or something.

01:12:22,240 --> 01:12:25,600
An ASN.1 compiler whipped me with cables repeatedly.

01:12:25,600 --> 01:12:28,240


01:12:28,240 --> 01:12:31,510
I'm not a big fan of ASN.1.

01:12:31,510 --> 01:12:33,110
Why don't people just use XDR?

01:12:33,110 --> 01:12:35,100
It's simple, it's clean, it's very understandable.

01:12:35,100 --> 01:12:37,760


01:12:37,760 --> 01:12:39,710
AUDIENCE: [INAUDIBLE].

01:12:39,710 --> 01:12:42,120
JEREMY ALLISON: Yeah, that was integer wrap.

01:12:42,120 --> 01:12:45,470
It had early integer wrap implementation holds, Yes.

01:12:45,470 --> 01:12:47,500
But they're all fixed now.

01:12:47,500 --> 01:12:50,160


01:12:50,160 --> 01:12:52,770
Anyway, so these are the kinds of things that you can do once

01:12:52,770 --> 01:12:54,780
you have DCE/RPC running in Samba.

01:12:54,780 --> 01:12:57,560
Look, it's the registry.

01:12:57,560 --> 01:12:59,116
But look closely.

01:12:59,116 --> 01:13:02,080


01:13:02,080 --> 01:13:07,650
We have Samba and services like cron, CUPS, port map,

01:13:07,650 --> 01:13:11,810
Postfix, xinetd.

01:13:11,810 --> 01:13:13,415
This is looking at a Unix box.

01:13:13,415 --> 01:13:19,900


01:13:19,900 --> 01:13:21,770
One of the things that we're thinking of doing is actually

01:13:21,770 --> 01:13:25,080
exporting all Samba configuration as a registry,

01:13:25,080 --> 01:13:29,550
because Windows users are really used to editing stuff.

01:13:29,550 --> 01:13:32,370
As you may or may not know, Samba is crippled with

01:13:32,370 --> 01:13:33,520
feature-itis.

01:13:33,520 --> 01:13:35,860
We have options up the wazoo.

01:13:35,860 --> 01:13:38,370
So we're thinking of just essentially removing all of

01:13:38,370 --> 01:13:39,180
those from SMB [UNINTELLIGIBLE]

01:13:39,180 --> 01:13:41,305
and saying, if you want to set this, do it via the registry.

01:13:41,305 --> 01:13:44,070


01:13:44,070 --> 01:13:45,470
It's a plan, it might work.

01:13:45,470 --> 01:13:48,860


01:13:48,860 --> 01:13:52,310
This is from the guy, who actually I mentioned

01:13:52,310 --> 01:13:56,110
previously, who wrote the Windows printing subsystem

01:13:56,110 --> 01:13:57,970
who's now working on an open source

01:13:57,970 --> 01:13:59,300
startup called Centeris.

01:13:59,300 --> 01:14:02,750
And this is actually some of their code.

01:14:02,750 --> 01:14:04,770
This is all now in inside of Samba.

01:14:04,770 --> 01:14:06,960
And they did something that I thought would never be

01:14:06,960 --> 01:14:11,230
possible, or at least I thought was insane, which is

01:14:11,230 --> 01:14:13,360
this is the Windows Performance Monitor, and what

01:14:13,360 --> 01:14:16,930
it's showing is the CPU usage on a Linux box with two

01:14:16,930 --> 01:14:19,930
processes compiling Samba.

01:14:19,930 --> 01:14:25,930
And what it does is it uses Samba registry RPCs that then

01:14:25,930 --> 01:14:29,750
fish, via some scripts, into /proc to export the

01:14:29,750 --> 01:14:30,640
information.

01:14:30,640 --> 01:14:33,020
I just think this is so cool.

01:14:33,020 --> 01:14:36,260
I remember, I always liked the Windows Performance Monitor

01:14:36,260 --> 01:14:39,460
and I remember trying to work out how it worked, and I

01:14:39,460 --> 01:14:42,610
realized it went into registry hell and just left it alone.

01:14:42,610 --> 01:14:44,900
And so he's now fixed that.

01:14:44,900 --> 01:14:47,130
And then the other really cool thing if you can see here--

01:14:47,130 --> 01:14:49,860


01:14:49,860 --> 01:14:52,300
again, this is Centeris code--

01:14:52,300 --> 01:14:56,910
this is the service control manager starting Postfix, as

01:14:56,910 --> 01:14:59,230
you may have noticed.

01:14:59,230 --> 01:15:05,890
And again, you have NTPD, CUPS, port mapper, and

01:15:05,890 --> 01:15:08,420
essentially if you really want, you can have your

01:15:08,420 --> 01:15:11,800
Windows admins administer your Unix systems. I don't know

01:15:11,800 --> 01:15:14,900
whether you would want to, but you could do that.

01:15:14,900 --> 01:15:19,000
It would just require a bunch of scripts, but it's perfectly

01:15:19,000 --> 01:15:21,410
feasible to allow Windows admins to do this.

01:15:21,410 --> 01:15:22,030
Yes, question.

01:15:22,030 --> 01:15:23,340
AUDIENCE: [INAUDIBLE]

01:15:23,340 --> 01:15:26,770
editor for Linux that removed everything out of the Samba

01:15:26,770 --> 01:15:32,650
interface into registry settings that would allow

01:15:32,650 --> 01:15:35,263
somebody who's running a Samba server who doesn't have any

01:15:35,263 --> 01:15:38,040
Windows clients of his own to administer their Samba box?

01:15:38,040 --> 01:15:40,790
JEREMY ALLISON: So the question is, yeah, this works

01:15:40,790 --> 01:15:43,250
great for Windows but what if you're in a pure Unix

01:15:43,250 --> 01:15:45,100
environment and you put stuff in the registry.

01:15:45,100 --> 01:15:46,010
How do you edit it?

01:15:46,010 --> 01:15:49,920
Fire a command line tool like God intended, damn it.

01:15:49,920 --> 01:15:50,940
RPC clients.

01:15:50,940 --> 01:15:53,150
You can diddle anything with RPC client.

01:15:53,150 --> 01:15:56,310
Yes, it's primitive and ugly and probably not really

01:15:56,310 --> 01:15:58,730
supportable going forward.

01:15:58,730 --> 01:16:01,500
What I'm actually hoping will happen is that the GNOME

01:16:01,500 --> 01:16:04,980
people, now that they've got access to our RPC libraries,

01:16:04,980 --> 01:16:08,780
will actually build a registry editor on Linux that looks

01:16:08,780 --> 01:16:12,350
like the Windows one that you can use to edit remote Windows

01:16:12,350 --> 01:16:15,560
registries or local Unix ones.

01:16:15,560 --> 01:16:16,140
Yeah, question.

01:16:16,140 --> 01:16:17,390
AUDIENCE: [INAUDIBLE].

01:16:17,390 --> 01:16:24,852


01:16:24,852 --> 01:16:26,420
JEREMY ALLISON: So the question is, have we ever

01:16:26,420 --> 01:16:27,940
thought of exporting something like that

01:16:27,940 --> 01:16:29,700
over the file system?

01:16:29,700 --> 01:16:33,720
I actually did think about that at one point, but it's

01:16:33,720 --> 01:16:36,410
far too much work for me to sit down and do everything.

01:16:36,410 --> 01:16:38,790
So the nice thing about Samba is we have a very

01:16:38,790 --> 01:16:41,420
well-documented VFS interface.

01:16:41,420 --> 01:16:45,120
So if you wanted to, you could create a share called

01:16:45,120 --> 01:16:49,530
configuration with a custom VFS back end that essentially

01:16:49,530 --> 01:16:52,550
exported whatever configuration you wanted.

01:16:52,550 --> 01:16:56,840


01:16:56,840 --> 01:16:59,140
There's an open source project and I can't remember the name

01:16:59,140 --> 01:17:00,570
of it, but it actually moves everything

01:17:00,570 --> 01:17:04,070
in /etc into a registry.

01:17:04,070 --> 01:17:04,460
Does anyone remember the name?

01:17:04,460 --> 01:17:05,280
AUDIENCE: Elektra.

01:17:05,280 --> 01:17:06,880
JEREMY ALLISON: Elektra, yeah.

01:17:06,880 --> 01:17:10,040
You could essentially write a VFS layer for Samba that would

01:17:10,040 --> 01:17:12,125
expose Elektra as a filesystem if you really

01:17:12,125 --> 01:17:13,200
wanted to do that.

01:17:13,200 --> 01:17:14,980
So yeah, we can do all sorts of really

01:17:14,980 --> 01:17:17,630
cool and weird things.

01:17:17,630 --> 01:17:18,790
It's just somebody has to write the

01:17:18,790 --> 01:17:20,040
code, that's the problem.

01:17:20,040 --> 01:17:22,750


01:17:22,750 --> 01:17:24,720
OK.

01:17:24,720 --> 01:17:28,590
Samba3 and Samba4 or, as I like to describe it, flying

01:17:28,590 --> 01:17:31,990
along in an airplane trying to build another airplane while

01:17:31,990 --> 01:17:34,290
flying and using the same parts between the two.

01:17:34,290 --> 01:17:36,820


01:17:36,820 --> 01:17:43,670
This is a big fiddly, but it's coming along.

01:17:43,670 --> 01:17:47,140
So the way I like to describe Samba4 is essentially it's our

01:17:47,140 --> 01:17:48,270
research arm.

01:17:48,270 --> 01:17:51,470
It's Samba Research.

01:17:51,470 --> 01:17:54,250
So essentially, Tridge got fed up with Samba3 code because it

01:17:54,250 --> 01:17:57,210
it's ugly and horrible and all the rest of the things that a

01:17:57,210 --> 01:17:59,450
project that's been going for 15 years is.

01:17:59,450 --> 01:18:00,675
So he said, screw this, I'm going to

01:18:00,675 --> 01:18:01,570
write something better.

01:18:01,570 --> 01:18:05,560
And he started by rewriting the VFS interface, and it just

01:18:05,560 --> 01:18:07,160
kind of grew from there.

01:18:07,160 --> 01:18:12,060
He designed it more as an NTFS-style VFS.

01:18:12,060 --> 01:18:15,240
Essentially, this is an engine for spinoff technologies.

01:18:15,240 --> 01:18:17,240
So we get the PIDL IDL compiler which

01:18:17,240 --> 01:18:19,640
works, unlike the ASN.1.

01:18:19,640 --> 01:18:23,340
We get talloc, which we use for just about everything.

01:18:23,340 --> 01:18:25,110
I believe there's something similar in Apache,

01:18:25,110 --> 01:18:26,750
but talloc is cooler.

01:18:26,750 --> 01:18:30,420
It has a better name.

01:18:30,420 --> 01:18:33,590
Although, Tridge and I have argued greatly about this

01:18:33,590 --> 01:18:40,200
because essentially, talloc to me is C++ without objects and

01:18:40,200 --> 01:18:45,330
it really bugs me because I'd much rather do this in C++.

01:18:45,330 --> 01:18:51,700
Essentially, it's resource de-allocation as a

01:18:51,700 --> 01:18:52,630
memory-free.

01:18:52,630 --> 01:18:55,610
So essentially what you do with talloc is because you can

01:18:55,610 --> 01:18:58,990
plug in free functions anywhere inside a talloc

01:18:58,990 --> 01:19:04,770
hierarchy, you malloc stuff, a resource, and you register a

01:19:04,770 --> 01:19:07,240
free function with it that will do things like close file

01:19:07,240 --> 01:19:08,070
descriptors.

01:19:08,070 --> 01:19:12,770
So to tear down an entire connection, all you do is you

01:19:12,770 --> 01:19:14,570
essentially say, talloc, destroy

01:19:14,570 --> 01:19:16,030
the top-level hierarchy.

01:19:16,030 --> 01:19:18,380
And it'll run down everything and it'll free memory, close

01:19:18,380 --> 01:19:20,255
file descriptors, release locks, whatever.

01:19:20,255 --> 01:19:23,300


01:19:23,300 --> 01:19:27,420
It's kind of like auto_ptrs without C++.

01:19:27,420 --> 01:19:32,550
It irritates me, but I do see the use of it, and we use it a

01:19:32,550 --> 01:19:33,190
great deal.

01:19:33,190 --> 01:19:34,930
Transactional TDB.

01:19:34,930 --> 01:19:37,160
TDB is our internal database that we use for just about

01:19:37,160 --> 01:19:38,330
everything.

01:19:38,330 --> 01:19:41,530
It's a very fast shared memory, very efficient, and

01:19:41,530 --> 01:19:46,050
Tridge added transactional TDB into it, and this is the key

01:19:46,050 --> 01:19:49,050
to doing the cluster work.

01:19:49,050 --> 01:19:53,310
Essentially, he's added InfiniBand and GIGI back ends,

01:19:53,310 --> 01:19:56,435
and he's kept the same TDB interface, which means that

01:19:56,435 --> 01:20:00,000
all the very, very carefully written code over the years

01:20:00,000 --> 01:20:04,650
that does the share mode stuff doesn't have to change.

01:20:04,650 --> 01:20:09,240
And when you do TDB allocation, it will talk to a

01:20:09,240 --> 01:20:11,100
cluster server.

01:20:11,100 --> 01:20:15,160
And admittedly, this is not scalability on the scale of a

01:20:15,160 --> 01:20:17,240
massive grid of machines.

01:20:17,240 --> 01:20:20,360
We're talking about scalability, let's say,

01:20:20,360 --> 01:20:24,410
between 5 to 10 to 20 maximum type machines.

01:20:24,410 --> 01:20:27,430
But if you think about what most people use file service

01:20:27,430 --> 01:20:30,450
for, the real sweet spot, just like with multi-processor

01:20:30,450 --> 01:20:33,330
machines, the real sweet spot is like four

01:20:33,330 --> 01:20:35,130
nodes on a file server.

01:20:35,130 --> 01:20:37,920
But the goal is to make it clustered out much, much

01:20:37,920 --> 01:20:41,790
higher with a shared filesystem back end like IBM's

01:20:41,790 --> 01:20:44,090
GPFS, for instance.

01:20:44,090 --> 01:20:45,880
And they're actually having great success

01:20:45,880 --> 01:20:48,650
with that as a product.

01:20:48,650 --> 01:20:55,060
LDB is essentially the core of the Samba4 LDAP database

01:20:55,060 --> 01:20:58,210
engine, with LDAP style search and indexes.

01:20:58,210 --> 01:21:02,230
So it's built on top of TDB, but it has LDAP-like syntax

01:21:02,230 --> 01:21:04,440
and attributes and queries.

01:21:04,440 --> 01:21:09,540
And then the new thing that we're moving back is kevent,

01:21:09,540 --> 01:21:12,610
which essentially abstracts all the stuff that I hate

01:21:12,610 --> 01:21:16,830
about the BSD kevents and the epoll or the poll, and it

01:21:16,830 --> 01:21:20,330
basically selects the best version.

01:21:20,330 --> 01:21:22,090
Yes, I know about libevent.

01:21:22,090 --> 01:21:23,010
Sorry, was that a question?

01:21:23,010 --> 01:21:24,680
AUDIENCE: Why didn't he use it?

01:21:24,680 --> 01:21:25,770
JEREMY ALLISON: Why didn't he use libevent?

01:21:25,770 --> 01:21:28,830
Yes,I called him up and said, why aren't you using libevent?

01:21:28,830 --> 01:21:30,210
Libevent doesn't do signals and it doesn't

01:21:30,210 --> 01:21:31,700
do real-time signals.

01:21:31,700 --> 01:21:35,670
So my comment was, couldn't we just fix libevent because it's

01:21:35,670 --> 01:21:37,290
out there and it already works?

01:21:37,290 --> 01:21:40,180
But Tridge really wanted something that meshed much

01:21:40,180 --> 01:21:41,760
better with talloc.

01:21:41,760 --> 01:21:45,130
And so again, the nice thing about using talloc in

01:21:45,130 --> 01:21:48,650
combination with eventlib is that when you want to tear

01:21:48,650 --> 01:21:51,450
something down, you free the top-level talloc hierarchy and

01:21:51,450 --> 01:21:54,040
bang, all your events go away.

01:21:54,040 --> 01:21:55,980
You get no dangling events, et cetera.

01:21:55,980 --> 01:21:57,844
AUDIENCE: Can you schedule to change the name?

01:21:57,844 --> 01:22:00,310
JEREMY ALLISON: Can you use schemes to change the name?

01:22:00,310 --> 01:22:01,840
You'll have to write to him about that.

01:22:01,840 --> 01:22:03,090
Probably not.

01:22:03,090 --> 01:22:05,920


01:22:05,920 --> 01:22:09,550
What's happening is these things are being written, put

01:22:09,550 --> 01:22:13,030
into Samba4 and then essentially, Samba3 is more

01:22:13,030 --> 01:22:14,200
like the main production code.

01:22:14,200 --> 01:22:17,450
Or as I like to commonly say it from where I came from,

01:22:17,450 --> 01:22:20,830
after the lord mayor's parade comes the muck cart to clean

01:22:20,830 --> 01:22:22,610
up the horses, you see.

01:22:22,610 --> 01:22:25,960
So we sort of shovel the stuff into our cart.

01:22:25,960 --> 01:22:29,790
So the beautiful technologies appear in Samba4 and we run

01:22:29,790 --> 01:22:32,220
up, like thieves in the night, and say, we could use that,

01:22:32,220 --> 01:22:35,060
and back port it into the production on Samba3.

01:22:35,060 --> 01:22:40,600
So my guess is that once we do a full NT Active Directory

01:22:40,600 --> 01:22:44,590
domain controller, whatever we ship will be called Samba4.

01:22:44,590 --> 01:22:47,030
I have no clue what that code base will look like.

01:22:47,030 --> 01:22:49,320
It will probably be some hybrid of the two, I'm

01:22:49,320 --> 01:22:54,230
guessing, because essentially as things work, we bring them

01:22:54,230 --> 01:22:57,890
back and we put them into production and push them out

01:22:57,890 --> 01:22:59,140
as rapidly as we can.

01:22:59,140 --> 01:23:02,270


01:23:02,270 --> 01:23:03,315
Is it a fork?

01:23:03,315 --> 01:23:05,430
Yes, it is.

01:23:05,430 --> 01:23:08,300
But actually, we've had some problems with this and some

01:23:08,300 --> 01:23:10,900
tensions in the team for a while, but it's actually a

01:23:10,900 --> 01:23:11,930
fairly beneficial one.

01:23:11,930 --> 01:23:15,250
We've learned to live with it.

01:23:15,250 --> 01:23:18,410
And as I said, the technologies that are created

01:23:18,410 --> 01:23:23,750
there get moved back, put into the stable series.

01:23:23,750 --> 01:23:27,390
So we don't know exactly what the future is going to look

01:23:27,390 --> 01:23:30,300
like, but we know it's going to be heavily dependent on

01:23:30,300 --> 01:23:32,030
Samba4 technologies.

01:23:32,030 --> 01:23:35,930
So things that we don't know yet.

01:23:35,930 --> 01:23:37,980
Should be merge with OpenLDAP?

01:23:37,980 --> 01:23:41,060
So I'm going to be in Germany next month for the Samba XP

01:23:41,060 --> 01:23:42,220
conference.

01:23:42,220 --> 01:23:44,780
You're welcome if you're there.

01:23:44,780 --> 01:23:47,180
And some of the OpenLDAP people are going to turn up

01:23:47,180 --> 01:23:50,630
and maybe we can talk about how much code we can share.

01:23:50,630 --> 01:23:54,570
Right now, we're using Heimdal The problem with Heimdal is

01:23:54,570 --> 01:23:57,290
not that the code isn't good, the code is fantastic.

01:23:57,290 --> 01:23:59,660
The problem is it's lost the mind share war.

01:23:59,660 --> 01:24:01,860
This is my problem with Hindle.

01:24:01,860 --> 01:24:04,210
Everybody ships MIT.

01:24:04,210 --> 01:24:07,250
SUSE used to the last holdout that shipped Heimdal, but I

01:24:07,250 --> 01:24:10,200
think they caught up with using MIT so that everybody

01:24:10,200 --> 01:24:12,030
uses MIT Kerberos now.

01:24:12,030 --> 01:24:16,860
So basing a solution on Heimdal isn't great for going

01:24:16,860 --> 01:24:19,015
to companies and saying, we have a wonderful

01:24:19,015 --> 01:24:20,260
new Kerberos solution.

01:24:20,260 --> 01:24:22,990
It's a completely different code base from anything else

01:24:22,990 --> 01:24:26,170
you've ever run and are happy with, security-wise.

01:24:26,170 --> 01:24:30,650
So that's my issue with that.

01:24:30,650 --> 01:24:34,460
The Heimdal code great, it's just that the MIT one is

01:24:34,460 --> 01:24:37,670
trusted by more people.

01:24:37,670 --> 01:24:40,825
We've got to do the DNS/DHCP, all the things that IT of IT

01:24:40,825 --> 01:24:41,500
Director does.

01:24:41,500 --> 01:24:44,460
And this is just my personal opinion that we can't do this

01:24:44,460 --> 01:24:46,200
on our own, we simply can't do this on our own.

01:24:46,200 --> 01:24:48,240
We have to delegate.

01:24:48,240 --> 01:24:51,370
We can build the glue that binds all the stuff together,

01:24:51,370 --> 01:24:53,830
but we can't build all this stuff on our own.

01:24:53,830 --> 01:24:55,650
There's just not enough of us.

01:24:55,650 --> 01:24:57,520
It's too hard a job.

01:24:57,520 --> 01:25:00,830
So as I said, whenever we ship working in Active Directory

01:25:00,830 --> 01:25:02,250
domain controller, we're going to call it

01:25:02,250 --> 01:25:03,760
Samba4, whatever it is.

01:25:03,760 --> 01:25:08,220


01:25:08,220 --> 01:25:10,630
Things that we face going forward.

01:25:10,630 --> 01:25:12,860
Windows integration isn't static.

01:25:12,860 --> 01:25:15,800
So Vista, as you may notice, changes a bunch of things.

01:25:15,800 --> 01:25:18,380


01:25:18,380 --> 01:25:23,580
We have a little patch set for our OEMs, that basically

01:25:23,580 --> 01:25:27,510
they're at eight patches that you can layer on top of Samba

01:25:27,510 --> 01:25:31,590
3024 to fix some of the issues that Vista threw up.

01:25:31,590 --> 01:25:34,670
It's funny because the release candidate didn't have the

01:25:34,670 --> 01:25:35,850
problems we were working.

01:25:35,850 --> 01:25:37,640
We thought we were working pretty well with it and then

01:25:37,640 --> 01:25:39,800
when the final release came out, we had some surprises.

01:25:39,800 --> 01:25:44,600


01:25:44,600 --> 01:25:45,850
SMB2.

01:25:45,850 --> 01:25:48,022


01:25:48,022 --> 01:25:50,150
Oh, it's the replacement for SMB.

01:25:50,150 --> 01:25:53,310
It's wonderful, it's new, it's sliced bread, it's really

01:25:53,310 --> 01:25:56,480
fast. It's built for the internet.

01:25:56,480 --> 01:25:59,240
So Tridge spent about six months, actually, diverting

01:25:59,240 --> 01:26:03,720
him from Samba4 for a while, because of course this was

01:26:03,720 --> 01:26:05,390
completely new, completely undocumented.

01:26:05,390 --> 01:26:08,200
What happens is you negotiate a protocol that's

01:26:08,200 --> 01:26:10,660
standard with SMB.

01:26:10,660 --> 01:26:14,410
And if the service says, I talk SMB2, what happens is the

01:26:14,410 --> 01:26:17,100
packet format completely changes.

01:26:17,100 --> 01:26:18,860
In fact, even the header changes.

01:26:18,860 --> 01:26:20,700
And at that point, you're talking a new protocol.

01:26:20,700 --> 01:26:22,720
So Tridge said, it can't be this hard.

01:26:22,720 --> 01:26:25,740
So essentially he did the same thing he did with Samba.

01:26:25,740 --> 01:26:29,340
So there's an implementation of SMB2.

01:26:29,340 --> 01:26:31,340
Right now there's no real service for it

01:26:31,340 --> 01:26:33,000
until Longhorn ships.

01:26:33,000 --> 01:26:34,930
And it does some nice things.

01:26:34,930 --> 01:26:38,280
It widens out a bunch a fields that were 16-bit in SMB and

01:26:38,280 --> 01:26:42,420
makes them 32-bit.

01:26:42,420 --> 01:26:46,380
It promises some things that we haven't yet seen, like

01:26:46,380 --> 01:26:47,390
transactional support.

01:26:47,390 --> 01:26:49,000
We don't know how that's supposed to be done.

01:26:49,000 --> 01:26:52,190
We've never seen it on the wire.

01:26:52,190 --> 01:26:55,170
It has some early implementation bugs.

01:26:55,170 --> 01:27:00,130
So for instance, Steve tried doing some implementations of

01:27:00,130 --> 01:27:03,220
SMB2 in the Linux kernel and managed to crash Vista as a

01:27:03,220 --> 01:27:04,640
server-- which you should never be

01:27:04,640 --> 01:27:06,600
able to do, of course--

01:27:06,600 --> 01:27:07,850
running SMB2.

01:27:07,850 --> 01:27:09,830


01:27:09,830 --> 01:27:11,860
I think Tridge reported this, I'm not sure whether it got

01:27:11,860 --> 01:27:14,890
fixed, but there were cases where some unused fields in

01:27:14,890 --> 01:27:18,260
SMB2 were spilling out kernel memory at some point.

01:27:18,260 --> 01:27:19,780
So this is obviously new.

01:27:19,780 --> 01:27:23,130


01:27:23,130 --> 01:27:25,900
Requirements, I'm not sure.

01:27:25,900 --> 01:27:29,200
There's an old story which I won't repeat here about why

01:27:29,200 --> 01:27:32,560
SMB2 was created, but if you search on the internet for it

01:27:32,560 --> 01:27:34,120
I'm sure you'll be able to find my

01:27:34,120 --> 01:27:35,040
earlier comments on that.

01:27:35,040 --> 01:27:35,635
Yeah, question.

01:27:35,635 --> 01:27:36,885
AUDIENCE: [INAUDIBLE].

01:27:36,885 --> 01:27:40,760


01:27:40,760 --> 01:27:43,930
JEREMY ALLISON: So the question was, does it do

01:27:43,930 --> 01:27:46,380
high-latency TCP Windows scaling better?

01:27:46,380 --> 01:27:47,960
Probably.

01:27:47,960 --> 01:27:49,450
I haven't looked it that carefully.

01:27:49,450 --> 01:27:52,460
Having said that, that was touted as one of the

01:27:52,460 --> 01:27:53,330
advantages.

01:27:53,330 --> 01:27:57,100
So Tridge actually sat down, brought up Windows Explorer

01:27:57,100 --> 01:28:00,390
using SMB against a Samba server, and then brought up

01:28:00,390 --> 01:28:03,730
the same Windows Explorer on the same directory to a Vista

01:28:03,730 --> 01:28:05,680
box using SMB2.

01:28:05,680 --> 01:28:13,140
And what he found was that it did either two or three times

01:28:13,140 --> 01:28:14,070
the number of packets.

01:28:14,070 --> 01:28:15,550
AUDIENCE: [INAUDIBLE].

01:28:15,550 --> 01:28:18,120
JEREMY ALLISON: So latency is going to kill you.

01:28:18,120 --> 01:28:19,370
Oh, to SMB2.

01:28:19,370 --> 01:28:22,980


01:28:22,980 --> 01:28:26,220
On the wire, transport might be very efficient, but if

01:28:26,220 --> 01:28:29,220
you've got the Windows Explorer developers writing

01:28:29,220 --> 01:28:33,160
the code that actually drives it, then it's going to suck.

01:28:33,160 --> 01:28:36,480
So yeah, I'm not expecting much out of it at the moment.

01:28:36,480 --> 01:28:37,540
But we're watching it.

01:28:37,540 --> 01:28:39,480
We have the ability to implement if

01:28:39,480 --> 01:28:40,550
we really have to.

01:28:40,550 --> 01:28:43,680
My guess is it would probably take a crash program of three

01:28:43,680 --> 01:28:47,140
to six months to get an SMB2 server nailed into the current

01:28:47,140 --> 01:28:49,200
production code if we really had to.

01:28:49,200 --> 01:28:52,190
I just don't want to have to, to be honest. My goal is that

01:28:52,190 --> 01:28:57,510
SMB2 is such a disaster that nobody bothers with it.

01:28:57,510 --> 01:28:59,810
You've got to have a dream, and that's mine.

01:28:59,810 --> 01:29:04,640


01:29:04,640 --> 01:29:07,920
Active directory, again, is not a static target.

01:29:07,920 --> 01:29:11,970
New RPCs turn up, new info levels of RPCs turn up.

01:29:11,970 --> 01:29:13,740
We have to work out what they are.

01:29:13,740 --> 01:29:15,230
I'm not so worried about that.

01:29:15,230 --> 01:29:17,410
We're getting pretty good at that.

01:29:17,410 --> 01:29:20,120
There's some interesting code that's going to come out soon.

01:29:20,120 --> 01:29:24,080
And again, the XPS, which is a new print subsystem, and

01:29:24,080 --> 01:29:28,590
server-side printing are the difficulties there.

01:29:28,590 --> 01:29:32,430
XPS doesn't actually seem to affect the print path much.

01:29:32,430 --> 01:29:34,130
I think it's more the rendering engine that

01:29:34,130 --> 01:29:35,520
changes with XPS.

01:29:35,520 --> 01:29:38,960
It still uses the old, crusty, hideous RPCs to actually do

01:29:38,960 --> 01:29:39,640
the transport.

01:29:39,640 --> 01:29:42,120
And to be honest, I don't care how they render it.

01:29:42,120 --> 01:29:45,850
I really don't, it's just bits to me and so long as I can

01:29:45,850 --> 01:29:46,800
serve [UNINTELLIGIBLE]

01:29:46,800 --> 01:29:48,270
over RPC, I'm happy.

01:29:48,270 --> 01:29:50,631
So I'm not so worried about that one.

01:29:50,631 --> 01:29:53,220


01:29:53,220 --> 01:29:55,290
Development is accelerating, as you may notice.

01:29:55,290 --> 01:29:57,170
Our release schedule gets longer, but development is

01:29:57,170 --> 01:29:59,790
actually getting faster and faster.

01:29:59,790 --> 01:30:03,150
So clustered Samba is going to be the next big thing.

01:30:03,150 --> 01:30:04,760
Tridge is going to be doing some demos of

01:30:04,760 --> 01:30:07,460
that at Samba XP.

01:30:07,460 --> 01:30:10,640
One of the things we really, really, really have to fix is

01:30:10,640 --> 01:30:13,350
remote provisioning, because the days of having each

01:30:13,350 --> 01:30:16,690
machine with an individual SMB.com file just sucks and

01:30:16,690 --> 01:30:19,130
must go away.

01:30:19,130 --> 01:30:24,920
So essentially, that's pretty similar to a group policy kind

01:30:24,920 --> 01:30:27,510
of thing, pushing out a configuration.

01:30:27,510 --> 01:30:32,410
So with virtualization, I don't know about you, I have a

01:30:32,410 --> 01:30:36,420
bunch of virtual machines at home because the dirty secret

01:30:36,420 --> 01:30:39,700
of the Samba team is no one, except for Jerry actually, he

01:30:39,700 --> 01:30:44,170
fell on his sword, nobody uses Windows anymore for anything.

01:30:44,170 --> 01:30:46,790
All we do is we have libraries of VMware images and when

01:30:46,790 --> 01:30:49,240
people complain, we test things.

01:30:49,240 --> 01:30:51,800
Jerry is the only Samba team member who says, look,

01:30:51,800 --> 01:30:53,690
somebody has got to do this, I'm going to run my home

01:30:53,690 --> 01:30:58,900
directory off Windows against the Samba server.

01:30:58,900 --> 01:31:01,460
Basically, he's an iPod fan so he has iTunes running.

01:31:01,460 --> 01:31:04,990
And apparently, iTunes breaks if anything goes wrong so.

01:31:04,990 --> 01:31:08,360
So that's one of our best tests.

01:31:08,360 --> 01:31:12,470
So with virtualization, the number of servers that you're

01:31:12,470 --> 01:31:14,800
going to have is going to be greater than the number of

01:31:14,800 --> 01:31:15,550
physical machines.

01:31:15,550 --> 01:31:18,820
And people have already got too many physical machines.

01:31:18,820 --> 01:31:21,930
On my home network, I have a bunch of virtual machines.

01:31:21,930 --> 01:31:24,860
I lost a server.

01:31:24,860 --> 01:31:26,400
As in, it was up there.

01:31:26,400 --> 01:31:29,500
I didn't know where it was, because everything's VMware.

01:31:29,500 --> 01:31:31,390
I have a bunch of machines in my bedroom.

01:31:31,390 --> 01:31:34,040
I was remote, and I didn't know where it was.

01:31:34,040 --> 01:31:37,370
And the thing is pinging and I'm like, OK, but what machine

01:31:37,370 --> 01:31:38,670
is it running on?

01:31:38,670 --> 01:31:43,090
So yeah, this is the nightmare of virtual machines, is that

01:31:43,090 --> 01:31:45,870
you can lose the damn things.

01:31:45,870 --> 01:31:47,450
Anyway.

01:31:47,450 --> 01:31:49,460
So encrypted CIFS transport, woohoo.

01:31:49,460 --> 01:31:52,620
I've just spent the last two weeks, if you follow my

01:31:52,620 --> 01:31:55,820
snippets in Google, you can see I've been pushing off

01:31:55,820 --> 01:31:58,820
everything else and just working on this.

01:31:58,820 --> 01:32:00,470
We need it for NFSv4.

01:32:00,470 --> 01:32:02,430
I've got the NTLM encryption working.

01:32:02,430 --> 01:32:08,160
I'm finishing up the Kerberized encryption, and I

01:32:08,160 --> 01:32:09,150
think this has a bright future.

01:32:09,150 --> 01:32:10,440
I'm very happy about that.

01:32:10,440 --> 01:32:13,270
One of the things that I think we might be able to do with

01:32:13,270 --> 01:32:16,060
SMB encrypted filesystems that you can't currently do with

01:32:16,060 --> 01:32:21,370
NFS is have a mix of encrypted and non-encrypted.

01:32:21,370 --> 01:32:24,200
On the same server, you'll be able to have a share that you

01:32:24,200 --> 01:32:27,200
decide is particularly sensitive and therefore any

01:32:27,200 --> 01:32:30,320
access to that particular share, even on the same TCP

01:32:30,320 --> 01:32:33,680
stream, that share access will be encrypted whereas the other

01:32:33,680 --> 01:32:34,600
stuff is not.

01:32:34,600 --> 01:32:37,740
So there's big arguments about that.

01:32:37,740 --> 01:32:38,110
Yeah, question.

01:32:38,110 --> 01:32:39,034
AUDIENCE: Encryption.

01:32:39,034 --> 01:32:41,344
Is it something like [UNINTELLIGIBLE].

01:32:41,344 --> 01:32:43,620
JEREMY ALLISON: It's GSSAPI.

01:32:43,620 --> 01:32:45,850
Screw you, I didn't invent anything new.

01:32:45,850 --> 01:32:47,820
Do you know why I didn't invent anything new?

01:32:47,820 --> 01:32:50,460
Because I knew people would whine and say, if you invent

01:32:50,460 --> 01:32:51,980
something new, you'll screw it up.

01:32:51,980 --> 01:32:55,030
So I've used standard GSSAPIs.

01:32:55,030 --> 01:32:57,370
I don't know what GSS is using underneath.

01:32:57,370 --> 01:33:00,750
It's configurable in the krb5.conf and I don't care.

01:33:00,750 --> 01:33:03,120
So if it breaks, it's their fault, not mine.

01:33:03,120 --> 01:33:04,804
AUDIENCE: So this is entirely yours and it's not

01:33:04,804 --> 01:33:05,225
Microsoft's?

01:33:05,225 --> 01:33:06,260
JEREMY ALLISON: Yes, that's right.

01:33:06,260 --> 01:33:07,500
This is Unix extensions.

01:33:07,500 --> 01:33:08,170
Sorry yeah.

01:33:08,170 --> 01:33:09,480
So this is Unix extensions.

01:33:09,480 --> 01:33:11,440
No, Microsoft has not yet done this.

01:33:11,440 --> 01:33:15,560
I would be very happy if they adopted this, actually.

01:33:15,560 --> 01:33:18,200
I'm going to document all this stuff up, I'm going to hand it

01:33:18,200 --> 01:33:21,080
to them and say, here's how we're doing this.

01:33:21,080 --> 01:33:24,070
And I would be very happy if they implemented that.

01:33:24,070 --> 01:33:26,424
I don't expect them to.

01:33:26,424 --> 01:33:27,674
AUDIENCE: [INAUDIBLE].

01:33:27,674 --> 01:33:30,136


01:33:30,136 --> 01:33:33,020
JEREMY ALLISON: So the comment is, aren't they using SPNEGO

01:33:33,020 --> 01:33:34,700
around the GSSAPI?

01:33:34,700 --> 01:33:36,190
But that's only for negotiation.

01:33:36,190 --> 01:33:37,840
So do we.

01:33:37,840 --> 01:33:39,440
That's where our nasty little hand-written ASN.1

01:33:39,440 --> 01:33:41,920
parser comes in.

01:33:41,920 --> 01:33:47,080
So we hand-unwrap the SPNEGO blobs and then pass them down

01:33:47,080 --> 01:33:48,980
to the Kerberos libs.

01:33:48,980 --> 01:33:55,570
I hand-unwrap my SPNEGO blob and then hand it down into the

01:33:55,570 --> 01:33:57,740
GSS library and it just works.

01:33:57,740 --> 01:34:01,220
And I don't have to care.

01:34:01,220 --> 01:34:03,820
So long as you've got the right GSS libraries, it'll do

01:34:03,820 --> 01:34:07,510
AAS, AAAS, whatever you tell it to.

01:34:07,510 --> 01:34:11,710
It's going to be slow as molasses unfortunately,

01:34:11,710 --> 01:34:14,850
because the GSSAPI doesn't allow you to do encryption and

01:34:14,850 --> 01:34:15,770
decryption in place.

01:34:15,770 --> 01:34:16,790
It always allocates a buffer.

01:34:16,790 --> 01:34:19,750
And when you're doing 127 k reads or writes,

01:34:19,750 --> 01:34:20,580
that's going to suck.

01:34:20,580 --> 01:34:25,190
But hey, this is not for speed, this is for security.

01:34:25,190 --> 01:34:27,600
Like I say, the nice thing about it is rather than having

01:34:27,600 --> 01:34:32,080
to do certificates, have to set up Kerberos principles,

01:34:32,080 --> 01:34:34,950
the main use I think this is going to be is for the little

01:34:34,950 --> 01:34:39,210
home NAS market where let's say people might have some

01:34:39,210 --> 01:34:41,980
secure data that they don't want going in the clear over

01:34:41,980 --> 01:34:43,740
the wireless network.

01:34:43,740 --> 01:34:44,740
Image data, perhaps.

01:34:44,740 --> 01:34:46,420
I wonder why people might want to do that.

01:34:46,420 --> 01:34:49,390
Can't possibly think.

01:34:49,390 --> 01:34:52,350
Secure image data on a home network so your kids don't see

01:34:52,350 --> 01:34:54,820
it, that's probably a good thing.

01:34:54,820 --> 01:34:57,940
Group policies for our winbindd.

01:34:57,940 --> 01:34:59,700
So as I say, winbindd continues to take over the

01:34:59,700 --> 01:35:04,880
world and essentially, it's LSA for Unix.

01:35:04,880 --> 01:35:10,630
So winbindd is getting lots and lots more work.

01:35:10,630 --> 01:35:13,740
I don't know whether you're aware of companies like

01:35:13,740 --> 01:35:17,140
Vintela and what's the other one?

01:35:17,140 --> 01:35:20,350
Centrify, I think, they have a similar product.

01:35:20,350 --> 01:35:22,800
It's not using winbindd, but it's a similar product.

01:35:22,800 --> 01:35:25,950
So I think winbindd can take the place of those things

01:35:25,950 --> 01:35:27,200
quite easily.

01:35:27,200 --> 01:35:31,600


01:35:31,600 --> 01:35:31,990
I'm done.

01:35:31,990 --> 01:35:32,880
Hooray.

01:35:32,880 --> 01:35:34,103
Yes, question.

01:35:34,103 --> 01:35:35,353
AUDIENCE: [INAUDIBLE].

01:35:35,353 --> 01:35:39,306


01:35:39,306 --> 01:35:41,830
JEREMY ALLISON: So the question is, is winbindd like

01:35:41,830 --> 01:35:43,550
the NetWare Novell Bindery?

01:35:43,550 --> 01:35:45,350
You know, I never actually understood

01:35:45,350 --> 01:35:47,390
what the Bindery was.

01:35:47,390 --> 01:35:49,510
I thought that was like a directory service, isn't it?

01:35:49,510 --> 01:35:50,701
AUDIENCE: [INAUDIBLE].

01:35:50,701 --> 01:35:52,630
JEREMY ALLISON: Well, winbindd is a proxy

01:35:52,630 --> 01:35:54,090
to a directory service.

01:35:54,090 --> 01:35:57,020
Winbindd itself isn't a directory service.

01:35:57,020 --> 01:35:58,170
It's a proxy for one.

01:35:58,170 --> 01:35:59,420
AUDIENCE: [INAUDIBLE].

01:35:59,420 --> 01:36:13,754


01:36:13,754 --> 01:36:16,480
JEREMY ALLISON: But they do that using something that

01:36:16,480 --> 01:36:19,670
sucks, sucks, sucks horribly.

01:36:19,670 --> 01:36:22,470
When you install the NetWare client for Windows--

01:36:22,470 --> 01:36:25,200
I know this, and this is not to criticize the people who

01:36:25,200 --> 01:36:27,920
did it because they have no other choice, and when I was

01:36:27,920 --> 01:36:29,510
at Novell they were in my group, and

01:36:29,510 --> 01:36:30,720
they're very small people.

01:36:30,720 --> 01:36:33,030
It's just that Microsoft gives you no choice.

01:36:33,030 --> 01:36:34,960
What they have is a GINA, which is

01:36:34,960 --> 01:36:36,020
the replacement logon.

01:36:36,020 --> 01:36:39,180
And what that does is essentially it creates a

01:36:39,180 --> 01:36:43,880
transient SID, it creates a local SID on the workstation.

01:36:43,880 --> 01:36:48,210
So it doesn't actually authenticate against the NT 4

01:36:48,210 --> 01:36:49,330
domain at all.

01:36:49,330 --> 01:36:51,600
What it does is it uses NetWare authentication,

01:36:51,600 --> 01:36:53,640
creates you a transient SID, and that's who

01:36:53,640 --> 01:36:55,330
you are on that box.

01:36:55,330 --> 01:36:56,840
It keeps you consistent.

01:36:56,840 --> 01:37:00,540
And if you're using NetWare file service, then essentially

01:37:00,540 --> 01:37:03,020
you have the same user ID across

01:37:03,020 --> 01:37:06,020
every single file server.

01:37:06,020 --> 01:37:09,530
Essentially, you don't need to have a globally unique SID

01:37:09,530 --> 01:37:12,540
because the server recognizes who you are because of who you

01:37:12,540 --> 01:37:13,390
authenticated as.

01:37:13,390 --> 01:37:15,040
But that's actually different from winbindd.

01:37:15,040 --> 01:37:17,765
AUDIENCE: [INAUDIBLE].

01:37:17,765 --> 01:37:19,400
JEREMY ALLISON: Yes, that's right.

01:37:19,400 --> 01:37:21,140
And that became eDirectory.

01:37:21,140 --> 01:37:24,500
And now, using the ZAD code that's been ported on top of

01:37:24,500 --> 01:37:26,870
that, they're actually providing real, active

01:37:26,870 --> 01:37:29,550
directory domain controller services on top of eDirectory.

01:37:29,550 --> 01:37:32,590


01:37:32,590 --> 01:37:36,970
But yeah, it's actually different.

01:37:36,970 --> 01:37:40,500
That level in Linux is actually the

01:37:40,500 --> 01:37:43,180
pam layer in Linux.

01:37:43,180 --> 01:37:45,440
And that then talks to winbindd, but winbindd is

01:37:45,440 --> 01:37:48,900
simply a proxy for talking to an external directory service.

01:37:48,900 --> 01:37:50,590
But it will cache stuff locally for

01:37:50,590 --> 01:37:52,896
disconnected operation.

01:37:52,896 --> 01:37:53,955
Any other questions?

01:37:53,955 --> 01:37:55,205
Hooray, I'm done, I'm done.

01:37:55,205 --> 01:38:00,110


01:38:00,110 --> 01:38:00,912
Oh, yes.

01:38:00,912 --> 01:38:03,864
AUDIENCE: It seems like basically nothing is

01:38:03,864 --> 01:38:05,340
documented from Microsoft's side.

01:38:05,340 --> 01:38:06,570
You have to do a lot of reverse

01:38:06,570 --> 01:38:07,800
engineering to get any place.

01:38:07,800 --> 01:38:10,260
Even when it's documented, it's wrong.

01:38:10,260 --> 01:38:14,196
And so any hard feelings for microsoft, that you guys are

01:38:14,196 --> 01:38:16,786
doing that?

01:38:16,786 --> 01:38:19,200
JEREMY ALLISON: I get on with Microsoft engineers very well.

01:38:19,200 --> 01:38:21,500
I don't think their marketing people like us very much.

01:38:21,500 --> 01:38:25,280


01:38:25,280 --> 01:38:28,130
There's a whole court case going on in Europe about that,

01:38:28,130 --> 01:38:33,520
as you may know, which Samba has been involved in and is

01:38:33,520 --> 01:38:36,420
still involved in.

01:38:36,420 --> 01:38:38,480
Apparently there is documentation now, it's just

01:38:38,480 --> 01:38:41,740
that the licensing has been crafted such that open source

01:38:41,740 --> 01:38:43,710
and free software projects can't see it.

01:38:43,710 --> 01:38:47,210


01:38:47,210 --> 01:38:52,040
But to be honest, if I did see it, there are certain things I

01:38:52,040 --> 01:38:54,340
would look for and if I didn't see them, I'd know it was

01:38:54,340 --> 01:38:56,750
wrong anyway.

01:38:56,750 --> 01:38:59,300
The problem is this thing is so big and ugly and complex,

01:38:59,300 --> 01:39:01,420
unless you actually really know how it works, who are you

01:39:01,420 --> 01:39:04,240
going to tell when the documentation is right?

01:39:04,240 --> 01:39:05,976
The only way you can tell when the documentation is right is

01:39:05,976 --> 01:39:08,270
to actually write something that follows the

01:39:08,270 --> 01:39:09,320
documentation.

01:39:09,320 --> 01:39:12,450
But if you do that and it doesn't work then you've spent

01:39:12,450 --> 01:39:14,940
10 years of effort.

01:39:14,940 --> 01:39:18,180
This whole thing doesn't really work very well, if you

01:39:18,180 --> 01:39:20,280
see what I mean.

01:39:20,280 --> 01:39:22,650
What I would really hope is for Microsoft to finish

01:39:22,650 --> 01:39:26,280
documenting stuff, to put it out there under RFC-like

01:39:26,280 --> 01:39:30,040
terms, i.e., available for everybody to use, and at that

01:39:30,040 --> 01:39:32,580
point we can actually collaborate on it with them

01:39:32,580 --> 01:39:33,950
and we can point out bugs.

01:39:33,950 --> 01:39:36,640
We can say oh no, that's not quite right.

01:39:36,640 --> 01:39:38,990
I remember when I gave my first talk on how Windows

01:39:38,990 --> 01:39:41,980
locking works, the Microsoft guy there said, can I have a

01:39:41,980 --> 01:39:44,390
copy of that because I want to give it to the CIFS team

01:39:44,390 --> 01:39:47,400
inside Microsoft because it will help train new engineers

01:39:47,400 --> 01:39:50,180
on how it's supposed to work.

01:39:50,180 --> 01:39:52,080
Because we've been doing this a long time, what would be

01:39:52,080 --> 01:39:55,200
really nice is if they would open up those docs and

01:39:55,200 --> 01:39:58,300
essentially, at that point, we could use them like a wiki and

01:39:58,300 --> 01:40:01,410
we would collaborate, and everybody would at least

01:40:01,410 --> 01:40:04,090
document what we've experienced.

01:40:04,090 --> 01:40:06,900
And at that point, we'd have a hope of documenting OK, this

01:40:06,900 --> 01:40:08,800
is what version x of Windows did.

01:40:08,800 --> 01:40:10,820
And it might have been slightly wrong or whatever,

01:40:10,820 --> 01:40:12,950
but everybody would collaborate together on it.

01:40:12,950 --> 01:40:16,470
But that's my goal, that's what I hope all this comes to.

01:40:16,470 --> 01:40:19,330
I think that would be great, actually.

01:40:19,330 --> 01:40:20,080
Yeah, question.

01:40:20,080 --> 01:40:21,330
AUDIENCE: [INAUDIBLE].

01:40:21,330 --> 01:40:33,337


01:40:33,337 --> 01:40:35,050
JEREMY ALLISON: I believe so.

01:40:35,050 --> 01:40:37,340
I don't know much about Radius.

01:40:37,340 --> 01:40:39,700
I know Radius is another authentication mechanism.

01:40:39,700 --> 01:40:43,390
So what winbindd does is it allows you to authenticate to

01:40:43,390 --> 01:40:45,020
an external source.

01:40:45,020 --> 01:40:46,240
It will actually manage your Kerberos

01:40:46,240 --> 01:40:47,770
tickets for you, as well.

01:40:47,770 --> 01:40:52,170
So rather than calling pam Kerberos, which gets the

01:40:52,170 --> 01:40:54,730
tickets directly from the Kerberos server, you can

01:40:54,730 --> 01:40:58,080
essentially proxy to winbindd and winbindd will fetch and

01:40:58,080 --> 01:40:59,930
maintain your tickets for you.

01:40:59,930 --> 01:41:03,220
So it will get you a TGT and if the TGT is starting to

01:41:03,220 --> 01:41:06,070
expire, winbindd will re-fetch it for you based on your cache

01:41:06,070 --> 01:41:06,760
credentials.

01:41:06,760 --> 01:41:07,830
If you tell it to.

01:41:07,830 --> 01:41:10,800
So winbindd is becoming this really great piece of glue

01:41:10,800 --> 01:41:14,240
technology that will work very well there.

01:41:14,240 --> 01:41:14,820
Yeah, question.

01:41:14,820 --> 01:41:17,270
AUDIENCE: You mentioned that you're getting better decoding

01:41:17,270 --> 01:41:23,640
the RPC they have. Have you looked at using those methods

01:41:23,640 --> 01:41:27,070
on other protocols, other than the file serving?

01:41:27,070 --> 01:41:28,050
Something like [UNINTELLIGIBLE]

01:41:28,050 --> 01:41:29,300
Exchange?

01:41:29,300 --> 01:41:31,260


01:41:31,260 --> 01:41:33,810
JEREMY ALLISON: So the question is, have you looked

01:41:33,810 --> 01:41:36,760
at Exchange protocol using your methods we've

01:41:36,760 --> 01:41:38,710
been using to do RPC?

01:41:38,710 --> 01:41:40,955
Notice I didn't describe what our methods are.

01:41:40,955 --> 01:41:45,090


01:41:45,090 --> 01:41:47,250
The interesting thing is that our methods wouldn't work on

01:41:47,250 --> 01:41:50,870
Exchange because Exchange, although tunneled in an RPC

01:41:50,870 --> 01:41:54,910
transport is not an RPC protocol.

01:41:54,910 --> 01:41:59,940
All Exchange does is it uses basically, here's data send,

01:41:59,940 --> 01:42:02,360
here's data back RPCs.

01:42:02,360 --> 01:42:06,150
But what's inside those blobs is a completely different and

01:42:06,150 --> 01:42:08,390
encrypted new protocol.

01:42:08,390 --> 01:42:11,620
You can speculate why that's done.

01:42:11,620 --> 01:42:15,820
I have some good theories on why they do that.

01:42:15,820 --> 01:42:20,540
Interoperability prevention I think is probably the best and

01:42:20,540 --> 01:42:22,070
the most popular one at that.

01:42:22,070 --> 01:42:23,150
So that wouldn't actually help.

01:42:23,150 --> 01:42:26,405
AUDIENCE: [UNINTELLIGIBLE].

01:42:26,405 --> 01:42:28,050
JEREMY ALLISON: No.

01:42:28,050 --> 01:42:29,310
No it isn't.

01:42:29,310 --> 01:42:32,540
I do know people who have worked on and decoded that,

01:42:32,540 --> 01:42:36,940
and the best comment I heard from that is he said, you

01:42:36,940 --> 01:42:39,470
think CIFS is bad, you should see this thing.

01:42:39,470 --> 01:42:43,140


01:42:43,140 --> 01:42:44,390
But it wasn't ASN.1.

01:42:44,390 --> 01:42:47,550


01:42:47,550 --> 01:42:49,180
Any other questions, comments?

01:42:49,180 --> 01:42:52,505
AUDIENCE: You said earlier that the POSIX [INAUDIBLE].

01:42:52,505 --> 01:42:56,780


01:42:56,780 --> 01:42:57,990
JEREMY ALLISON: Yes indeed.

01:42:57,990 --> 01:43:02,900
AUDIENCE: The POSIX open semantics are interesting when

01:43:02,900 --> 01:43:06,410
it comes to [INAUDIBLE].

01:43:06,410 --> 01:43:07,650
JEREMY ALLISON: Oh yes, and that's why we

01:43:07,650 --> 01:43:09,490
have to cache it.

01:43:09,490 --> 01:43:12,780
So we have an entire layer that says if there's a locks

01:43:12,780 --> 01:43:15,480
extent on this, then we push it in a queue

01:43:15,480 --> 01:43:16,610
and we close it later.

01:43:16,610 --> 01:43:19,640
That's the only case where we can potentially lose data

01:43:19,640 --> 01:43:24,450
because if you are proxying a Samba mount of NFS-- remember,

01:43:24,450 --> 01:43:26,980
NFS sucks--

01:43:26,980 --> 01:43:31,990
NFS can do write-behinds and NFS can return you write error

01:43:31,990 --> 01:43:34,190
on a close.

01:43:34,190 --> 01:43:39,080
I actually had to debug a big Samba installation on AAX

01:43:39,080 --> 01:43:42,260
running for Intel up in Portland at one point, and

01:43:42,260 --> 01:43:45,910
they were hitting bugs where essentially we weren't

01:43:45,910 --> 01:43:48,430
returning errors correctly on a close.

01:43:48,430 --> 01:43:51,360
And what was happening was they had a disk-full condition

01:43:51,360 --> 01:43:54,385
that they haven't noticed and the writes succeed but the

01:43:54,385 --> 01:43:55,010
close fails.

01:43:55,010 --> 01:43:57,430
AUDIENCE: [INAUDIBLE].

01:43:57,430 --> 01:43:58,740
JEREMY ALLISON: Yes, I agree.

01:43:58,740 --> 01:44:01,460
But I've never seen it on a local file system.

01:44:01,460 --> 01:44:04,760
I've only ever seen it on bloody NFS servers, which

01:44:04,760 --> 01:44:07,440
happens all the time because they're doing write-behind.

01:44:07,440 --> 01:44:10,550
And that's the only case where we could theoretically lose

01:44:10,550 --> 01:44:13,160
data because we have to defer the close.

01:44:13,160 --> 01:44:16,090
And once we've told the client, yes, we've closed that

01:44:16,090 --> 01:44:21,070
and it's been successful, essentially all we can do is

01:44:21,070 --> 01:44:26,910
we can pass along the error on close to the last closer, is

01:44:26,910 --> 01:44:28,940
all we can do in that case.

01:44:28,940 --> 01:44:32,340
But I've spent a great deal of time inside that code making

01:44:32,340 --> 01:44:34,740
the semantics as good as we can get them for that case.

01:44:34,740 --> 01:44:38,240


01:44:38,240 --> 01:44:39,490
Any other questions?

01:44:39,490 --> 01:44:42,720


01:44:42,720 --> 01:44:44,310
All right, we're done.

01:44:44,310 --> 01:44:46,340
Thank you very much for coming.

01:44:46,340 --> 01:44:47,490
I hope you've enjoyed it.

01:44:47,490 --> 01:44:49,040
Thank you.


YouTube URL: https://www.youtube.com/watch?v=0LgIb-TZVbg


