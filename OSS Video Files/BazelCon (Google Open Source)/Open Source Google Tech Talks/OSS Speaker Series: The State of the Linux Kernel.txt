Title: OSS Speaker Series: The State of the Linux Kernel
Publication date: 2010-10-27
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talks
May 1, 2007

ABSTRACT



Andrew will present a broad look at the trends in recent changes in the Linux kernel: what areas of kernel functionality are people working on, and what changes can we expect to see over the next year ?

This feature-by-feature walk-through will be tied to an examination of the motivations of the kernel contributors: why do particular individuals and organizations choose particular things to work upon ?

He will also examine areas of the kernel which are arguably suffering from some neglect, the reasons for this and some possible corrective actions which might be taken.

Andrew will finish with a discussion of the importance of individual testers...
Captions: 
	00:00:26,939 --> 00:00:32,750
well thanks for coming everybody how

00:00:29,039 --> 00:00:35,760
many Australians are here excellent

00:00:32,750 --> 00:00:38,460
and how many over not Google is how many

00:00:35,760 --> 00:00:39,600
not Google it's you that's a lot - it's

00:00:38,460 --> 00:00:42,780
good to see we have there's still

00:00:39,600 --> 00:00:45,379
somebody we haven't hired people from

00:00:42,780 --> 00:00:45,379
the real world

00:00:45,530 --> 00:00:52,170
myself a bit of background on myself I

00:00:48,390 --> 00:00:55,920
started a next development in 1999 which

00:00:52,170 --> 00:00:59,360
makes me a newbie because people join

00:00:55,920 --> 00:01:01,350
the kernel project never seem to leave I

00:00:59,360 --> 00:01:04,890
started out doing some maintenance work

00:01:01,350 --> 00:01:06,890
on network drivers and then in the year

00:01:04,890 --> 00:01:10,110
2000 I spent pretty much the whole time

00:01:06,890 --> 00:01:12,180
just fixing bugs in the 2.3 series I

00:01:10,110 --> 00:01:14,040
look on the mailing list try and

00:01:12,180 --> 00:01:17,460
reproduce other people's bugs work with

00:01:14,040 --> 00:01:19,110
reporters attempting to fix bugs and so

00:01:17,460 --> 00:01:20,100
whenever young fella comes up to me and

00:01:19,110 --> 00:01:22,560
says how do I get into kernel

00:01:20,100 --> 00:01:24,150
development I tell them just fix bugs

00:01:22,560 --> 00:01:26,280
because it's a great way to learn the

00:01:24,150 --> 00:01:28,140
code I found that you could stare at

00:01:26,280 --> 00:01:30,090
code for days and days stared into your

00:01:28,140 --> 00:01:31,380
teeth fell out you'd never learn it as

00:01:30,090 --> 00:01:33,270
well as when you needed to get in there

00:01:31,380 --> 00:01:38,850
and make a change so I always tell

00:01:33,270 --> 00:01:43,109
people that none of them ever do it Brad

00:01:38,850 --> 00:01:46,469
about 2001 I got a job doing Linux stuff

00:01:43,109 --> 00:01:52,829
I was putting the Red Hat's 2.2 based

00:01:46,469 --> 00:01:54,299
ext3 into the 2.4 kernel and file

00:01:52,829 --> 00:01:55,740
systems and memory management are

00:01:54,299 --> 00:01:57,329
terribly closely linked a little mixed

00:01:55,740 --> 00:01:59,850
so but inevitably I learned a lot about

00:01:57,329 --> 00:02:02,579
memory management that way so when the 2

00:01:59,850 --> 00:02:04,350
5 series opened up I did a lot of work

00:02:02,579 --> 00:02:05,759
on memory management managed to fix a

00:02:04,350 --> 00:02:09,750
lot of the problems I had wrestled with

00:02:05,759 --> 00:02:11,610
when doing the ext3 port then Linda's

00:02:09,750 --> 00:02:13,290
came along and take me on the shoulder

00:02:11,610 --> 00:02:17,220
and asked me to look after the 2.6

00:02:13,290 --> 00:02:18,959
series after he had branched off 2.7 of

00:02:17,220 --> 00:02:21,390
course we then changed the plan so we

00:02:18,959 --> 00:02:24,920
have no plans now ever to open up to

00:02:21,390 --> 00:02:27,660
seven series so basically Loomis and I

00:02:24,920 --> 00:02:29,760
maintain Co maintaining if you like the

00:02:27,660 --> 00:02:31,610
production kernel which is also the

00:02:29,760 --> 00:02:34,290
development cone all the to six series

00:02:31,610 --> 00:02:35,880
and that situation has been relatively

00:02:34,290 --> 00:02:38,390
stable for the past three or four years

00:02:35,880 --> 00:02:38,390
now

00:02:39,060 --> 00:02:44,830
my talk today is what thought Leslie

00:02:42,580 --> 00:02:47,349
politely called a reprise of a talk that

00:02:44,830 --> 00:02:49,540
I gave earlier on this year so if any of

00:02:47,349 --> 00:02:51,340
you were here were in Belgium who heard

00:02:49,540 --> 00:02:54,099
me speak of February you can go go hey

00:02:51,340 --> 00:02:56,230
now but it's surprising that when I was

00:02:54,099 --> 00:02:57,910
doing my reprise of the reprise how much

00:02:56,230 --> 00:02:59,200
stuff had changed us in that two-month

00:02:57,910 --> 00:03:00,250
window I've quite a lot of things I

00:02:59,200 --> 00:03:03,610
think not gonna do that

00:03:00,250 --> 00:03:05,950
a lot of new things came in so kernel

00:03:03,610 --> 00:03:08,230
development is pretty a rapid rate of

00:03:05,950 --> 00:03:10,840
change of code is very fast a lot of new

00:03:08,230 --> 00:03:16,180
things come out very commonly and very

00:03:10,840 --> 00:03:19,450
rapidly so the sort of things I was

00:03:16,180 --> 00:03:21,459
going to look at today and I've got

00:03:19,450 --> 00:03:23,650
about 40 minutes of Stand and Deliver

00:03:21,459 --> 00:03:26,170
here I think and probably 20 minutes of

00:03:23,650 --> 00:03:27,849
Q&A at the end it's important to

00:03:26,170 --> 00:03:31,209
understand my job in the world is to

00:03:27,849 --> 00:03:32,829
serve people such as yourselves so it'd

00:03:31,209 --> 00:03:34,299
probably be more beneficial if you are

00:03:32,829 --> 00:03:35,530
all standing up here and are sitting

00:03:34,299 --> 00:03:37,090
down there and you're talking to me

00:03:35,530 --> 00:03:39,970
because it's important to me to

00:03:37,090 --> 00:03:42,489
understand what people are using Linux

00:03:39,970 --> 00:03:45,670
for what their pain points are etc so

00:03:42,489 --> 00:03:48,430
please let's use that 20 minutes which

00:03:45,670 --> 00:03:50,799
I'm happy to arbitrarily stretch so to

00:03:48,430 --> 00:03:54,310
help me understand how we're going in

00:03:50,799 --> 00:03:58,510
the kernel and whether we're going the

00:03:54,310 --> 00:04:00,310
right direction etc in mind prepare

00:03:58,510 --> 00:04:03,579
batter I have some stuff on which

00:04:00,310 --> 00:04:05,769
features have recently been merged in

00:04:03,579 --> 00:04:08,739
the kernel which we're which features

00:04:05,769 --> 00:04:10,569
we're presently contemplating what might

00:04:08,739 --> 00:04:13,930
turn up in the kernel over the next

00:04:10,569 --> 00:04:15,940
twelve months or so I'll spend some time

00:04:13,930 --> 00:04:17,560
looking at who is actually developing

00:04:15,940 --> 00:04:19,479
those features and what their

00:04:17,560 --> 00:04:23,080
motivations are for doing kernel

00:04:19,479 --> 00:04:24,580
development work I'll look at what the

00:04:23,080 --> 00:04:25,930
role of professional developers is

00:04:24,580 --> 00:04:28,150
people who are paid to work on the

00:04:25,930 --> 00:04:31,870
kernel possesses those who do it out of

00:04:28,150 --> 00:04:34,660
love loss GP duty and we'll also look at

00:04:31,870 --> 00:04:37,030
the private developers and how I'll also

00:04:34,660 --> 00:04:38,560
touch on how individuals who are not

00:04:37,030 --> 00:04:40,510
paid to work on the kernel but who wish

00:04:38,560 --> 00:04:43,889
to contribute to the kernel how they

00:04:40,510 --> 00:04:43,889
could most effectively do so

00:04:45,260 --> 00:04:50,490
first up what sort of machines use Linux

00:04:48,690 --> 00:04:52,740
that's pretty sophisticated or against

00:04:50,490 --> 00:04:56,220
here this is probably not really news to

00:04:52,740 --> 00:05:00,180
you I like to break it down to four main

00:04:56,220 --> 00:05:01,920
classes of machine the servers and the

00:05:00,180 --> 00:05:03,930
other large machines which obviously do

00:05:01,920 --> 00:05:07,620
database web file and all the other sort

00:05:03,930 --> 00:05:08,700
of servicing which goes on a lot of

00:05:07,620 --> 00:05:10,950
attention for scientific computing

00:05:08,700 --> 00:05:13,320
machines are the really big number

00:05:10,950 --> 00:05:17,700
crunchers which are very predominantly

00:05:13,320 --> 00:05:20,340
ia-64 based nowadays and most of the

00:05:17,700 --> 00:05:23,670
funding for kernel development is still

00:05:20,340 --> 00:05:27,390
in is comes from companies who are

00:05:23,670 --> 00:05:29,580
interested in markets which use Linux as

00:05:27,390 --> 00:05:32,940
a server so it's from the server market

00:05:29,580 --> 00:05:35,990
and that includes the hardware companies

00:05:32,940 --> 00:05:38,850
Intel I think is most prominently autos

00:05:35,990 --> 00:05:40,890
the software companies his customers use

00:05:38,850 --> 00:05:42,480
Linux that includes not only the distro

00:05:40,890 --> 00:05:45,300
so obviously RedHat and SUSE are a great

00:05:42,480 --> 00:05:48,380
kernel developers but it right also in

00:05:45,300 --> 00:05:52,920
that categorize companies such as Oracle

00:05:48,380 --> 00:05:54,240
IBM you have motivation to have Linux

00:05:52,920 --> 00:05:58,680
working as well as possible on their

00:05:54,240 --> 00:06:00,920
customers machines and we on the kernel

00:05:58,680 --> 00:06:03,240
team always get blamed of being

00:06:00,920 --> 00:06:05,580
excessively focused on the server side

00:06:03,240 --> 00:06:07,440
of things that's not true we're only

00:06:05,580 --> 00:06:14,640
excessively funded by the server side of

00:06:07,440 --> 00:06:15,120
things moving down the stack the desktop

00:06:14,640 --> 00:06:17,490
machines

00:06:15,120 --> 00:06:19,290
I believe it's less commercially

00:06:17,490 --> 00:06:25,140
important for major players in kernel

00:06:19,290 --> 00:06:27,450
space but to us who actually work on the

00:06:25,140 --> 00:06:30,240
kernel I mean we all run Linux on the

00:06:27,450 --> 00:06:32,640
desktop and most of the people who very

00:06:30,240 --> 00:06:35,400
freely email us are also desktop users

00:06:32,640 --> 00:06:36,690
so desktop gets a very high level of

00:06:35,400 --> 00:06:38,460
attention even though it's not as

00:06:36,690 --> 00:06:42,390
commercially significant as a service

00:06:38,460 --> 00:06:46,170
base consumer or what you might like to

00:06:42,390 --> 00:06:48,390
call large embedded I think you can see

00:06:46,170 --> 00:06:50,820
in my machines they often tend to be x86

00:06:48,390 --> 00:06:55,200
so they're basically a glorified PC with

00:06:50,820 --> 00:06:57,180
various bits taken off such as

00:06:55,200 --> 00:06:58,249
instrument control systems the digital

00:06:57,180 --> 00:07:01,759
video recorders

00:06:58,249 --> 00:07:05,719
and the PlayStation 3 etc so big

00:07:01,759 --> 00:07:07,849
embedded systems if you like the amount

00:07:05,719 --> 00:07:09,919
of funding which the kernel development

00:07:07,849 --> 00:07:12,379
gets from companies who are in this

00:07:09,919 --> 00:07:15,829
space is I think disproportionately

00:07:12,379 --> 00:07:18,619
small that's because I think people in

00:07:15,829 --> 00:07:20,749
the consumer space are afflicted by what

00:07:18,619 --> 00:07:25,789
I will call the embedded problem which

00:07:20,749 --> 00:07:28,719
is about three charts are hidden the

00:07:25,789 --> 00:07:32,059
fourth category I look at is embedded a

00:07:28,719 --> 00:07:34,099
lot of smaller devices listed some here

00:07:32,059 --> 00:07:36,799
cell phones PDAs your little wireless

00:07:34,099 --> 00:07:39,019
routers televisions I discovered the

00:07:36,799 --> 00:07:40,759
other day that I think every digital

00:07:39,019 --> 00:07:44,259
television that comes out of Asia now is

00:07:40,759 --> 00:07:47,509
Linux based all from Panasonic Sony

00:07:44,259 --> 00:07:49,189
Samsung all of those so I discovered my

00:07:47,509 --> 00:07:52,519
new flat-screen television as a Linux

00:07:49,189 --> 00:07:55,509
box and I didn't know I can press my

00:07:52,519 --> 00:07:58,069
kids it works

00:07:55,509 --> 00:07:59,719
camcorders lot little camcorders

00:07:58,069 --> 00:08:01,069
nowadays are running Linux a very old

00:07:59,719 --> 00:08:04,699
version of Linux but they're running

00:08:01,069 --> 00:08:06,259
Linux and the handhelds these tend to be

00:08:04,699 --> 00:08:07,610
not actually from the manufacturers it's

00:08:06,259 --> 00:08:09,019
people who've grabbed a handheld and

00:08:07,610 --> 00:08:13,039
then ripped out whatever was on it and

00:08:09,019 --> 00:08:16,039
put Linux in it the very smallest

00:08:13,039 --> 00:08:17,329
devices which run software are things

00:08:16,039 --> 00:08:20,089
like things like television or remote

00:08:17,329 --> 00:08:21,649
controls and the garage door openers run

00:08:20,089 --> 00:08:24,229
software I don't know that those things

00:08:21,649 --> 00:08:26,449
are not addressed by Linux there tend to

00:08:24,229 --> 00:08:27,469
be much more specialized and I think

00:08:26,449 --> 00:08:28,729
Linux is always going to be to

00:08:27,469 --> 00:08:32,990
heavyweight to get into the very

00:08:28,729 --> 00:08:35,959
smallest embedded devices most of these

00:08:32,990 --> 00:08:37,729
embedded systems they're usually non x86

00:08:35,959 --> 00:08:39,979
they often use a very cheap

00:08:37,729 --> 00:08:41,209
microprocessor a microprocessor which

00:08:39,979 --> 00:08:41,990
doesn't even have a memory management

00:08:41,209 --> 00:08:46,009
unit in it

00:08:41,990 --> 00:08:47,629
and they generally won't have a rotating

00:08:46,009 --> 00:08:52,459
disk of course a lot of them will have a

00:08:47,629 --> 00:08:54,620
flash disk and matter funding which we

00:08:52,459 --> 00:08:56,110
on the kernel team get from companies

00:08:54,620 --> 00:09:01,639
are doing embedded development is

00:08:56,110 --> 00:09:05,110
disproportionately small and maybe it

00:09:01,639 --> 00:09:05,110
was four shots ahead but we'll get onto

00:09:05,300 --> 00:09:09,500
and looking at what company's

00:09:07,339 --> 00:09:13,370
motivations are at a fun development of

00:09:09,500 --> 00:09:16,700
the Linux kernel I think there are three

00:09:13,370 --> 00:09:18,290
main categories here there are the

00:09:16,700 --> 00:09:22,190
hardware companies the people who

00:09:18,290 --> 00:09:22,970
actually sell adapters motherboards all

00:09:22,190 --> 00:09:24,830
that sort of thing

00:09:22,970 --> 00:09:27,140
which their customers wish to run Linux

00:09:24,830 --> 00:09:30,250
on and obviously they want Linux to run

00:09:27,140 --> 00:09:33,080
as well as possible on their hardware

00:09:30,250 --> 00:09:35,600
well the software vendors the IBM zero

00:09:33,080 --> 00:09:37,880
calls the Red Hat's and all the rest who

00:09:35,600 --> 00:09:44,690
sell software and services to those

00:09:37,880 --> 00:09:47,180
customers who want to eliminate the door

00:09:44,690 --> 00:09:50,050
that has Linux in it but the customers

00:09:47,180 --> 00:09:52,430
generally won't even see it

00:09:50,050 --> 00:09:55,220
I'd be a critical difference between

00:09:52,430 --> 00:09:56,990
these groups here is the hardware and

00:09:55,220 --> 00:09:59,029
software vendors their customers have an

00:09:56,990 --> 00:10:00,800
expectation that they will be upgrading

00:09:59,029 --> 00:10:02,240
the kernel version across the lifetime

00:10:00,800 --> 00:10:05,860
and we all know we've gone from Fedora

00:10:02,240 --> 00:10:08,420
core 5 to Fedora core 6 or l4 or l5 etc

00:10:05,860 --> 00:10:10,610
the customers expect to have to do that

00:10:08,420 --> 00:10:12,290
and their providers expect them to have

00:10:10,610 --> 00:10:13,579
to do that I think this is a critical

00:10:12,290 --> 00:10:17,149
difference that reflects back on the

00:10:13,579 --> 00:10:19,100
funding situation these companies have

00:10:17,149 --> 00:10:21,260
worked out if they want to get new

00:10:19,100 --> 00:10:22,990
features into their customers kernels

00:10:21,260 --> 00:10:27,040
from your hardware support new

00:10:22,990 --> 00:10:29,390
optimization features etc turns out

00:10:27,040 --> 00:10:30,680
finally after many years everybody's

00:10:29,390 --> 00:10:32,570
worked out the best way to get new

00:10:30,680 --> 00:10:36,320
features in to end customers hands is

00:10:32,570 --> 00:10:38,540
via the kernel or dog kernel used to be

00:10:36,320 --> 00:10:41,630
the case back in the 2.4 days for a

00:10:38,540 --> 00:10:43,459
number of reasons a lot of companies

00:10:41,630 --> 00:10:44,750
would just get their drivers straight in

00:10:43,459 --> 00:10:48,290
the Red Hat kernel straight into the

00:10:44,750 --> 00:10:52,490
suzer kernel and they have no real route

00:10:48,290 --> 00:10:54,350
up into mainline that all changed things

00:10:52,490 --> 00:10:55,670
nowadays people are much better many

00:10:54,350 --> 00:10:58,040
companies are much better against

00:10:55,670 --> 00:11:00,829
working against mainline and this has

00:10:58,040 --> 00:11:03,110
been aided by some policy changes at the

00:11:00,829 --> 00:11:05,060
major vendors particularly Red Hat

00:11:03,110 --> 00:11:06,829
nowadays I just have a strong tendency

00:11:05,060 --> 00:11:09,230
of hardware vendor comes up and says

00:11:06,829 --> 00:11:10,760
look at our driver they'll say no send

00:11:09,230 --> 00:11:11,730
it Andrew send it to lineThe send up to

00:11:10,760 --> 00:11:13,800
James

00:11:11,730 --> 00:11:17,399
and everybody's being very good about

00:11:13,800 --> 00:11:19,079
that I think the overhaul both quality

00:11:17,399 --> 00:11:22,760
and consistency of the kernel has been

00:11:19,079 --> 00:11:26,279
added for benefited from that process

00:11:22,760 --> 00:11:28,320
and the fact that people have worked out

00:11:26,279 --> 00:11:30,060
the best way to deliver features to

00:11:28,320 --> 00:11:32,970
their customers via kernel elorg

00:11:30,060 --> 00:11:36,029
that has helped us get funding for the

00:11:32,970 --> 00:11:41,610
kernel development mainly in the form of

00:11:36,029 --> 00:11:44,130
salaries now some of the device

00:11:41,610 --> 00:11:49,230
manufacturers not all of them they also

00:11:44,130 --> 00:11:51,360
have upgrade plans for example ps3 that

00:11:49,230 --> 00:11:55,050
I expect they will plan on revving their

00:11:51,360 --> 00:11:56,699
kernel sometime and future company I

00:11:55,050 --> 00:11:59,070
previously worked for djao who make

00:11:56,699 --> 00:12:00,839
personal video recorders also they

00:11:59,070 --> 00:12:03,180
upload their kernel version during

00:12:00,839 --> 00:12:06,320
development to pick up the new features

00:12:03,180 --> 00:12:06,320
which are coming out of kernel at all

00:12:07,130 --> 00:12:11,579
whereas for embedded companies I think

00:12:10,290 --> 00:12:13,560
the critical difference with an embedded

00:12:11,579 --> 00:12:15,000
company is once they ship the product

00:12:13,560 --> 00:12:17,760
they have absolutely no plan whatsoever

00:12:15,000 --> 00:12:18,810
to approve the kernel so if you're

00:12:17,760 --> 00:12:20,639
making a camco

00:12:18,810 --> 00:12:22,560
camcorder you'll golf and grab a two

00:12:20,639 --> 00:12:26,220
4:18 kernel or something perfectly

00:12:22,560 --> 00:12:30,990
ancient like that customize it ship it

00:12:26,220 --> 00:12:32,610
and you'll never upgrade that current so

00:12:30,990 --> 00:12:33,870
because you have no plan to upgrade the

00:12:32,610 --> 00:12:35,819
kernel on your device you really have

00:12:33,870 --> 00:12:37,800
very little motivation to get your

00:12:35,819 --> 00:12:40,139
features your changes fed back through

00:12:37,800 --> 00:12:41,639
the kernel or dog kernel and one of the

00:12:40,139 --> 00:12:43,019
main reasons people do that is the cost

00:12:41,639 --> 00:12:44,639
optimization so they don't have to

00:12:43,019 --> 00:12:46,740
permanently maintain the patches and

00:12:44,639 --> 00:12:48,959
retesting every time you dump it on

00:12:46,740 --> 00:12:49,230
Linux and Co and they look after it for

00:12:48,959 --> 00:12:51,420
you

00:12:49,230 --> 00:12:53,040
but that argument doesn't apply if you

00:12:51,420 --> 00:12:56,910
never intend to take that kernel back

00:12:53,040 --> 00:12:58,620
now from kernel at all other reasons

00:12:56,910 --> 00:13:00,230
were obviously relatively low funding

00:12:58,620 --> 00:13:03,110
from the embedded side of the world is

00:13:00,230 --> 00:13:05,850
it's a hard scrabble life

00:13:03,110 --> 00:13:07,170
the timelines time to mark is extremely

00:13:05,850 --> 00:13:12,779
short and there's not a lot of money in

00:13:07,170 --> 00:13:14,160
it the major in what we do so obviously

00:13:12,779 --> 00:13:16,110
see some involvement from embedded

00:13:14,160 --> 00:13:17,639
companies and I think a lot of that

00:13:16,110 --> 00:13:22,199
comes not from the people who actually

00:13:17,639 --> 00:13:23,960
shipped the products as much as the

00:13:22,199 --> 00:13:26,360
people who ship components

00:13:23,960 --> 00:13:28,430
to them say for example ah they don't

00:13:26,360 --> 00:13:30,470
make embedded products but they have

00:13:28,430 --> 00:13:32,150
commercially made of a commercial

00:13:30,470 --> 00:13:35,330
motivation have Linux run as well as

00:13:32,150 --> 00:13:37,220
possible on arm based machines so they

00:13:35,330 --> 00:13:41,390
can pick up as many device manufacturers

00:13:37,220 --> 00:13:44,000
using Linux as possible so arm do as an

00:13:41,390 --> 00:13:47,690
example do fund a Linux development for

00:13:44,000 --> 00:13:49,970
that region so despite the fact that

00:13:47,690 --> 00:13:53,900
embedded is under represented in the

00:13:49,970 --> 00:13:55,970
kernel development community will think

00:13:53,900 --> 00:13:59,240
it's cool that so many devices out there

00:13:55,970 --> 00:14:03,170
all the cell phones and television sets

00:13:59,240 --> 00:14:04,520
running Linux and so even though a lot

00:14:03,170 --> 00:14:06,020
of people who work on the kernel they're

00:14:04,520 --> 00:14:09,410
not really funded to work on to make

00:14:06,020 --> 00:14:11,500
embedded better we we do care about the

00:14:09,410 --> 00:14:15,440
quality of embedded support and we

00:14:11,500 --> 00:14:17,420
always review those big service patches

00:14:15,440 --> 00:14:19,700
with an eye on what is the impact of

00:14:17,420 --> 00:14:22,030
this on embedded will it hurt or are the

00:14:19,700 --> 00:14:22,030
users

00:14:25,600 --> 00:14:34,040
switching topics now this is basically a

00:14:30,980 --> 00:14:35,899
very partial overview but some of the

00:14:34,040 --> 00:14:40,550
things which are happening in the kernel

00:14:35,899 --> 00:14:42,410
development at present what I think is

00:14:40,550 --> 00:14:46,519
going to happen soon who's doing it why

00:14:42,410 --> 00:14:48,769
they're doing it and other stuff it's

00:14:46,519 --> 00:14:50,570
always hard for me to predict what's

00:14:48,769 --> 00:14:54,290
gonna be in the kernel and six or twelve

00:14:50,570 --> 00:14:55,910
months time I have no stuff I can't I

00:14:54,290 --> 00:14:57,470
don't have a quarterly planning meeting

00:14:55,910 --> 00:14:59,600
where we sit down and work out what the

00:14:57,470 --> 00:15:01,519
what features are going to develop over

00:14:59,600 --> 00:15:08,269
the next 12 months and assign heads to

00:15:01,519 --> 00:15:10,040
them so all I can say is what I see

00:15:08,269 --> 00:15:12,560
other people working on there people who

00:15:10,040 --> 00:15:14,209
do have engineers working for them I

00:15:12,560 --> 00:15:17,180
find it on the grapevine what they're

00:15:14,209 --> 00:15:19,339
working on and so my prediction is just

00:15:17,180 --> 00:15:25,310
based on what other people tell me they

00:15:19,339 --> 00:15:28,339
plan to work on on the server side and

00:15:25,310 --> 00:15:30,740
if any band is huge a lot there have

00:15:28,339 --> 00:15:32,600
been a lot of changes going in and large

00:15:30,740 --> 00:15:36,470
amount of changes continue to flow

00:15:32,600 --> 00:15:39,610
through in a surprising amount of work

00:15:36,470 --> 00:15:42,079
happening on core networking new

00:15:39,610 --> 00:15:44,360
protocols which I never knew existed are

00:15:42,079 --> 00:15:46,250
appearing in the stack and a lot of

00:15:44,360 --> 00:15:48,649
refactoring and restructuring of the

00:15:46,250 --> 00:15:51,380
network code base goes on new

00:15:48,649 --> 00:15:53,240
implementations of TCP flow control say

00:15:51,380 --> 00:15:59,600
entire new protocols sitting at the IP

00:15:53,240 --> 00:16:02,890
on top of IP etc storage I think most of

00:15:59,600 --> 00:16:06,920
the activity at present is in serial ata

00:16:02,890 --> 00:16:10,070
scuzzy in some ways is a bit stalled

00:16:06,920 --> 00:16:11,959
because of the sheer complexity of the

00:16:10,070 --> 00:16:15,350
scuzzy stack having to support so many

00:16:11,959 --> 00:16:19,250
old crufty old hardware and crafty old

00:16:15,350 --> 00:16:21,050
drivers that sit on top of them and when

00:16:19,250 --> 00:16:23,750
we look at things like serial Attached

00:16:21,050 --> 00:16:25,699
storage people are seriously considering

00:16:23,750 --> 00:16:30,010
bypassing the scuzzy stack to a large

00:16:25,699 --> 00:16:30,010
extent to avoid all of that legacy

00:16:30,070 --> 00:16:33,920
tremendous amount of work happening in

00:16:31,880 --> 00:16:35,870
Umarov the past two or three years it's

00:16:33,920 --> 00:16:38,530
very much been driven by SGI who

00:16:35,870 --> 00:16:45,590
recently I believe booted Linux and

00:16:38,530 --> 00:16:47,690
4096 CPU machine but a nice thing about

00:16:45,590 --> 00:16:50,360
the work which SGI is doing to improve

00:16:47,690 --> 00:16:53,120
Numa is that it's also beneficial for

00:16:50,360 --> 00:16:55,340
the Opteron machines locked ROM machines

00:16:53,120 --> 00:16:57,380
which are also NEMA and it tends to be

00:16:55,340 --> 00:16:59,030
the case that an uma and Vance Minh if

00:16:57,380 --> 00:17:01,400
it's a good one will also help pass

00:16:59,030 --> 00:17:03,170
scalability and performance on a boring

00:17:01,400 --> 00:17:08,290
old multi-core or symmetrical multi

00:17:03,170 --> 00:17:10,850
processing machine virtualization

00:17:08,290 --> 00:17:12,410
obviously as the great war between Zen

00:17:10,850 --> 00:17:13,810
and VMware which has been going with

00:17:12,410 --> 00:17:16,040
about three years and the war between

00:17:13,810 --> 00:17:18,530
Zen and the kernel team and the wall

00:17:16,040 --> 00:17:21,430
between everybody and everybody else and

00:17:18,530 --> 00:17:24,980
that becomes KVM and they got in first

00:17:21,430 --> 00:17:28,090
KVM came out of nowhere but israel

00:17:24,980 --> 00:17:33,800
actually but metaphorically no way and

00:17:28,090 --> 00:17:36,590
was an easy merge VMware support has it

00:17:33,800 --> 00:17:40,430
appeared in two 6:21 which was released

00:17:36,590 --> 00:17:43,520
a week ago I expect support for Zen

00:17:40,430 --> 00:17:45,440
domain you will be in - 622 although

00:17:43,520 --> 00:17:48,830
it's being a bit of a difficult birth at

00:17:45,440 --> 00:17:50,270
present and of course rusty Russell

00:17:48,830 --> 00:17:51,290
decided none of that was any good and

00:17:50,270 --> 00:17:53,570
went off and write his own

00:17:51,290 --> 00:17:57,100
implementation of both the hypervisor

00:17:53,570 --> 00:18:01,280
from the it's Linux on Linux so he has a

00:17:57,100 --> 00:18:04,700
very simple client host side and guest

00:18:01,280 --> 00:18:06,620
side and no versioning between nor

00:18:04,700 --> 00:18:11,540
anything so if you try and run at to 620

00:18:06,620 --> 00:18:14,120
guest on a to 621 host it won't work but

00:18:11,540 --> 00:18:16,250
it's basically L guest is supposed to be

00:18:14,120 --> 00:18:18,890
a minimal skeleton how to do it code

00:18:16,250 --> 00:18:24,400
easy to hack on and I'd expect our guest

00:18:18,890 --> 00:18:28,400
will appear into 6:22 tremendous work

00:18:24,400 --> 00:18:32,300
going on in containerization this is a

00:18:28,400 --> 00:18:34,970
very difficult topic because it means so

00:18:32,300 --> 00:18:37,640
many things to so needed from people you

00:18:34,970 --> 00:18:39,260
have the V server the virtual server

00:18:37,640 --> 00:18:41,950
type people who want to take a single

00:18:39,260 --> 00:18:44,210
machine and partition that up against a

00:18:41,950 --> 00:18:46,040
couple of hundred different customers

00:18:44,210 --> 00:18:47,840
who are all run their own version of

00:18:46,040 --> 00:18:50,470
Apache and stop by everybody else's

00:18:47,840 --> 00:18:50,470
version of the pageant

00:18:51,000 --> 00:18:56,320
on the other hand you have the

00:18:53,170 --> 00:18:59,290
enterprise guys who want to have

00:18:56,320 --> 00:19:01,870
resource management so you can have your

00:18:59,290 --> 00:19:03,190
your backup suddenly fires fires often

00:19:01,870 --> 00:19:07,150
you don't want it to cause excessive

00:19:03,190 --> 00:19:08,740
latency from your database query engine

00:19:07,150 --> 00:19:10,600
so you want to be able to partition

00:19:08,740 --> 00:19:11,860
machine and avoid interaction between

00:19:10,600 --> 00:19:12,810
different jobs running on the same

00:19:11,860 --> 00:19:17,860
machine

00:19:12,810 --> 00:19:20,470
so that's resource management other

00:19:17,860 --> 00:19:22,480
groups of people apparently there's some

00:19:20,470 --> 00:19:24,360
time between containerization and high

00:19:22,480 --> 00:19:27,000
availability which I've never understood

00:19:24,360 --> 00:19:30,460
I think partially it could be do with

00:19:27,000 --> 00:19:33,430
migrating migrating jobs from one

00:19:30,460 --> 00:19:35,110
machine to the other so whole budget

00:19:33,430 --> 00:19:36,480
people with different requirements all

00:19:35,110 --> 00:19:39,340
of which fall under the category of

00:19:36,480 --> 00:19:40,300
containerization and the requirements

00:19:39,340 --> 00:19:41,680
are a little bit different their

00:19:40,300 --> 00:19:43,090
implementations a bit different and a

00:19:41,680 --> 00:19:44,800
lot of them have gone a long way down

00:19:43,090 --> 00:19:48,400
the track of having implementations I

00:19:44,800 --> 00:19:50,440
mean the openvz guys they've been

00:19:48,400 --> 00:19:51,790
shipping the product to many customers

00:19:50,440 --> 00:19:53,400
and they've got hundreds of thousands of

00:19:51,790 --> 00:19:59,020
machines are running openvz

00:19:53,400 --> 00:20:00,910
so their ability to accept the changes

00:19:59,020 --> 00:20:02,290
which other stakeholders are going to

00:20:00,910 --> 00:20:04,930
force them on is it's pretty limited

00:20:02,290 --> 00:20:06,430
because they obviously when most Beco

00:20:04,930 --> 00:20:07,720
gets in the kernel adorab they want it

00:20:06,430 --> 00:20:11,470
to be regionally compatible with what

00:20:07,720 --> 00:20:13,300
they're already shipping so we've been

00:20:11,470 --> 00:20:17,680
dancing around the containerization

00:20:13,300 --> 00:20:19,150
issue for a couple of years we are

00:20:17,680 --> 00:20:20,530
converging I think most of the

00:20:19,150 --> 00:20:22,780
stakeholders are playing together quite

00:20:20,530 --> 00:20:24,340
nicely but it's a complex problem some

00:20:22,780 --> 00:20:28,680
of the bits and pieces have gone into

00:20:24,340 --> 00:20:31,690
the tree the many in terms of

00:20:28,680 --> 00:20:36,130
virtualization of particular global

00:20:31,690 --> 00:20:39,010
resources within the kernel and right

00:20:36,130 --> 00:20:41,950
now everybody seems pretty happy with

00:20:39,010 --> 00:20:45,340
poor Minaj's patches Paul's at Google

00:20:41,950 --> 00:20:48,640
he's done some work on this and unless

00:20:45,340 --> 00:20:50,560
somebody makes serious objections for

00:20:48,640 --> 00:20:52,270
that approach I expect we'll be going

00:20:50,560 --> 00:20:53,530
down that track using pool stuff and

00:20:52,270 --> 00:20:55,710
then let everybody else build on top of

00:20:53,530 --> 00:20:55,710
that

00:20:56,540 --> 00:21:01,430
resource management I touched on before

00:20:58,490 --> 00:21:02,930
this is the ability to not have one job

00:21:01,430 --> 00:21:04,340
running the machine trash another one

00:21:02,930 --> 00:21:09,050
get some degree of quality of service

00:21:04,340 --> 00:21:11,980
between different unrelated jobs IBM for

00:21:09,050 --> 00:21:14,800
many years was pushing su-kam the kernel

00:21:11,980 --> 00:21:17,720
class-based kernel resource manager and

00:21:14,800 --> 00:21:19,280
that went through many generations each

00:21:17,720 --> 00:21:21,260
one about half the size of the previous

00:21:19,280 --> 00:21:24,080
one in response to what we politely call

00:21:21,260 --> 00:21:26,090
feedback to reach the stage where it was

00:21:24,080 --> 00:21:29,210
actually quite a sane looking patch set

00:21:26,090 --> 00:21:30,740
but now most of their developers they're

00:21:29,210 --> 00:21:33,830
slotting in there or slotting in behind

00:21:30,740 --> 00:21:36,800
the containerization effort which will

00:21:33,830 --> 00:21:40,880
pretty much meet their requirements if

00:21:36,800 --> 00:21:44,270
and when we ever get them k exact and

00:21:40,880 --> 00:21:46,820
kdump kdump is important enterprise

00:21:44,270 --> 00:21:48,410
feature it's the ability to generate a

00:21:46,820 --> 00:21:50,450
kernel crash dump it kernel goes up

00:21:48,410 --> 00:21:52,760
Siddal then go and spatter its guts on

00:21:50,450 --> 00:21:54,290
the hard disk so that we can then pick

00:21:52,760 --> 00:21:57,620
up the result after the reboot and

00:21:54,290 --> 00:21:59,300
analyze why the kernel crashed there

00:21:57,620 --> 00:22:02,090
been numerous implementations have done

00:21:59,300 --> 00:22:07,070
this done out of tree all of them

00:22:02,090 --> 00:22:09,220
involved the crashed kernel writing a

00:22:07,070 --> 00:22:11,810
copy of itself to the network or to disk

00:22:09,220 --> 00:22:13,610
that was generally never acceptable to

00:22:11,810 --> 00:22:15,080
us Luna's always thought it was stupid

00:22:13,610 --> 00:22:17,030
you had it you have a kernel which is

00:22:15,080 --> 00:22:18,440
already toast to attempt to get that to

00:22:17,030 --> 00:22:23,450
write to disk as a very dangerous thing

00:22:18,440 --> 00:22:25,220
so we took a new approach and it was

00:22:23,450 --> 00:22:27,170
completely vaporware but we decided to

00:22:25,220 --> 00:22:30,890
do this two years ago kernel summit in

00:22:27,170 --> 00:22:33,410
ottawa to use k exec instead k exec is

00:22:30,890 --> 00:22:35,330
ability for linux to load a new copy of

00:22:33,410 --> 00:22:36,680
the kernel into itself and jump to it so

00:22:35,330 --> 00:22:40,790
you can basically do a reboot in

00:22:36,680 --> 00:22:42,740
fraction of a second where we modified

00:22:40,790 --> 00:22:44,330
care exec was that once you jumped into

00:22:42,740 --> 00:22:46,430
this new kernel we would leave the old

00:22:44,330 --> 00:22:49,910
kernel alone not touch that memory and

00:22:46,430 --> 00:22:52,280
then in the new kernel we have a little

00:22:49,910 --> 00:22:55,070
slash dev mode which you can access all

00:22:52,280 --> 00:22:56,480
the old kernels memory so the kernel

00:22:55,070 --> 00:22:59,030
will crash will then jump into the

00:22:56,480 --> 00:23:01,370
preloaded new kernel and then the new

00:22:59,030 --> 00:23:04,250
kernel which comes up fresh clean hasn't

00:23:01,370 --> 00:23:05,930
trashed its data structures that kernel

00:23:04,250 --> 00:23:09,039
will then write the crashed kernel to

00:23:05,930 --> 00:23:11,960
disk or across an

00:23:09,039 --> 00:23:13,490
and that's been merged a lot of people

00:23:11,960 --> 00:23:15,200
are working on it and the various

00:23:13,490 --> 00:23:20,870
vendors enterprise people are slowly

00:23:15,200 --> 00:23:21,470
slotting behind it my secret plan with

00:23:20,870 --> 00:23:24,230
kdump

00:23:21,470 --> 00:23:25,820
is I would very much like we developers

00:23:24,230 --> 00:23:27,830
on the kernel team to be able to get a

00:23:25,820 --> 00:23:30,799
crash image from people whose goal has

00:23:27,830 --> 00:23:32,630
gone tits up because at present all you

00:23:30,799 --> 00:23:36,769
get is loot streisand it's always were

00:23:32,630 --> 00:23:38,600
draped and and you don't have the symbol

00:23:36,769 --> 00:23:41,720
table it's very hard to work out exactly

00:23:38,600 --> 00:23:42,320
what line you're crashing on etc so it

00:23:41,720 --> 00:23:45,110
would be lovely

00:23:42,320 --> 00:23:46,669
one day when someone's Colonel crash

00:23:45,110 --> 00:23:49,549
they can say oh it crashed and by the

00:23:46,669 --> 00:23:51,200
way here is my crash dump so you can

00:23:49,549 --> 00:23:54,200
then fired up in gdb and have a look at

00:23:51,200 --> 00:23:56,269
the data structures so I've UK done even

00:23:54,200 --> 00:23:58,639
though it's an enterprise feature it

00:23:56,269 --> 00:24:02,389
could be quite useful for the general

00:23:58,639 --> 00:24:04,279
kernel development effort and now I'm

00:24:02,389 --> 00:24:06,169
not interested in people's page cache I

00:24:04,279 --> 00:24:09,320
don't want to see your password files

00:24:06,169 --> 00:24:11,510
and whatever else you have in memory so

00:24:09,320 --> 00:24:12,769
we expect kdump will not dump that part

00:24:11,510 --> 00:24:14,750
of memory which is the great bulk of

00:24:12,769 --> 00:24:16,460
memory we're not interested in user user

00:24:14,750 --> 00:24:22,159
data we're only interested in kernel

00:24:16,460 --> 00:24:24,830
data K probes that stability effectively

00:24:22,159 --> 00:24:30,559
of a kernel module to set a trap point

00:24:24,830 --> 00:24:32,649
somewhere in the kernel and main reason

00:24:30,559 --> 00:24:35,630
for that is for advanced instrumentation

00:24:32,649 --> 00:24:39,230
it's supposedly our answer to the

00:24:35,630 --> 00:24:40,940
Solaris D trace feature system tap is

00:24:39,230 --> 00:24:42,950
the user space component of that and

00:24:40,940 --> 00:24:46,960
it's supported by Red Hat and various

00:24:42,950 --> 00:24:49,460
other vendors the way it works is you

00:24:46,960 --> 00:24:51,230
you write a little script in a funny C

00:24:49,460 --> 00:24:52,760
like programming language can you feed

00:24:51,230 --> 00:24:55,700
that into system tap tools which then

00:24:52,760 --> 00:24:58,010
will turn it into a kernel module low

00:24:55,700 --> 00:25:00,470
that module into your kernel and then it

00:24:58,010 --> 00:25:02,360
will hook itself into the core kernel by

00:25:00,470 --> 00:25:06,049
inserting trap points using the K probes

00:25:02,360 --> 00:25:07,549
facility and then we have high bandwidth

00:25:06,049 --> 00:25:09,889
interfaces coming out of that module to

00:25:07,549 --> 00:25:11,659
user space so if you want to get in and

00:25:09,889 --> 00:25:13,880
say I want to trace context switches or

00:25:11,659 --> 00:25:17,240
I want to trace disk i/o or trace dip

00:25:13,880 --> 00:25:19,490
this particular line you can do so all

00:25:17,240 --> 00:25:20,540
in this programming language which

00:25:19,490 --> 00:25:22,160
systemtap provides

00:25:20,540 --> 00:25:24,820
I think it has pretty graphical user

00:25:22,160 --> 00:25:27,560
interfaces and things as well

00:25:24,820 --> 00:25:30,320
difficult project but the vendors seem

00:25:27,560 --> 00:25:34,940
committed to it seems to be going fairly

00:25:30,320 --> 00:25:38,810
well ext4

00:25:34,940 --> 00:25:42,890
I think file systems generally is slowly

00:25:38,810 --> 00:25:47,210
turning into a weak spot for Linux ext3

00:25:42,890 --> 00:25:49,730
is but slow good I believe has limits on

00:25:47,210 --> 00:25:51,740
device sizes and it's just generally not

00:25:49,730 --> 00:25:59,090
particularly 21st second century

00:25:51,740 --> 00:26:00,980
technology the xt4 is well XFS I think

00:25:59,090 --> 00:26:04,970
is generally a better file system

00:26:00,980 --> 00:26:07,490
it's creepy how well XFS can do file

00:26:04,970 --> 00:26:10,460
layout for the high-end machines it is

00:26:07,490 --> 00:26:11,780
extremely good there are and there have

00:26:10,460 --> 00:26:13,520
been various times when we found

00:26:11,780 --> 00:26:15,110
problems with ext3 or where somebody

00:26:13,520 --> 00:26:17,960
tosses are really truly were clear that

00:26:15,110 --> 00:26:21,680
it does really bad stuff I think aha but

00:26:17,960 --> 00:26:25,550
XFS can't do this and damn it does every

00:26:21,680 --> 00:26:28,220
time so a lot of work has gone in Exodus

00:26:25,550 --> 00:26:29,560
it's fiendishly complex and nobody

00:26:28,220 --> 00:26:32,480
understands it

00:26:29,560 --> 00:26:34,670
unfortunately the vendors for which we

00:26:32,480 --> 00:26:37,960
mean principally Red Hat and Sousa seem

00:26:34,670 --> 00:26:41,180
very reluctant to support except s I

00:26:37,960 --> 00:26:42,470
think the reasons for this are they

00:26:41,180 --> 00:26:44,930
don't have any engineers who can

00:26:42,470 --> 00:26:47,420
understand it and the attractive thing

00:26:44,930 --> 00:26:49,250
about ext3 is that it is understood and

00:26:47,420 --> 00:26:52,460
supported by engineers from a lot of

00:26:49,250 --> 00:26:54,220
different companies so as far as I can

00:26:52,460 --> 00:26:57,590
tell all the vendors have decided to

00:26:54,220 --> 00:27:01,940
hook up behind ext4 rather than

00:26:57,590 --> 00:27:04,370
investing in XFS ext4 has all the new

00:27:01,940 --> 00:27:09,260
features extent base allocation it will

00:27:04,370 --> 00:27:12,080
have delayed allocation it large device

00:27:09,260 --> 00:27:13,700
support etc I don't there's any reason

00:27:12,080 --> 00:27:16,250
for thinking it would be a lot faster

00:27:13,700 --> 00:27:19,460
than ext3 in a lot of cases but it

00:27:16,250 --> 00:27:23,710
basically for certain easy workloads and

00:27:19,460 --> 00:27:26,150
for large devices it will fill the gap

00:27:23,710 --> 00:27:27,590
that I suspect will still have

00:27:26,150 --> 00:27:29,890
significant performance problems with

00:27:27,590 --> 00:27:32,510
significant workloads on the XD for

00:27:29,890 --> 00:27:33,360
basically I think we need a new file

00:27:32,510 --> 00:27:34,590
system

00:27:33,360 --> 00:27:40,710
I just don't know where it's gonna come

00:27:34,590 --> 00:27:50,310
from very simple multi-core people yes

00:27:40,710 --> 00:27:54,090
Daniel ZFS I could talk about son at

00:27:50,310 --> 00:27:56,610
length if you like um well ZFS is the

00:27:54,090 --> 00:27:59,270
licen licensing incompatible so one

00:27:56,610 --> 00:27:59,270
would have to start again

00:28:02,630 --> 00:28:09,030
things were doing for desktop machines

00:28:05,090 --> 00:28:14,520
hot-plug ability or actually it's like

00:28:09,030 --> 00:28:18,090
then crash ability hop like a being

00:28:14,520 --> 00:28:19,440
hopping of CPUs and modes and memory is

00:28:18,090 --> 00:28:20,700
not a desktop feature that should have

00:28:19,440 --> 00:28:23,370
been on the previous chart which I

00:28:20,700 --> 00:28:25,670
apologize hot-plug ability obviously has

00:28:23,370 --> 00:28:30,510
many things like a car bus devices

00:28:25,670 --> 00:28:32,580
firewire devices and USB devices all the

00:28:30,510 --> 00:28:34,020
work going on power management it's

00:28:32,580 --> 00:28:35,520
still pretty stupid about power

00:28:34,020 --> 00:28:39,780
management we said really support I know

00:28:35,520 --> 00:28:42,300
two states that's often on I suspect one

00:28:39,780 --> 00:28:43,920
day more pressure will come upon the

00:28:42,300 --> 00:28:45,600
operating system community due to have

00:28:43,920 --> 00:28:47,310
smarter states than that like if my

00:28:45,600 --> 00:28:49,080
network card hasn't sent any packets for

00:28:47,310 --> 00:28:52,110
the past ten milliseconds well why is it

00:28:49,080 --> 00:28:54,030
still fully powered up but I really

00:28:52,110 --> 00:28:55,560
haven't seen any threat that we're gonna

00:28:54,030 --> 00:28:56,160
have to do that yet but I expect it'll

00:28:55,560 --> 00:28:58,380
happen one day

00:28:56,160 --> 00:29:00,390
just bring devices into a lower power

00:28:58,380 --> 00:29:01,880
state which is not off we don't have

00:29:00,390 --> 00:29:03,870
much infrastructure support for that

00:29:01,880 --> 00:29:06,110
we're having trouble getting off and on

00:29:03,870 --> 00:29:06,110
working

00:29:08,169 --> 00:29:14,419
it's always the biases faults never

00:29:10,669 --> 00:29:16,059
alphabet' framebuffer drivers it's one

00:29:14,419 --> 00:29:19,880
of those subsystems I know nothing about

00:29:16,059 --> 00:29:21,980
it just enormous amount of activity

00:29:19,880 --> 00:29:23,389
coming out of the new drivers a lot of

00:29:21,980 --> 00:29:23,929
maintenance work or fix up happening

00:29:23,389 --> 00:29:27,380
there

00:29:23,929 --> 00:29:30,289
we have a wonderful maintainer Tony de

00:29:27,380 --> 00:29:32,539
players who is a physician living in the

00:29:30,289 --> 00:29:34,190
Philippines there's no interest in

00:29:32,539 --> 00:29:36,049
working for Linda company just simply

00:29:34,190 --> 00:29:38,720
spend all this time ignore his patients

00:29:36,049 --> 00:29:40,360
and working on frame buffer drivers he's

00:29:38,720 --> 00:29:43,789
great

00:29:40,360 --> 00:29:46,309
direct rendering drivers this is the 3d

00:29:43,789 --> 00:29:47,450
stuff obsolete all sorts of problems in

00:29:46,309 --> 00:29:49,549
this area to do with lack of

00:29:47,450 --> 00:29:53,240
specifications and certain close source

00:29:49,549 --> 00:29:55,399
drivers from certain companies again a

00:29:53,240 --> 00:29:59,000
great maintainer there David le is of

00:29:55,399 --> 00:30:03,730
course in Australia doing tremendous

00:29:59,000 --> 00:30:06,830
amount of work been the input system a

00:30:03,730 --> 00:30:08,330
whole plethora of input devices popular

00:30:06,830 --> 00:30:10,130
source of crashes and hangs and things

00:30:08,330 --> 00:30:12,950
like that but again a lot of development

00:30:10,130 --> 00:30:14,659
there strong maintainer sound is taken

00:30:12,950 --> 00:30:17,899
care of by a couple of Sousa engineers

00:30:14,659 --> 00:30:19,669
with the ELSA stack USBs got about a

00:30:17,899 --> 00:30:23,320
thousand different developers each one

00:30:19,669 --> 00:30:27,080
about a thousand devices to take care of

00:30:23,320 --> 00:30:28,940
1394 the old fire worse tech this has

00:30:27,080 --> 00:30:31,700
been a problem child for a long time he

00:30:28,940 --> 00:30:33,350
used to be a long time at running fire

00:30:31,700 --> 00:30:37,789
wire on SMP was a good way to reboot

00:30:33,350 --> 00:30:41,029
your machine but Stefan's done a lot of

00:30:37,789 --> 00:30:43,490
sterling work there and a new fire wire

00:30:41,029 --> 00:30:45,679
stack and I think a complete new fire

00:30:43,490 --> 00:30:47,120
stack was central in us for moving today

00:30:45,679 --> 00:30:49,880
but I haven't checked whether actually

00:30:47,120 --> 00:30:52,960
most it so the plan there is to take the

00:30:49,880 --> 00:30:55,070
new fire wire stack build it up to the

00:30:52,960 --> 00:30:57,639
same level of function old as the old

00:30:55,070 --> 00:30:59,990
one and then throw the old one away and

00:30:57,639 --> 00:31:02,330
even though the kernel API is a bit

00:30:59,990 --> 00:31:05,600
different they assure me that everybody

00:31:02,330 --> 00:31:08,000
uses user space library and will be API

00:31:05,600 --> 00:31:09,289
compatible at that level so if you're

00:31:08,000 --> 00:31:13,130
programming directly to the system

00:31:09,289 --> 00:31:15,559
called API sorry you should have used

00:31:13,130 --> 00:31:18,620
the library anyway

00:31:15,559 --> 00:31:21,440
a lot of our work with the desktop

00:31:18,620 --> 00:31:24,980
concerns latency this is what I call the

00:31:21,440 --> 00:31:27,259
squeaky wheel problem where people who'd

00:31:24,980 --> 00:31:29,389
never say oh that was 100 millisecond

00:31:27,259 --> 00:31:30,710
glitch I need to email Ingo and Andrew

00:31:29,389 --> 00:31:32,779
and everybody else at that my hundredth

00:31:30,710 --> 00:31:35,960
of a second glitch so we have a lot of

00:31:32,779 --> 00:31:37,759
squeaky squeaky gates and on the mailing

00:31:35,960 --> 00:31:39,350
list and so a lot of work happens this

00:31:37,759 --> 00:31:42,710
is people who complain a lot

00:31:39,350 --> 00:31:45,799
squeaky gate gets the oil so a lot of

00:31:42,710 --> 00:31:47,240
work is happening with interactivity now

00:31:45,799 --> 00:31:49,009
I must admit I had a report the other

00:31:47,240 --> 00:31:51,499
day that guys machine went to lunch for

00:31:49,009 --> 00:31:53,509
20 minutes so he had a right to squeak

00:31:51,499 --> 00:31:57,379
but not all of our interactivity

00:31:53,509 --> 00:31:59,929
problems are that bad but we continue to

00:31:57,379 --> 00:32:01,820
work on the interactivity and this is in

00:31:59,929 --> 00:32:04,249
three main areas the i/o scheduling

00:32:01,820 --> 00:32:07,460
generally the prioritization of reads

00:32:04,249 --> 00:32:09,379
versus writes on the disk our dirty

00:32:07,460 --> 00:32:11,389
memory write out policy which right now

00:32:09,379 --> 00:32:14,840
I politely say is optimized for

00:32:11,389 --> 00:32:16,759
performance rather than latency and the

00:32:14,840 --> 00:32:18,529
CPU scheduler which everybody always

00:32:16,759 --> 00:32:19,789
seems to have an opinion about even if

00:32:18,529 --> 00:32:24,289
they don't have their own version of a

00:32:19,789 --> 00:32:26,720
CPU scheduling dirty memory right out is

00:32:24,289 --> 00:32:27,919
I think probably our biggest problem

00:32:26,720 --> 00:32:30,289
there are certain situations in which

00:32:27,919 --> 00:32:33,139
the kernel will perform very badly it

00:32:30,289 --> 00:32:35,840
doesn't just affect just desktop

00:32:33,139 --> 00:32:37,789
machines that can also be a quality of

00:32:35,840 --> 00:32:40,519
our service issue for server class

00:32:37,789 --> 00:32:41,899
machines several people are working on

00:32:40,519 --> 00:32:43,970
that from totally different directions

00:32:41,899 --> 00:32:47,659
and none of them are quite got it right

00:32:43,970 --> 00:32:49,309
yet it's a tough problem the other thing

00:32:47,659 --> 00:32:50,749
when people say oh you don't care about

00:32:49,309 --> 00:32:52,940
the desktop I'll tell them we put in

00:32:50,749 --> 00:32:54,799
identifier I haven't actually done any

00:32:52,940 --> 00:32:56,869
work on I'll notify or F notify for the

00:32:54,799 --> 00:32:58,509
past year or so but it's a fancier way

00:32:56,869 --> 00:33:00,860
in which the kernel can deliver

00:32:58,509 --> 00:33:02,570
notification to use a space that's a

00:33:00,860 --> 00:33:04,730
file has changed or been added or

00:33:02,570 --> 00:33:11,029
deleted or read from so that you can

00:33:04,730 --> 00:33:12,440
update it in your little GUI window few

00:33:11,029 --> 00:33:13,820
technologies going in that are more

00:33:12,440 --> 00:33:16,190
targeted at the smaller machines

00:33:13,820 --> 00:33:18,590
consumer and embedded the ones we

00:33:16,190 --> 00:33:21,679
emerged into to 620 of course of the

00:33:18,590 --> 00:33:24,889
dynamic ticks and hores timers

00:33:21,679 --> 00:33:26,269
I used to work AIX guy his jaw hit the

00:33:24,889 --> 00:33:27,309
floor when he found out the leaks are

00:33:26,269 --> 00:33:28,809
still doing interrupt

00:33:27,309 --> 00:33:30,639
retain memory second says why you do

00:33:28,809 --> 00:33:34,870
that if there's nothing to do what's

00:33:30,639 --> 00:33:36,490
hard but it was hard but now we do have

00:33:34,870 --> 00:33:38,200
dynamic tics which works on some

00:33:36,490 --> 00:33:39,639
machines but it's very good at forming

00:33:38,200 --> 00:33:43,389
back to the old scheme if it doesn't

00:33:39,639 --> 00:33:45,730
work out and it will basically the whole

00:33:43,389 --> 00:33:47,620
machine will go to sleep if there's

00:33:45,730 --> 00:33:48,999
nothing to do for another 1.1 seconds

00:33:47,620 --> 00:33:52,299
the whole machine will just go to sleep

00:33:48,999 --> 00:33:55,919
and won't wake up for 1.1 seconds rather

00:33:52,299 --> 00:33:58,360
than waking up every 10 milliseconds and

00:33:55,919 --> 00:34:00,639
leverage on the back of that because we

00:33:58,360 --> 00:34:02,049
are now have instead of program your

00:34:00,639 --> 00:34:03,610
timer to go be 10 milliseconds we

00:34:02,049 --> 00:34:06,220
program it to go off exactly when we

00:34:03,610 --> 00:34:07,929
need it this gives us much higher

00:34:06,220 --> 00:34:09,940
resolution timers than we previously had

00:34:07,929 --> 00:34:12,069
so we've gone from the 10 millisecond

00:34:09,940 --> 00:34:13,480
resolution down to something pretty

00:34:12,069 --> 00:34:17,109
arbitrary depending on what you are a

00:34:13,480 --> 00:34:18,700
clock our Doyle support the people who

00:34:17,109 --> 00:34:20,649
are really crying out for this were the

00:34:18,700 --> 00:34:22,690
One Laptop Per child who do not want to

00:34:20,649 --> 00:34:25,270
wake their machine up every 10

00:34:22,690 --> 00:34:28,030
milliseconds and it's a significant

00:34:25,270 --> 00:34:29,710
power saving for the OLPC but a lot of

00:34:28,030 --> 00:34:33,569
embedded systems are really aggressive

00:34:29,710 --> 00:34:33,569
power requirements do like that feature

00:34:33,869 --> 00:34:40,149
2 6 coma I think it has got better I

00:34:36,849 --> 00:34:41,950
think this smallest build you can do on

00:34:40,149 --> 00:34:46,119
a tiny little unit process machine is

00:34:41,950 --> 00:34:48,129
still a bit larger than 2 for Colonel we

00:34:46,119 --> 00:34:50,169
are concerned about it we do continually

00:34:48,129 --> 00:34:51,550
try to counteract it but they just these

00:34:50,169 --> 00:34:54,129
things happen it's been a very slow

00:34:51,550 --> 00:34:56,319
growth one thing we put in recently

00:34:54,129 --> 00:34:57,790
finally was the ability to just make the

00:34:56,319 --> 00:34:59,650
whole block layer go away the entire

00:34:57,790 --> 00:35:01,270
support for block devices and buffer

00:34:59,650 --> 00:35:03,220
heads and disk i/o and all that sort of

00:35:01,270 --> 00:35:04,930
stuff you can just disappear that

00:35:03,220 --> 00:35:07,470
completely from your kernel build if you

00:35:04,930 --> 00:35:11,050
do not have disks in the system

00:35:07,470 --> 00:35:13,420
no MMU support support mm ulis machines

00:35:11,050 --> 00:35:15,730
is being maintained mainly by Dave house

00:35:13,420 --> 00:35:19,240
at Red Hat and as far as I know that's

00:35:15,730 --> 00:35:22,030
working well funny little CPU

00:35:19,240 --> 00:35:25,930
architectures keep on turning up frv AVR

00:35:22,030 --> 00:35:27,670
32 from I forget who that's from

00:35:25,930 --> 00:35:31,599
Blackfin comes from hat mill that will

00:35:27,670 --> 00:35:35,560
be in - 622 a number of these no MMU and

00:35:31,599 --> 00:35:37,690
some of them are either no me or MMU

00:35:35,560 --> 00:35:40,420
various bus technologies and i/o

00:35:37,690 --> 00:35:43,030
technologies that happen spi being

00:35:40,420 --> 00:35:48,100
actively maintained by people who are

00:35:43,030 --> 00:35:49,540
also working in the embedded area very

00:35:48,100 --> 00:35:52,420
important to embed it is Ingo Molnar

00:35:49,540 --> 00:35:55,030
real-time tree which is a separate patch

00:35:52,420 --> 00:35:56,590
set from the kernel which contains all

00:35:55,030 --> 00:36:01,120
sorts of features in a panel it does

00:35:56,590 --> 00:36:02,200
real-time hard real-time very well but

00:36:01,120 --> 00:36:04,480
I've been a lot of technologies that

00:36:02,200 --> 00:36:06,790
available out of tree and add-on monster

00:36:04,480 --> 00:36:09,390
patches or little operating systems

00:36:06,790 --> 00:36:12,910
which run underneath Linux news Linux as

00:36:09,390 --> 00:36:14,200
one of their applications but I think a

00:36:12,910 --> 00:36:17,170
lot of those are sort of falling by the

00:36:14,200 --> 00:36:19,750
wayside now as the serious real-time

00:36:17,170 --> 00:36:22,000
vendors of are actually shipping in goes

00:36:19,750 --> 00:36:24,820
tree and as we're gradually moving

00:36:22,000 --> 00:36:26,560
features a Domingos tree into a mainline

00:36:24,820 --> 00:36:28,360
kernel a lot of things that come across

00:36:26,560 --> 00:36:31,810
the mingoes tree it's sort of a testing

00:36:28,360 --> 00:36:34,030
ground and I'd imagine at the end of the

00:36:31,810 --> 00:36:36,580
day if we can merge things faster he can

00:36:34,030 --> 00:36:38,290
write them will actually get most of the

00:36:36,580 --> 00:36:41,380
real-time tree into the mainstream

00:36:38,290 --> 00:36:42,640
kernel but one feature which you may

00:36:41,380 --> 00:36:45,820
have a little bit of trouble putting in

00:36:42,640 --> 00:36:47,770
is one feature Ingo has is all the

00:36:45,820 --> 00:36:49,810
interrupt handlers for all the devices

00:36:47,770 --> 00:36:51,400
actually run within tasks contexts so

00:36:49,810 --> 00:36:53,200
we'll take an interrupt on they all just

00:36:51,400 --> 00:36:55,450
basically cloak a task and them a task

00:36:53,200 --> 00:36:56,830
will run the interrupt handler rather

00:36:55,450 --> 00:37:00,730
than running it synchronously within the

00:36:56,830 --> 00:37:02,590
interrupt that's the sort of thing where

00:37:00,730 --> 00:37:05,800
Linna says no no no no no we'll never do

00:37:02,590 --> 00:37:07,670
that when we see the patch we'll

00:37:05,800 --> 00:37:09,840
probably end up doing

00:37:07,670 --> 00:37:13,860
what we said about this is that about a

00:37:09,840 --> 00:37:15,390
simpie forever sport assembly so I ain't

00:37:13,860 --> 00:37:17,490
guys putting up these things I'd imagine

00:37:15,390 --> 00:37:18,930
when he finally gets down and presents

00:37:17,490 --> 00:37:21,110
the patch to Italy yeah that's not so

00:37:18,930 --> 00:37:21,110
bad

00:37:21,740 --> 00:37:27,120
instrumentation I think this is a weak

00:37:23,550 --> 00:37:29,700
spot in the kernel particularly for the

00:37:27,120 --> 00:37:31,200
sophisticated enterprise side of things

00:37:29,700 --> 00:37:35,250
people who really want to know what's

00:37:31,200 --> 00:37:38,310
going on inside that kernel we do I

00:37:35,250 --> 00:37:39,870
don't think we expose enough stuff to

00:37:38,310 --> 00:37:41,340
the sophisticated program is to help

00:37:39,870 --> 00:37:44,580
them understand what the kernel is doing

00:37:41,340 --> 00:37:48,270
to them and why it's doing it features

00:37:44,580 --> 00:37:51,000
are going in at a steady pace if not a

00:37:48,270 --> 00:37:54,180
high pace we recently put in perta

00:37:51,000 --> 00:37:57,810
statistics called task stats that's a

00:37:54,180 --> 00:38:00,510
fairly major change what ty stats does

00:37:57,810 --> 00:38:01,950
it'll basically when a task exits it

00:38:00,510 --> 00:38:05,580
will grab a little packet of information

00:38:01,950 --> 00:38:07,320
about 30 40 fields about how much run

00:38:05,580 --> 00:38:09,780
time it did and all sorts of things like

00:38:07,320 --> 00:38:11,730
that and deliver that across the net

00:38:09,780 --> 00:38:15,150
link socket connection up to a daemon

00:38:11,730 --> 00:38:17,820
which is monitoring tasks stats is

00:38:15,150 --> 00:38:19,830
designed to be very scalable for the

00:38:17,820 --> 00:38:23,970
high-end machines the important thing

00:38:19,830 --> 00:38:26,160
about start test stats it is now it is

00:38:23,970 --> 00:38:29,460
now our future way of delivering per

00:38:26,160 --> 00:38:34,380
task instrumentation out to applications

00:38:29,460 --> 00:38:36,840
and already one fine programmer namely

00:38:34,380 --> 00:38:40,050
myself added per task accounting for i/o

00:38:36,840 --> 00:38:42,420
into tasks that's so I was able to just

00:38:40,050 --> 00:38:44,160
stick a few more fields on the end so

00:38:42,420 --> 00:38:46,590
when a task exit you can find out how

00:38:44,160 --> 00:38:49,740
many how many bytes of i/o it caused to

00:38:46,590 --> 00:38:56,040
be read and written and that was very

00:38:49,740 --> 00:38:57,330
easy to do also touch debts you don't

00:38:56,040 --> 00:38:59,070
have to wake the TAS to exit you can

00:38:57,330 --> 00:39:01,230
actually query a presently running tasks

00:38:59,070 --> 00:39:04,980
and get us cameras out of it so for

00:39:01,230 --> 00:39:06,780
ongoing monitoring another thing we're

00:39:04,980 --> 00:39:08,910
working on is per process memory

00:39:06,780 --> 00:39:13,710
footprint monitoring that's a fine term

00:39:08,910 --> 00:39:15,870
isn't it it's very difficult people want

00:39:13,710 --> 00:39:17,880
to say well how much memory is my is my

00:39:15,870 --> 00:39:19,830
process using it's been running 24 hours

00:39:17,880 --> 00:39:22,350
I can see the resident sets

00:39:19,830 --> 00:39:25,170
is one point five gigabytes well how are

00:39:22,350 --> 00:39:28,650
just really using search me we don't

00:39:25,170 --> 00:39:33,060
have any way of knowing so we had a

00:39:28,650 --> 00:39:35,070
little brain wave here what we do is we

00:39:33,060 --> 00:39:37,830
go into the kernel and for every page

00:39:35,070 --> 00:39:40,710
which that process owns we'll just go

00:39:37,830 --> 00:39:43,620
and clear all the reference bits and

00:39:40,710 --> 00:39:45,600
within the page table entries so now as

00:39:43,620 --> 00:39:47,550
soon as you've done that you can then go

00:39:45,600 --> 00:39:50,820
into the process and count up how many

00:39:47,550 --> 00:39:52,200
reference bits that's it so immediately

00:39:50,820 --> 00:39:53,790
after include them or you expect none to

00:39:52,200 --> 00:39:55,680
be set but as your process goes off and

00:39:53,790 --> 00:39:57,210
touches pages touches pages you'd expect

00:39:55,680 --> 00:40:00,210
to see the number of reference bits go

00:39:57,210 --> 00:40:02,100
up across time so you can so the

00:40:00,210 --> 00:40:04,050
programmer the system administrator that

00:40:02,100 --> 00:40:05,670
can they can get some idea of how much

00:40:04,050 --> 00:40:07,680
memory his process is really using

00:40:05,670 --> 00:40:13,950
rather than how much it actually has

00:40:07,680 --> 00:40:16,830
allocated so that was good but in fact

00:40:13,950 --> 00:40:19,020
were brought to you iGoogle but now Matt

00:40:16,830 --> 00:40:21,810
McCall has gone to totally turn that

00:40:19,020 --> 00:40:23,430
upside down and has developed new

00:40:21,810 --> 00:40:28,050
interfaces for the kernel which let you

00:40:23,430 --> 00:40:29,730
get access to every single page frame

00:40:28,050 --> 00:40:31,380
within your process to find out whether

00:40:29,730 --> 00:40:33,650
your page is reference for the rich the

00:40:31,380 --> 00:40:36,510
dirty and what sort of page it is etc

00:40:33,650 --> 00:40:37,860
very low-level interface might change at

00:40:36,510 --> 00:40:40,170
any time in the future so we changed

00:40:37,860 --> 00:40:42,060
kernel internals but I think anybody

00:40:40,170 --> 00:40:44,700
who's sophisticated enough to use this

00:40:42,060 --> 00:40:46,940
interface will be able to cope with that

00:40:44,700 --> 00:40:48,810
but it's something we've always lacked

00:40:46,940 --> 00:40:50,190
it'll do quite a lot of user space

00:40:48,810 --> 00:40:51,690
development to be able to use these

00:40:50,190 --> 00:40:53,430
interfaces you need quite a lot of

00:40:51,690 --> 00:40:56,280
knowledge they should give great

00:40:53,430 --> 00:41:00,890
transparency into both the static and

00:40:56,280 --> 00:41:00,890
dynamic memory behavior of applications

00:41:01,220 --> 00:41:06,390
perfmon there was once upon a time a

00:41:04,500 --> 00:41:09,630
thing called perfect counter which gave

00:41:06,390 --> 00:41:14,970
us access to your processor CPU counters

00:41:09,630 --> 00:41:18,510
the ones which Intel AMD and IBM etc

00:41:14,970 --> 00:41:20,760
givers perf can have died and now

00:41:18,510 --> 00:41:22,650
perfmon is the way ahead it basically

00:41:20,760 --> 00:41:24,450
does the same thing it's already

00:41:22,650 --> 00:41:28,620
implemented in the mainstream kernel for

00:41:24,450 --> 00:41:31,200
ia-64 tremendously large patch which

00:41:28,620 --> 00:41:33,119
then gets a gives us access to all of

00:41:31,200 --> 00:41:37,140
the or hopefully most of the

00:41:33,119 --> 00:41:40,049
advanced performance scanners on sort of

00:41:37,140 --> 00:41:42,150
the AMD Intel power I think several

00:41:40,049 --> 00:41:45,509
other architectures various states of

00:41:42,150 --> 00:41:47,099
support the perfmon is taking a hell of

00:41:45,509 --> 00:41:49,769
a long time to get into the mainstream

00:41:47,099 --> 00:41:51,390
kernel we had a decent round of review

00:41:49,769 --> 00:41:53,819
about six months ago and things went

00:41:51,390 --> 00:41:57,059
quiet but we will get there eventually

00:41:53,819 --> 00:41:59,970
but it'll be pretty important interface

00:41:57,059 --> 00:42:02,130
for people measuring getting detailed

00:41:59,970 --> 00:42:07,740
information about the behavior of their

00:42:02,130 --> 00:42:11,130
applications things happening in the

00:42:07,740 --> 00:42:14,490
kernel core Kay event this comes from a

00:42:11,130 --> 00:42:18,029
gentleman in Russia somewhere who came

00:42:14,490 --> 00:42:19,529
up with a scheme for anything which can

00:42:18,029 --> 00:42:20,970
generate an event in the kernel and when

00:42:19,529 --> 00:42:23,940
you go through the list there's an awful

00:42:20,970 --> 00:42:26,970
lot there's TTY IO and file completion

00:42:23,940 --> 00:42:29,249
and socket completion and timers going

00:42:26,970 --> 00:42:33,329
off all sorts of things had a unified

00:42:29,249 --> 00:42:35,430
scheme where the kernel would place a

00:42:33,329 --> 00:42:36,960
description of the event directly into a

00:42:35,430 --> 00:42:38,519
user space ring before and send the wake

00:42:36,960 --> 00:42:41,359
up to the application which is waiting

00:42:38,519 --> 00:42:44,039
for it so that's basically for your

00:42:41,359 --> 00:42:45,509
threaded service we have a whole bunch

00:42:44,039 --> 00:42:47,190
of tasks or wedding on the one ring but

00:42:45,509 --> 00:42:50,519
they pick up an event runaway handle it

00:42:47,190 --> 00:42:51,779
come back wait for next one so Kevin I

00:42:50,519 --> 00:42:53,190
think it reached version number

00:42:51,779 --> 00:42:57,059
forty-seven when he started to get a bit

00:42:53,190 --> 00:42:58,559
dispirited we never quite got over the

00:42:57,059 --> 00:43:00,210
hump I was never to find quite enough

00:42:58,559 --> 00:43:01,859
people who actually sit down and spend

00:43:00,210 --> 00:43:04,079
the time to review it I couldn't get and

00:43:01,859 --> 00:43:06,450
it's a major interface very important

00:43:04,079 --> 00:43:11,700
thing and I couldn't quite get enough

00:43:06,450 --> 00:43:13,440
mindshare behind it so then along comes

00:43:11,700 --> 00:43:14,819
a crown from Oracle and proposes

00:43:13,440 --> 00:43:17,430
something completely different

00:43:14,819 --> 00:43:19,259
rather than having new event reporting

00:43:17,430 --> 00:43:23,309
interfaces how about we just make all

00:43:19,259 --> 00:43:26,549
system calls asynchronous so if if

00:43:23,309 --> 00:43:28,170
instead take a read from disk what you'd

00:43:26,549 --> 00:43:30,630
like to do is they start the read now

00:43:28,170 --> 00:43:32,640
and tell me when it's finished its

00:43:30,630 --> 00:43:35,940
acquires new infrastructure to be put

00:43:32,640 --> 00:43:37,529
around the read system call but with a

00:43:35,940 --> 00:43:41,489
synchronous system cause what you can do

00:43:37,529 --> 00:43:43,650
is say run some arbitrary system call it

00:43:41,489 --> 00:43:44,840
happens to be read and tell me when

00:43:43,650 --> 00:43:47,150
that's finished

00:43:44,840 --> 00:43:49,640
every theoretically every system call on

00:43:47,150 --> 00:43:50,870
the kernel becomes asynchronous and this

00:43:49,640 --> 00:43:52,010
basically solves the whole problem

00:43:50,870 --> 00:43:53,630
because you can take all these old

00:43:52,010 --> 00:43:58,970
synchronous system calls and not have to

00:43:53,630 --> 00:44:00,380
wait on them so it's a nice idea so that

00:43:58,970 --> 00:44:03,350
came out with this and that got Ingo

00:44:00,380 --> 00:44:04,910
coding for about 15 when it sort of came

00:44:03,350 --> 00:44:09,130
out with a massive patch that which did

00:44:04,910 --> 00:44:13,480
it in completely different way I woulda

00:44:09,130 --> 00:44:15,530
called his version of that sis 'let's

00:44:13,480 --> 00:44:17,180
don't quite at present because he's

00:44:15,530 --> 00:44:18,620
disappeared into the CPU schedule a

00:44:17,180 --> 00:44:20,210
black hole for a few weeks but I'd

00:44:18,620 --> 00:44:22,460
imagine that when he comes out of that

00:44:20,210 --> 00:44:25,970
black hole we'll start looking at sis

00:44:22,460 --> 00:44:27,410
let's again and it was looking pretty

00:44:25,970 --> 00:44:30,140
positive but wouldn't surprise me if

00:44:27,410 --> 00:44:31,690
maybe towards the end of the year we do

00:44:30,140 --> 00:44:36,890
have some asynchronous system called

00:44:31,690 --> 00:44:39,650
implementation in the kernel foo Texas

00:44:36,890 --> 00:44:41,500
that's the kernels basic synchronization

00:44:39,650 --> 00:44:44,510
primitive which allows you to implement

00:44:41,500 --> 00:44:46,850
user space locking in which you've don't

00:44:44,510 --> 00:44:52,970
enter the kernel at all in a non

00:44:46,850 --> 00:44:54,920
contended common case lots of things

00:44:52,970 --> 00:44:59,030
happening here we recently merged an

00:44:54,920 --> 00:45:00,680
implementation to basically a simpler

00:44:59,030 --> 00:45:02,360
version of food X's which didn't have to

00:45:00,680 --> 00:45:05,030
support sharing between different

00:45:02,360 --> 00:45:07,070
heavyweight processes so that's an

00:45:05,030 --> 00:45:09,550
optimization and I'd imagine that while

00:45:07,070 --> 00:45:13,820
I'm planning on merging that under T 622

00:45:09,550 --> 00:45:16,520
people work on 64-bit food X's priority

00:45:13,820 --> 00:45:20,210
inheritance on Felix's as well what our

00:45:16,520 --> 00:45:22,820
work happening there and it's all well

00:45:20,210 --> 00:45:24,830
supported by the G Lipsy guys who to a

00:45:22,820 --> 00:45:30,080
large extent driving the changes in

00:45:24,830 --> 00:45:32,540
footings adding a new Moto M advisors

00:45:30,080 --> 00:45:34,820
not exactly a world shattering thing but

00:45:32,540 --> 00:45:36,320
it's a really example of the the little

00:45:34,820 --> 00:45:37,790
incremental changes we make in the

00:45:36,320 --> 00:45:40,070
kernel to attempt to improve the

00:45:37,790 --> 00:45:43,010
situation user space there are some

00:45:40,070 --> 00:45:45,320
performance issues with melt in G let's

00:45:43,010 --> 00:45:49,580
see which is function it gets used quite

00:45:45,320 --> 00:45:51,980
a lot so we've been working that with

00:45:49,580 --> 00:45:53,450
with the G let's see developers and now

00:45:51,980 --> 00:45:58,960
there's an implementation in Maya tree

00:45:53,450 --> 00:46:02,130
of a new mode - in advice which Mallory

00:45:58,960 --> 00:46:06,900
News to optimize this internal functions

00:46:02,130 --> 00:46:06,900
plan to get that into to 622 as well

00:46:07,660 --> 00:46:13,900
David lesney came out of nowhere and

00:46:10,030 --> 00:46:16,600
buried me in patches which is an

00:46:13,900 --> 00:46:18,370
alternative decay event in which we've

00:46:16,600 --> 00:46:22,150
got these various objects in the kernel

00:46:18,370 --> 00:46:24,130
of which generate asynchronous events to

00:46:22,150 --> 00:46:26,500
an instance here are signals and timer

00:46:24,130 --> 00:46:28,270
expiry but there's no way you can select

00:46:26,500 --> 00:46:30,760
on them so if you've got an application

00:46:28,270 --> 00:46:32,470
which wants to either wait on a select

00:46:30,760 --> 00:46:36,730
on a socket or on this timer going off

00:46:32,470 --> 00:46:38,380
on the signal coming off you enter home

00:46:36,730 --> 00:46:40,900
to do a signal based implementation

00:46:38,380 --> 00:46:42,580
which tends to be messy and slow so what

00:46:40,900 --> 00:46:45,370
David's cut with is a new sort of file

00:46:42,580 --> 00:46:47,650
descriptor which will when a timer goes

00:46:45,370 --> 00:46:49,810
off the timer will be delivered to you

00:46:47,650 --> 00:46:51,610
across the file descriptor so you can

00:46:49,810 --> 00:46:54,460
just add that particular special file

00:46:51,610 --> 00:46:56,020
descriptor to your select set and it

00:46:54,460 --> 00:47:00,520
will come up and say hey here's a timer

00:46:56,020 --> 00:47:05,980
for you and that's looking like to 6:22

00:47:00,520 --> 00:47:12,670
material as well gee Munsell debug

00:47:05,980 --> 00:47:15,340
ability it's important to us we don't

00:47:12,670 --> 00:47:17,800
all work in one building and talk to

00:47:15,340 --> 00:47:19,300
each other from 9 to 5 kernel developers

00:47:17,800 --> 00:47:21,640
kernel testers that are all spread all

00:47:19,300 --> 00:47:25,210
around the world it's very important to

00:47:21,640 --> 00:47:27,100
us that the kernel have a lot of self

00:47:25,210 --> 00:47:29,620
checking self consistency checking and

00:47:27,100 --> 00:47:32,650
also a lot of infrastructure in there to

00:47:29,620 --> 00:47:34,390
help the developers who are 12 time

00:47:32,650 --> 00:47:37,210
zones and 5,000 miles away from the

00:47:34,390 --> 00:47:41,560
reporters find out what the heck went

00:47:37,210 --> 00:47:43,090
wrong Ingo did the locking dependency

00:47:41,560 --> 00:47:44,590
checker recently that's pretty

00:47:43,090 --> 00:47:46,570
sophisticated thing that will monitor

00:47:44,590 --> 00:47:49,450
the order in which various types of lot

00:47:46,570 --> 00:47:51,880
taken and develop a dependency graph

00:47:49,450 --> 00:47:54,210
between them and later on if it sees

00:47:51,880 --> 00:47:56,620
some locks being taken a different order

00:47:54,210 --> 00:47:59,490
with incorrect dependency will report on

00:47:56,620 --> 00:48:01,390
it so you have a potential deadlock here

00:47:59,490 --> 00:48:04,120
originally modes a framework for

00:48:01,390 --> 00:48:07,000
deliberate injection of thoughts so you

00:48:04,120 --> 00:48:09,250
can if you're designing a device driver

00:48:07,000 --> 00:48:11,440
you can wire it up to this library and

00:48:09,250 --> 00:48:14,050
deliberately poke faults and your device

00:48:11,440 --> 00:48:15,540
to simulate memory allocation errors or

00:48:14,050 --> 00:48:18,000
checksum errors or anything like that

00:48:15,540 --> 00:48:20,260
nobody's using that yet

00:48:18,000 --> 00:48:21,730
Colonel debuggers everybody thinks we'll

00:48:20,260 --> 00:48:25,390
never have a debugger in the kernel

00:48:21,730 --> 00:48:27,820
because Linda's said no I think I can

00:48:25,390 --> 00:48:32,770
talk him around my preferred option

00:48:27,820 --> 00:48:34,870
there is K gdb the only other options on

00:48:32,770 --> 00:48:36,760
the table really a KDB which i think is

00:48:34,870 --> 00:48:39,820
too low level it doesn't understand the

00:48:36,760 --> 00:48:42,840
source code and the Novell debugger

00:48:39,820 --> 00:48:46,570
which the patch is pretty scary-looking

00:48:42,840 --> 00:48:48,010
k gdb I would have measured years ago if

00:48:46,570 --> 00:48:49,720
it really had somebody is prepared to

00:48:48,010 --> 00:48:52,330
stand up behind it and support it long

00:48:49,720 --> 00:48:53,680
term but mobis really been on offer yet

00:48:52,330 --> 00:48:55,600
however there have been some changes

00:48:53,680 --> 00:48:57,580
recently which are optimistic looking I

00:48:55,600 --> 00:48:59,830
could get cagey to be back in my tree

00:48:57,580 --> 00:49:02,500
within a month or two I have it might be

00:48:59,830 --> 00:49:04,660
on the way to mainline cleanups they

00:49:02,500 --> 00:49:06,280
drive everybody wild people go in and

00:49:04,660 --> 00:49:07,870
they make factions static and they fix

00:49:06,280 --> 00:49:11,490
up your white space and they take out

00:49:07,870 --> 00:49:16,600
your includes and they add new includes

00:49:11,490 --> 00:49:18,700
everybody hates it but and it does

00:49:16,600 --> 00:49:20,230
sometimes it breaks things sometimes I

00:49:18,700 --> 00:49:24,130
get nasty grams from the developers

00:49:20,230 --> 00:49:26,170
saying hey you broke my code but we grit

00:49:24,130 --> 00:49:28,830
our teeth and bear it because we do

00:49:26,170 --> 00:49:31,560
expect the Linux kernel code base I mean

00:49:28,830 --> 00:49:33,910
when are we finally going to delete it

00:49:31,560 --> 00:49:35,620
probably will after my career's over

00:49:33,910 --> 00:49:38,260
it's gonna be there for a long long long

00:49:35,620 --> 00:49:41,220
long time we understand we're in it for

00:49:38,260 --> 00:49:43,270
the long term the clarity and

00:49:41,220 --> 00:49:45,970
maintainability of the kernel is an

00:49:43,270 --> 00:49:48,010
important asset so even though there are

00:49:45,970 --> 00:49:48,640
short-term cost we do believe all this

00:49:48,010 --> 00:49:51,490
cleanups

00:49:48,640 --> 00:49:53,530
of long-term benefit and certainly when

00:49:51,490 --> 00:49:55,810
you go back and look at the 2.4 tree say

00:49:53,530 --> 00:50:01,720
yeah did we do that things have got a

00:49:55,810 --> 00:50:03,340
lot better so yeah we merge them we had

00:50:01,720 --> 00:50:08,200
it immersion because we feel we need to

00:50:03,340 --> 00:50:09,880
do so things I don't know about yet

00:50:08,200 --> 00:50:11,890
people just pop out of the woodwork with

00:50:09,880 --> 00:50:15,760
features which I never expected Kay

00:50:11,890 --> 00:50:18,450
event was one case there KVM of course

00:50:15,760 --> 00:50:20,830
is the classic from the recent last year

00:50:18,450 --> 00:50:22,030
people have a brain wave them cut for

00:50:20,830 --> 00:50:23,060
something and sometimes it's somebody

00:50:22,030 --> 00:50:25,650
you've never heard of

00:50:23,060 --> 00:50:27,329
the curious thing about KVM was that it

00:50:25,650 --> 00:50:30,750
came from a bunch of people would never

00:50:27,329 --> 00:50:32,790
heard of but it was very clean and very

00:50:30,750 --> 00:50:34,109
Edom idiomatic kernel code it looked

00:50:32,790 --> 00:50:36,660
like the guys have been working in

00:50:34,109 --> 00:50:38,040
Colonel amperes but it was as far as I

00:50:36,660 --> 00:50:40,320
know their first submission that was

00:50:38,040 --> 00:50:42,410
such an easy merge so it's a pleasant

00:50:40,320 --> 00:50:42,410
surprise

00:50:45,890 --> 00:50:51,300
colonel contributors the greater joy to

00:50:49,710 --> 00:50:52,820
Colonel work now is done by people who

00:50:51,300 --> 00:50:55,109
have paid for it

00:50:52,820 --> 00:50:58,410
most of them deserve to be paid for it

00:50:55,109 --> 00:51:00,990
the middle but the private contributors

00:50:58,410 --> 00:51:02,700
are still important they're not as

00:51:00,990 --> 00:51:05,670
important as they were ten years ago I

00:51:02,700 --> 00:51:07,380
don't think but I'm they're particularly

00:51:05,670 --> 00:51:08,910
important in desktop related development

00:51:07,380 --> 00:51:10,530
because they're doing thing because they

00:51:08,910 --> 00:51:13,550
mainly desktop users and they're doing

00:51:10,530 --> 00:51:15,960
things which matter to them and

00:51:13,550 --> 00:51:17,609
oftentimes you get somebody as a

00:51:15,960 --> 00:51:19,829
contributor and you don't know who they

00:51:17,609 --> 00:51:21,060
work for they may hide behind some email

00:51:19,829 --> 00:51:23,160
address and you find out oh I've been

00:51:21,060 --> 00:51:27,810
working for Intel for five years Oh have

00:51:23,160 --> 00:51:29,460
you and I'd say a lot of these people

00:51:27,810 --> 00:51:31,200
for any good they don't stay individual

00:51:29,460 --> 00:51:38,430
contributors for a long people tend to

00:51:31,200 --> 00:51:41,760
snap them up the area where non

00:51:38,430 --> 00:51:45,630
professional contributors best

00:51:41,760 --> 00:51:46,800
contribute is of course in testing there

00:51:45,630 --> 00:51:49,200
are lots of crazy people who are

00:51:46,800 --> 00:51:51,060
download the latest snapshot Colonel is

00:51:49,200 --> 00:51:53,250
the latest release kernels or even the

00:51:51,060 --> 00:51:55,920
latest mm kernels for one I inflict on

00:51:53,250 --> 00:51:57,869
the public and just test it

00:51:55,920 --> 00:51:59,569
find out what any problems are and

00:51:57,869 --> 00:52:03,390
report on them

00:51:59,569 --> 00:52:05,160
these people are indispensable of kernel

00:52:03,390 --> 00:52:06,720
effort if these people didn't download

00:52:05,160 --> 00:52:09,060
and test development kernels the whole

00:52:06,720 --> 00:52:11,970
project grind to a halt I don't

00:52:09,060 --> 00:52:13,829
exaggerate that reason being I mean

00:52:11,970 --> 00:52:15,180
you've got a core of one or two hundred

00:52:13,829 --> 00:52:16,770
kernel developers which means they've

00:52:15,180 --> 00:52:19,020
got a core of five or six hundred

00:52:16,770 --> 00:52:22,220
machines to test kernels on those of

00:52:19,020 --> 00:52:22,220
them who do actually test stuff

00:52:25,840 --> 00:52:30,080
but that's only such a tiny subset of

00:52:28,580 --> 00:52:32,120
the machines we actually need to run on

00:52:30,080 --> 00:52:33,970
so people will get their code and test

00:52:32,120 --> 00:52:36,200
it beautifully I mean I used to

00:52:33,970 --> 00:52:38,540
allegedly still maintain the freak on

00:52:36,200 --> 00:52:40,970
network driver I only had a stack of

00:52:38,540 --> 00:52:43,610
NICs this high the device is supposed to

00:52:40,970 --> 00:52:46,010
support 23 of them and then you get

00:52:43,610 --> 00:52:47,810
interactions with various PCI issues

00:52:46,010 --> 00:52:49,610
interactions that are with ACPI

00:52:47,810 --> 00:52:53,270
wake-on-lan the number of combinations

00:52:49,610 --> 00:52:55,850
is awful so we're very much dependent on

00:52:53,270 --> 00:52:57,500
the external testers because they have

00:52:55,850 --> 00:52:59,780
different hardware from what the

00:52:57,500 --> 00:53:02,930
developers have and because they'll toss

00:52:59,780 --> 00:53:04,970
different workloads at it seems that a

00:53:02,930 --> 00:53:07,040
lot of our useful tests as the guys who

00:53:04,970 --> 00:53:08,060
are like working at an ISP and he's

00:53:07,040 --> 00:53:09,320
supposed to be looking after his

00:53:08,060 --> 00:53:11,180
customers instead he's loading the

00:53:09,320 --> 00:53:14,930
latest scalable Carolina's production

00:53:11,180 --> 00:53:16,910
machines I'm not complaining you punk

00:53:14,930 --> 00:53:18,950
lab don't work for me

00:53:16,910 --> 00:53:22,460
a lot of them quite sophisticated users

00:53:18,950 --> 00:53:26,540
and they just great and can't thank them

00:53:22,460 --> 00:53:27,770
too much but if you're - fine people

00:53:26,540 --> 00:53:30,980
want to help the tribute for Colonel

00:53:27,770 --> 00:53:35,080
effing testing is an easy and extremely

00:53:30,980 --> 00:53:37,070
valuable way of doing so so this is my

00:53:35,080 --> 00:53:38,210
astronaut what the colonel can do for

00:53:37,070 --> 00:53:43,850
you but what you can do for the colonel

00:53:38,210 --> 00:53:45,290
slide how to test the Linux kernel if

00:53:43,850 --> 00:53:47,420
you're brave enough to compile your own

00:53:45,290 --> 00:53:49,280
kernel you'll grab the latest snapshot

00:53:47,420 --> 00:53:50,840
from the snapshots directory i'm colonel

00:53:49,280 --> 00:53:51,560
a dog and i think it's linked off the

00:53:50,840 --> 00:53:53,930
front page

00:53:51,560 --> 00:53:55,490
and just use it people say oh should i

00:53:53,930 --> 00:53:58,130
run benchmarks should I run Bonnie

00:53:55,490 --> 00:54:00,350
should I do this I don't think so I

00:53:58,130 --> 00:54:02,420
think it's valuable of people just use

00:54:00,350 --> 00:54:04,610
the kernel in their day-to-day use it

00:54:02,420 --> 00:54:08,420
works ok fine if everybody does that

00:54:04,610 --> 00:54:12,080
worked ok for them we're done nothing

00:54:08,420 --> 00:54:14,630
special needs to be done testing

00:54:12,080 --> 00:54:16,430
probably I think once a week or once a

00:54:14,630 --> 00:54:17,720
month the suitable interval to update

00:54:16,430 --> 00:54:21,560
your kernel and keep an eye out for

00:54:17,720 --> 00:54:26,570
things which are going wrong Fedora open

00:54:21,560 --> 00:54:28,280
SUSE very nicely they put out a bleeding

00:54:26,570 --> 00:54:29,960
edge kernel I'm not sure about the

00:54:28,280 --> 00:54:32,480
openSUSE one but the Fedora kernel is

00:54:29,960 --> 00:54:36,260
generally no more than one to two weeks

00:54:32,480 --> 00:54:37,160
behind the kernel a dog kernel very much

00:54:36,260 --> 00:54:39,349
in sync with the kernel

00:54:37,160 --> 00:54:41,510
colonel and we do readily accept bug

00:54:39,349 --> 00:54:46,670
reports against the latest fedora

00:54:41,510 --> 00:54:48,859
colonel they're almost always also bugs

00:54:46,670 --> 00:54:50,420
against mainline and the nice thing

00:54:48,859 --> 00:54:52,369
about that is you can just grab the RPM

00:54:50,420 --> 00:54:53,660
which they put up there for you and

00:54:52,369 --> 00:54:57,859
install it without having to build the

00:54:53,660 --> 00:55:03,349
comb if it doesn't work great if you do

00:54:57,859 --> 00:55:05,329
have a problem reporting it is the

00:55:03,349 --> 00:55:06,980
greatest value often developers will

00:55:05,329 --> 00:55:08,930
Gavin come back say well can you please

00:55:06,980 --> 00:55:10,339
try this patch or that sort of thing a

00:55:08,930 --> 00:55:11,690
lot of people can't do that because they

00:55:10,339 --> 00:55:13,160
just downloaded the RPM they're not

00:55:11,690 --> 00:55:15,109
interested in building their own kernel

00:55:13,160 --> 00:55:16,579
that's when we get in a little dialogue

00:55:15,109 --> 00:55:18,079
with Dave Jones to get him to add the

00:55:16,579 --> 00:55:25,309
patch so it comes back down via that

00:55:18,079 --> 00:55:29,990
route but actually reporting a problem

00:55:25,309 --> 00:55:32,720
is the main thing when reporting the

00:55:29,990 --> 00:55:33,890
problems the best way to do that

00:55:32,720 --> 00:55:35,960
particularly if you well if you're

00:55:33,890 --> 00:55:37,609
testing a leading edge a snapshot kernel

00:55:35,960 --> 00:55:39,890
some development kernel reported via

00:55:37,609 --> 00:55:42,980
email be careful about who you send it

00:55:39,890 --> 00:55:45,109
to make sure it gets Linux kernel and

00:55:42,980 --> 00:55:49,789
also to the developers and the relevant

00:55:45,109 --> 00:55:51,859
mailing list and if it's a long-term bug

00:55:49,789 --> 00:55:53,930
like give youth right now we just

00:55:51,859 --> 00:55:56,510
released two 6:21 if you find a bug in

00:55:53,930 --> 00:55:59,510
two 6:19 or something like that it's

00:55:56,510 --> 00:56:01,299
probably best to go straight to bugzilla

00:55:59,510 --> 00:56:04,160
kernel a dog to raise the report there

00:56:01,299 --> 00:56:07,160
so what we do what I prefer that we do

00:56:04,160 --> 00:56:08,720
is the short term hot bug fixes for code

00:56:07,160 --> 00:56:10,520
which is still in people's mind let's do

00:56:08,720 --> 00:56:13,970
that by email generally we can get it

00:56:10,520 --> 00:56:15,319
resolved within within a day or so if it

00:56:13,970 --> 00:56:17,539
looks too hard if it's been there for a

00:56:15,319 --> 00:56:18,260
while I'll push bugs into Bugzilla for

00:56:17,539 --> 00:56:23,510
longer-term

00:56:18,260 --> 00:56:26,000
tracking those people who have built

00:56:23,510 --> 00:56:28,069
their own kernels if we can talk them

00:56:26,000 --> 00:56:30,470
into it they will use gits but the

00:56:28,069 --> 00:56:32,990
source code the revision control systems

00:56:30,470 --> 00:56:35,440
bisection feature so you can actually

00:56:32,990 --> 00:56:39,710
say yep - 6:20 unworked

00:56:35,440 --> 00:56:41,390
- 6:20 worked - 621 didn't work and get

00:56:39,710 --> 00:56:43,430
you can then just say yes that works no

00:56:41,390 --> 00:56:45,799
that doesn't bisect through all the

00:56:43,430 --> 00:56:47,750
change sets in the kernel can you come

00:56:45,799 --> 00:56:49,200
down to a particular patch which is the

00:56:47,750 --> 00:56:51,480
one which broke your machine

00:56:49,200 --> 00:56:56,069
it's wonderful when it works sometimes

00:56:51,480 --> 00:56:57,869
it doesn't work because get it doesn't

00:56:56,069 --> 00:57:00,480
have a linear sequence of patches it has

00:56:57,869 --> 00:57:03,779
some complex n-dimensional graph which

00:57:00,480 --> 00:57:05,579
I've never understood so git bisect will

00:57:03,779 --> 00:57:07,140
sometimes get stuck close to but not

00:57:05,579 --> 00:57:09,599
exactly on the buggy patch but that's

00:57:07,140 --> 00:57:14,029
still useful news chances are it's

00:57:09,599 --> 00:57:17,250
pointing an ACP eye patch it normally is

00:57:14,029 --> 00:57:18,420
so then we can tell Lin look one of

00:57:17,250 --> 00:57:20,849
these hundred patches yours is broken

00:57:18,420 --> 00:57:24,140
you're fine put it in Bugzilla in a

00:57:20,849 --> 00:57:24,140
couple years time it won't be fixed

00:57:24,599 --> 00:57:27,930
but if you do get stuck on git bisect

00:57:26,460 --> 00:57:29,579
people come talk to you through how to

00:57:27,930 --> 00:57:31,859
get over the hump and actually get down

00:57:29,579 --> 00:57:34,260
on a particular change set so git bisect

00:57:31,859 --> 00:57:35,849
has been very useful to us and a lot of

00:57:34,260 --> 00:57:37,890
people people you've never heard of

00:57:35,849 --> 00:57:40,289
before Canton say I bisected it down

00:57:37,890 --> 00:57:43,500
this particular patch and it broke and

00:57:40,289 --> 00:57:48,390
that's so good bye-bye patch or send a

00:57:43,500 --> 00:57:52,019
nasty grin with originator that's it

00:57:48,390 --> 00:57:59,779
from me my forty minutes went for 59

00:57:52,019 --> 00:57:59,779
minutes questions and answers please

00:58:05,340 --> 00:58:10,210
and it's important you tell me things I

00:58:08,350 --> 00:58:11,470
need to do I need to know rather than

00:58:10,210 --> 00:58:22,480
having me tell you things you want to

00:58:11,470 --> 00:58:24,310
know yes sir did not talk about that the

00:58:22,480 --> 00:58:25,900
funding situation with embedded systems

00:58:24,310 --> 00:58:28,750
well that was all my waffle about why

00:58:25,900 --> 00:58:30,310
they're not motivated because they don't

00:58:28,750 --> 00:58:32,230
have plan to upgrade to new colonel

00:58:30,310 --> 00:58:35,380
means they don't work against kernel.org

00:58:32,230 --> 00:58:37,060
you see a lot of people go to various

00:58:35,380 --> 00:58:38,800
conferences and stand up in front of the

00:58:37,060 --> 00:58:40,240
embedded people and tell them how to

00:58:38,800 --> 00:58:42,190
interact with the colonel community etc

00:58:40,240 --> 00:58:45,040
but the message doesn't seem to be

00:58:42,190 --> 00:58:46,450
getting through very well they just they

00:58:45,040 --> 00:59:06,600
don't have commercial motivation to do

00:58:46,450 --> 00:59:06,600
so then ZFS excellent yes

00:59:07,730 --> 00:59:17,300
yes only anecdotal data the problem with

00:59:12,980 --> 00:59:20,630
XFS is well as a long-standing problem

00:59:17,300 --> 00:59:22,070
with XFS in that you're using XFS your

00:59:20,630 --> 00:59:24,680
righteous and files your machine goes

00:59:22,070 --> 00:59:27,200
you bring it back up and that file now

00:59:24,680 --> 00:59:31,700
has zeros in the middle where you'd

00:59:27,200 --> 00:59:33,980
expected to see data what the way ext3

00:59:31,700 --> 00:59:35,660
gets around that is it writes all you

00:59:33,980 --> 00:59:37,250
every time it runs a journal commit

00:59:35,660 --> 00:59:39,260
every time it writes out your files

00:59:37,250 --> 00:59:39,980
allocation information it'll write the

00:59:39,260 --> 00:59:43,220
data first

00:59:39,980 --> 00:59:45,770
so writes the data out then it writes

00:59:43,220 --> 00:59:48,200
the metadata which refers to the data so

00:59:45,770 --> 00:59:50,960
if you get a crash bus recovery you

00:59:48,200 --> 00:59:52,780
don't have metadata referring to data

00:59:50,960 --> 00:59:55,130
which hasn't been written yet

00:59:52,780 --> 00:59:59,420
Exeter's doesn't do that it's a metadata

00:59:55,130 --> 01:00:01,400
only journaling so XFS it'll if when you

00:59:59,420 --> 01:00:05,240
do write to a file it'll dirty the page

01:00:01,400 --> 01:00:06,920
cache then it will write the metadata to

01:00:05,240 --> 01:00:09,200
the journal first and then if you crash

01:00:06,920 --> 01:00:10,579
you have metadata in the journal which

01:00:09,200 --> 01:00:13,790
refers to data which hasn't been written

01:00:10,579 --> 01:00:15,200
yet Steve laws many years ago that

01:00:13,790 --> 01:00:15,980
should be no no no no that doesn't

01:00:15,200 --> 01:00:17,599
happen because of waffleh waffleh

01:00:15,980 --> 01:00:21,079
waffleh but it does happen and people

01:00:17,599 --> 01:00:22,579
regularly complain about it yes files

01:00:21,079 --> 01:00:28,430
will come back with zeros in them or

01:00:22,579 --> 01:00:30,380
make surface I think we can fix that but

01:00:28,430 --> 01:00:32,180
to do that I know exactly how to do it

01:00:30,380 --> 01:00:34,520
you need to take over the MM tree for me

01:00:32,180 --> 01:00:35,690
so I'll get time to do it I have to

01:00:34,520 --> 01:00:37,099
describe how we should do this several

01:00:35,690 --> 01:00:39,260
times but nobody's picked up the ball

01:00:37,099 --> 01:00:42,440
and run with it yet but we can solve

01:00:39,260 --> 01:00:44,210
that in the VFS simply by doing a

01:00:42,440 --> 01:00:47,390
sophisticated F data sync before we run

01:00:44,210 --> 01:00:49,220
the metadata commitment it's basically

01:00:47,390 --> 01:00:51,369
it's ordered mode for XFS but nobody's

01:00:49,220 --> 01:00:51,369
done

01:00:58,120 --> 01:01:05,090
was it very little

01:01:03,470 --> 01:01:08,480
I don't read anything useful to say

01:01:05,090 --> 01:01:11,660
about CFS I see people seem to regard it

01:01:08,480 --> 01:01:14,600
well it's very unknown exceeding that it

01:01:11,660 --> 01:01:17,480
obviously Linux separates the concept of

01:01:14,600 --> 01:01:19,730
volume management and filesystem growth

01:01:17,480 --> 01:01:21,320
from the file system itself we like to

01:01:19,730 --> 01:01:23,420
keep these things separate rows I

01:01:21,320 --> 01:01:25,010
understand ZFS does a lot of these

01:01:23,420 --> 01:01:28,700
management roles internally within the

01:01:25,010 --> 01:01:29,840
file system that make me that might make

01:01:28,700 --> 01:01:33,800
sense I just don't have the experience

01:01:29,840 --> 01:01:35,420
or knowledge to say if it's if it really

01:01:33,800 --> 01:01:38,570
is if it does come out under a

01:01:35,420 --> 01:01:39,890
compatible license yeah wouldn't

01:01:38,570 --> 01:01:42,130
surprise me somebody got in there and

01:01:39,890 --> 01:01:42,130
did it

01:01:49,260 --> 01:01:56,069
common infrastructure for TCP offload I

01:01:54,079 --> 01:01:59,250
don't think I could say anything

01:01:56,069 --> 01:02:01,710
intelligent about that I know David

01:01:59,250 --> 01:02:04,349
Miller traditionally has been very anti

01:02:01,710 --> 01:02:06,180
TCP offload mainly because it does

01:02:04,349 --> 01:02:08,430
things such as bypassing things which X

01:02:06,180 --> 01:02:11,369
people expect women to have such as net

01:02:08,430 --> 01:02:14,130
filter and various other packet ingress

01:02:11,369 --> 01:02:15,930
egress filtering options but that's as

01:02:14,130 --> 01:02:17,760
much as I know I know David doesn't like

01:02:15,930 --> 01:02:19,079
it a lot of people have tried they

01:02:17,760 --> 01:02:20,910
haven't managed to get past the David

01:02:19,079 --> 01:02:24,529
humping whether that hump is being

01:02:20,910 --> 01:02:24,529
smoothed out nowadays I do not know

01:02:36,529 --> 01:02:42,630
Raisa three is obviously it's kind of

01:02:41,010 --> 01:02:43,950
moldering nowadays it doesn't perform

01:02:42,630 --> 01:02:44,640
very well not a lot of maintenance is

01:02:43,950 --> 01:02:45,839
going into it

01:02:44,640 --> 01:02:47,190
most of the maintenance that goes into

01:02:45,839 --> 01:02:49,079
it manages to break it rather than

01:02:47,190 --> 01:02:50,760
improve it I'm afraid but there are a

01:02:49,079 --> 01:02:52,109
few people who work on rise up three but

01:02:50,760 --> 01:02:52,700
it no it doesn't really seem to have a

01:02:52,109 --> 01:02:55,410
future

01:02:52,700 --> 01:02:58,769
Rosa four has been in my tree now for

01:02:55,410 --> 01:02:59,940
about two years obviously your hands had

01:02:58,769 --> 01:03:02,490
a few personal problems which has

01:02:59,940 --> 01:03:04,529
impacted Rises rise of force development

01:03:02,490 --> 01:03:07,740
but I'm still getting paid just for it

01:03:04,529 --> 01:03:10,430
and a couple of the name sis engineers

01:03:07,740 --> 01:03:16,650
from Russia are still working on it I

01:03:10,430 --> 01:03:17,849
think in an unfunded basis and so I

01:03:16,650 --> 01:03:19,980
wouldn't rule out the possibility of

01:03:17,849 --> 01:03:21,990
Reiser for getting merged it needs a bit

01:03:19,980 --> 01:03:23,430
more work done into it needs to get a

01:03:21,990 --> 01:03:25,799
little bit more mindshare in momentum

01:03:23,430 --> 01:03:27,119
they had a bad reputation from several

01:03:25,799 --> 01:03:27,809
years ago where absolutely had the

01:03:27,119 --> 01:03:29,880
kitchen sink

01:03:27,809 --> 01:03:31,920
everything was in erisa for always going

01:03:29,880 --> 01:03:34,049
to be in Raisa for all those plans are

01:03:31,920 --> 01:03:36,299
being wound back a lot a lot of code is

01:03:34,049 --> 01:03:38,609
taken out it's much more regular file

01:03:36,299 --> 01:03:40,170
system than it used to be so I haven't

01:03:38,609 --> 01:03:42,059
stuck my nose in there for every year I

01:03:40,170 --> 01:03:44,819
measure what we have there is closely

01:03:42,059 --> 01:03:46,019
being merged well than it used to be but

01:03:44,819 --> 01:03:48,029
the barrier there's a pretty high

01:03:46,019 --> 01:03:50,910
barrier for merging file systems in the

01:03:48,029 --> 01:03:54,029
Linux there's significant maintenance

01:03:50,910 --> 01:03:55,799
cost for everybody involved we need to

01:03:54,029 --> 01:03:57,930
handle bug reports is the interaction of

01:03:55,799 --> 01:04:01,369
the VM which is often complicated and

01:03:57,930 --> 01:04:01,369
affects the memory management developers

01:04:01,940 --> 01:04:05,390
so it's not the sort of thing you can

01:04:03,710 --> 01:04:07,190
just slide in and think I will let them

01:04:05,390 --> 01:04:09,910
take care of it because it has impacts

01:04:07,190 --> 01:04:49,250
on the rest of the kernel and other

01:04:09,910 --> 01:04:53,630
people so we testing is very nicely put

01:04:49,250 --> 01:04:56,690
out late again she could not Rebecca

01:04:53,630 --> 01:05:00,490
Salem Oregon with Jim Beam no more than

01:04:56,690 --> 01:05:03,350
one to two weeks behind the camera vodka

01:05:00,490 --> 01:05:05,180
very much a secret

01:05:03,350 --> 01:05:14,120
and we do readily accept bug reports

01:05:05,180 --> 01:05:15,590
against the latest always and the last

01:05:14,120 --> 01:05:26,390
thing that is you can affect the up

01:05:15,590 --> 01:05:37,130
again up there for you and reporting it

01:05:26,390 --> 01:05:39,680
is the greatest company in the morning

01:05:37,130 --> 01:05:41,300
mr. bodeaux around Telmo that's when we

01:05:39,680 --> 01:05:48,970
get in a little bar with a chance to

01:05:41,300 --> 01:05:51,200
indirect effect any bar that yeah but

01:05:48,970 --> 01:05:56,470
Hector reporting the problem is than

01:05:51,200 --> 01:05:59,390
anything when they're going the problems

01:05:56,470 --> 01:06:00,770
this way to do that particular if you're

01:05:59,390 --> 01:06:04,400
testing a leading here's a snapshot

01:06:00,770 --> 01:06:07,730
kernels of them reported by email became

01:06:04,400 --> 01:06:10,100
that incentive to make short resolute

01:06:07,730 --> 01:06:14,990
external and also to the developments in

01:06:10,100 --> 01:06:19,370
the row of loneliness and it's a woman

01:06:14,990 --> 01:06:21,140
both like right now we just won a bucket

01:06:19,370 --> 01:06:24,730
into six nineteen or something like that

01:06:21,140 --> 01:06:27,730
probably just to go straight to my

01:06:24,730 --> 01:06:27,730
village

01:06:52,500 --> 01:07:32,560
the bicycle sometimes gets stuck closed

01:07:30,460 --> 01:07:51,910
movement on exactly on the buggy that's

01:07:32,560 --> 01:07:53,619
still useful you get stuck on git bisect

01:07:51,910 --> 01:07:54,220
people control you through how to get

01:07:53,619 --> 01:07:57,670
over the hump

01:07:54,220 --> 01:08:01,020
next we get them so they get by second

01:07:57,670 --> 01:08:01,020
thing very useful to us

01:08:46,909 --> 01:08:50,850
the funding situation with embedded

01:08:49,409 --> 01:08:54,299
systems one left a little more hopeful

01:08:50,850 --> 01:08:59,730
about whether motivated because then if

01:08:54,299 --> 01:09:01,889
anyone can be gentleman I won't think

01:08:59,730 --> 01:09:06,560
about the various compositions end up

01:09:01,889 --> 01:09:06,560
kind of the until happened

01:09:17,270 --> 01:09:19,840
see

01:09:43,449 --> 01:09:46,659
in the

01:11:03,210 --> 01:11:10,100
we can solve that innovators simply by

01:11:07,570 --> 01:11:16,000
going to stay there basically

01:11:10,100 --> 01:11:16,000
I started my first kiss

01:11:49,929 --> 01:11:59,650
possible that if

01:12:14,640 --> 01:12:23,150
Owen is welcome to be awkward I don't

01:12:20,250 --> 01:12:23,150
think I was like

01:12:50,730 --> 01:12:55,570
so while we're on the subject of file

01:12:52,960 --> 01:12:57,610
systems the other costs that had to be

01:12:55,570 --> 01:12:59,790
paid a couple years ago was resurrect us

01:12:57,610 --> 01:13:03,489
what's the starting with that is it

01:12:59,790 --> 01:13:07,599
still being developed our runs a fleet

01:13:03,489 --> 01:13:09,820
is it's coming over in there they look

01:13:07,599 --> 01:13:14,969
for very well-known automates going into

01:13:09,820 --> 01:13:14,969
it most improvement

01:13:18,130 --> 01:13:23,889
what does it for this being my training

01:13:20,619 --> 01:13:25,389
after that two years hopefully your

01:13:23,889 --> 01:13:30,310
hands up if he person allotment is

01:13:25,389 --> 01:13:35,550
infected by us develop muscle memory and

01:13:30,310 --> 01:13:35,550
our nicest engineers from

01:13:49,350 --> 01:13:55,060
temporary protection for 70 years ago I

01:13:51,850 --> 01:13:57,430
actually have the kitchen sink was

01:13:55,060 --> 01:13:59,830
generosity less depends on the

01:13:57,430 --> 01:14:04,770
environment whether the water is taken

01:13:59,830 --> 01:14:04,770
out a regular file system used to be

01:14:06,030 --> 01:14:13,240
there's possibly but the barrier this is

01:14:11,200 --> 01:14:17,050
pretty high very of emerging processes

01:14:13,240 --> 01:14:18,390
with Linux on this maintenance cost for

01:14:17,050 --> 01:14:20,590
everybody involved

01:14:18,390 --> 01:14:23,950
we've handled bike reports with

01:14:20,590 --> 01:14:28,660
interaction with the ending the memory

01:14:23,950 --> 01:14:30,840
management abilities so it's not sort of

01:14:28,660 --> 01:14:30,840
thing

01:14:48,070 --> 01:14:55,640
my favorite arbitrary positions

01:14:52,550 --> 01:14:57,110
and most of our users can't really

01:14:55,640 --> 01:15:00,890
explain to them what next card is all

01:14:57,110 --> 01:15:03,310
about and training to arts and then

01:15:00,890 --> 01:15:05,930
their program will pay off Isaac with

01:15:03,310 --> 01:15:08,390
the director happy people of 10,000

01:15:05,930 --> 01:15:11,429
files and we responsible but is there

01:15:08,390 --> 01:15:14,429
any chance we can simply get widows

01:15:11,429 --> 01:15:16,150
or at least heaven be simple sides or

01:15:14,429 --> 01:15:19,000
like the end

01:15:16,150 --> 01:15:20,920
recycling processes the command line

01:15:19,000 --> 01:15:24,550
length limit you know whatever we reach

01:15:20,920 --> 01:15:26,110
about 2.6 stop X velocity six I want

01:15:24,550 --> 01:15:28,719
important because my pageant directory

01:15:26,110 --> 01:15:31,150
now become a monument just about Cuba

01:15:28,719 --> 01:15:33,159
it's not situation now the program pool

01:15:31,150 --> 01:15:37,330
as well where that says the latest

01:15:33,159 --> 01:15:38,500
economic standing wave or something but

01:15:37,330 --> 01:15:42,159
we're let the season relationship

01:15:38,500 --> 01:15:45,219
kernels dated October it is a problem

01:15:42,159 --> 01:15:47,110
yes there was a pretty group of impacts

01:15:45,219 --> 01:15:50,440
occurring for somebody at Google whose

01:15:47,110 --> 01:15:57,790
name get dynamically allocate all thing

01:15:50,440 --> 01:16:00,630
so that allocated that's not quite the

01:15:57,790 --> 01:16:03,130
bus terminus it's a difficult match

01:16:00,630 --> 01:16:06,090
Watson seven pages into the new

01:16:03,130 --> 01:16:06,090
processes Damien

01:16:24,630 --> 01:16:27,260
Tania

01:16:30,610 --> 01:16:34,910
can answer this question that's fine so

01:16:33,380 --> 01:16:37,040
the word on the street is that google

01:16:34,910 --> 01:16:39,860
has their own kernel they track outside

01:16:37,040 --> 01:16:41,630
of the mainline kernel and there's what

01:16:39,860 --> 01:16:45,430
I understand a lot of changes there I'm

01:16:41,630 --> 01:16:45,430
curious Google is

01:16:49,640 --> 01:16:53,480
other included will come and pull the

01:16:52,190 --> 01:17:00,550
patches the neighbors are of interest

01:16:53,480 --> 01:17:00,550
rate never ever it's basic

01:17:06,090 --> 01:17:11,500
much of our villages too much money but

01:17:09,580 --> 01:17:14,710
ever since directly for rednecks and

01:17:11,500 --> 01:17:16,180
Susan estimated tens of thousands of us

01:17:14,710 --> 01:17:28,740
out they have a big liberation invest

01:17:16,180 --> 01:17:28,740
it's not like that

01:17:32,809 --> 01:17:40,590
so large projects completed see it seems

01:17:37,499 --> 01:17:42,840
a terrible battle but me

01:17:40,590 --> 01:17:46,020
this is an awful language except maybe

01:17:42,840 --> 01:17:48,270
for a project - experiments than the

01:17:46,020 --> 01:17:52,110
right choice is there any chance that

01:17:48,270 --> 01:17:54,949
the most Awkward faculty who's another

01:17:52,110 --> 01:17:54,949
programming like

01:17:58,180 --> 01:18:09,340
I've seen friend of its abash company in

01:18:07,390 --> 01:18:13,720
the hole would give you a very emphatic

01:18:09,340 --> 01:18:21,340
answer to that aspect

01:18:13,720 --> 01:18:24,100
why did nothing that's needed but I

01:18:21,340 --> 01:18:39,370
think even like excellent system

01:18:24,100 --> 01:18:42,570
software in the communities that they

01:18:39,370 --> 01:18:42,570
said no I see no

01:19:03,200 --> 01:19:11,540
I don't have any education committees if

01:19:06,440 --> 01:19:12,860
somebody sees somebody kernel module to

01:19:11,540 --> 01:19:16,090
be able to accommodate and this may be a

01:19:12,860 --> 01:19:16,090
cost for us for doing that

01:19:42,230 --> 01:19:48,710
it is pretty limited so there is a flame

01:19:45,870 --> 01:19:54,480
right now which has been proposed for

01:19:48,710 --> 01:19:56,630
mr. de ruyter so there are days if you

01:19:54,480 --> 01:20:01,860
have a particularly bison to read some

01:19:56,630 --> 01:20:03,270
particular specialist you see numerical

01:20:01,860 --> 01:20:06,420
control company or scientific

01:20:03,270 --> 01:20:08,070
instruments then you have a complicated

01:20:06,420 --> 01:20:12,900
device what we need is the little

01:20:08,070 --> 01:20:15,360
skillet into the kernel jostle the

01:20:12,900 --> 01:20:19,380
package a result descend by seconds

01:20:15,360 --> 01:20:21,090
later we have now about 150 lives the

01:20:19,380 --> 01:20:23,190
other is in the great bulk of your

01:20:21,090 --> 01:20:25,020
sophisticated information within a from

01:20:23,190 --> 01:20:30,300
user space to spoken to a minimal

01:20:25,020 --> 01:20:32,100
sputters I don't think I had some

01:20:30,300 --> 01:20:34,890
concerns a bigger than this user for a

01:20:32,100 --> 01:20:37,770
license price opinion maybe something to

01:20:34,890 --> 01:20:39,090
stop getting decent kind of support the

01:20:37,770 --> 01:20:41,940
people convinced me otherwise

01:20:39,090 --> 01:20:44,220
really and especially us people we

01:20:41,940 --> 01:20:45,840
definitely run a quite a message driver

01:20:44,220 --> 01:20:52,530
which might include plating fortune or

01:20:45,840 --> 01:20:53,560
some things so I think that's a part of

01:20:52,530 --> 01:20:59,460
it

01:20:53,560 --> 01:21:03,820
basically these specialized devices

01:20:59,460 --> 01:21:06,090
became the usual is multiplying like for

01:21:03,820 --> 01:21:06,090
right

01:21:10,610 --> 01:21:13,510

YouTube URL: https://www.youtube.com/watch?v=JiIl123dz50


