Title: How To Design A Good API and Why it Matters
Publication date: 2011-03-31
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talks
January 24, 2007

ABSTRACT

Every day around the world, software developers spend much of their time working with a variety of Application Programming Interfaces (APIs). Some are integral to the core platform, some provide access to widely distributed frameworks, and some are written in-house for use by a few developers. Nearly all programmers occasionally function as API designers, whether they know it or not. A well-designed API can be a great asset to the organization that wrote it and to all who use it. Good APIs increase the pleasure and productivity of the developers who use them, the quality of the software they produce, and ultimately, the corporate bottom line....
Captions: 
	00:00:23,769 --> 00:00:27,599
>> First, I would like to thank you and welcome you all to the latest in our series of talks

00:00:27,599 --> 00:00:29,980
on advance topics and programming languages.

00:00:29,980 --> 00:00:33,780
The purpose of these series of talks is to expose all of the great domain knowledge in

00:00:33,780 --> 00:00:36,010
programming languages that we have at Google.

00:00:36,010 --> 00:00:39,370
So that--what that means is that everybody in this audience, all of you geniuses who

00:00:39,370 --> 00:00:44,510
work for Google and myself discounted, should give a talk.

00:00:44,510 --> 00:00:50,629
So please, come to me, my name Jeremy Manson email me, IM me whatever and tell me what

00:00:50,629 --> 00:00:52,719
talk you are going to give and I will set it up and give you a talk.

00:00:52,719 --> 00:00:57,910
You don't have to be an author like Josh or some of the people we have coming up in order

00:00:57,910 --> 00:01:00,449
to do so.

00:01:00,449 --> 00:01:01,710
Josh--and we're running late.

00:01:01,710 --> 00:01:05,239
Josh didn't want me to build him up too much and give him a swell head.

00:01:05,239 --> 00:01:07,650
So, I want to introduce him.

00:01:07,650 --> 00:01:12,909
I'll just say that in a company full of geniuses, it's his star that shines probably the most

00:01:12,909 --> 00:01:14,290
brightly.

00:01:14,290 --> 00:01:16,770
And I just want to...

00:01:16,770 --> 00:01:18,869
>> BLOCH: I'll get you for that.

00:01:18,869 --> 00:01:25,590
>> I just want to introduce this man whose boot heel I am not worthy to lick, Joshua

00:01:25,590 --> 00:01:29,439
Bloch ladies and gentlemen.

00:01:29,439 --> 00:01:37,040
>> BLOCH: Normally at this point, I thank my introducer for the introduction but today

00:01:37,040 --> 00:01:39,340
I think I'll dispense with that formality.

00:01:39,340 --> 00:01:46,969
So, I should--I should also say by the way that this is unfortunately rather a long talk.

00:01:46,969 --> 00:01:51,060
I try to have short talks with one or two key ideas but this subject matter just doesn't

00:01:51,060 --> 00:01:52,619
lend itself to that.

00:01:52,619 --> 00:01:56,779
So, please hold your questions till the end and in fact, we'll probably use up the hour

00:01:56,779 --> 00:02:00,289
without questions but then I'll hang around for as long as you want and answer all the

00:02:00,289 --> 00:02:02,299
questions that you have.

00:02:02,299 --> 00:02:05,270
So, why is API design important?

00:02:05,270 --> 00:02:10,069
Well, APIs can be among a company's greatest assets.

00:02:10,069 --> 00:02:14,840
A good API is something that people invest heavily in.

00:02:14,840 --> 00:02:17,860
They do this in obvious ways and in less obvious ways.

00:02:17,860 --> 00:02:22,350
Obvious ways are may be a by product built around the APIs.

00:02:22,350 --> 00:02:23,370
They write to the API.

00:02:23,370 --> 00:02:25,810
But the less obvious ways is they learn it.

00:02:25,810 --> 00:02:29,890
They spend hours and hours--actually, they spend months learning the APIs.

00:02:29,890 --> 00:02:33,430
And once they've have done that, you know, they don't want to learn a new one because

00:02:33,430 --> 00:02:37,090
they have to unlearn everything they know and replace it with something else.

00:02:37,090 --> 00:02:42,000
And furthermore, the API is just wired throughout the infrastructure at a company.

00:02:42,000 --> 00:02:46,700
So, a successful API can make a company, can give a franchise that last.

00:02:46,700 --> 00:02:55,780
So--I guess it's about twenty-five years now and similarly a bad API can be among a company's

00:02:55,780 --> 00:02:56,780
greatest liabilities.

00:02:56,780 --> 00:02:59,180
And there are a couple of reasons for this.

00:02:59,180 --> 00:03:05,820
First of all, a bad API can cause an unending stream of, you know, support phone calls because

00:03:05,820 --> 00:03:11,780
people cannot make the thing do what it ought to do and it can inhibit a company's ability

00:03:11,780 --> 00:03:15,650
to move forward because once you have a bad API you cannot change it at will.

00:03:15,650 --> 00:03:18,170
You're pretty much stuck with it forever.

00:03:18,170 --> 00:03:20,420
You have one chance to get it right.

00:03:20,420 --> 00:03:24,790
So, that's pretty scary and with that in mind, you want to learn how to make APIs that will

00:03:24,790 --> 00:03:26,790
stand the test of time.

00:03:26,790 --> 00:03:31,390
So, now you know why API design is important but why is it important to you?

00:03:31,390 --> 00:03:34,600
Not all of you may think of yourselves as API designers.

00:03:34,600 --> 00:03:38,760
Well, it turns out that all of you are API designers.

00:03:38,760 --> 00:03:42,510
Anyone who programs a computer is an API designer.

00:03:42,510 --> 00:03:47,990
And the reason is that good programming is inherently modular and these inter-modular

00:03:47,990 --> 00:03:51,010
boundaries are themselves APIs.

00:03:51,010 --> 00:03:54,570
Furthermore, good APIs tend to get reused.

00:03:54,570 --> 00:03:59,100
If you've written a module and it's good at doing something, you now, one of these days

00:03:59,100 --> 00:04:01,710
one of your co-worker is going to need to do the same thing.

00:04:01,710 --> 00:04:05,790
And gosh, you know you've already got this module that does it but once he's using that

00:04:05,790 --> 00:04:09,810
API, you are no longer free to change it at will because if you change it you'll break

00:04:09,810 --> 00:04:10,810
his program.

00:04:10,810 --> 00:04:15,010
And if he has ten friends and they all start using it then you're really hosed.

00:04:15,010 --> 00:04:21,040
Finally, thinking in terms of API design tends to improve the quality of the programs that

00:04:21,040 --> 00:04:22,040
you write.

00:04:22,040 --> 00:04:25,090
It tends to sort of keep you from just hacking things together.

00:04:25,090 --> 00:04:30,031
It tends to make you want to write nice units, you now, that are--that are composable, that

00:04:30,031 --> 00:04:32,290
are reusable and that are sensible.

00:04:32,290 --> 00:04:37,460
Now, one other question we've got to get out of the way at the beginning is, why am I talking

00:04:37,460 --> 00:04:42,020
about API at what is billed as a language design series?

00:04:42,020 --> 00:04:45,539
And the glib answer of course is that Jeremy asked me to do it.

00:04:45,539 --> 00:04:51,080
And Jeremy used to be friend, so, of course, I said, "Yeah, of course I'll do it."

00:04:51,080 --> 00:04:55,969
But in fact the real answer is that API design and language design are very, very similar.

00:04:55,969 --> 00:05:01,599
The only real difference is that API design is constrained by the syntactic--sorry, the

00:05:01,599 --> 00:05:04,340
syntax of the language for which you're writing the API.

00:05:04,340 --> 00:05:07,719
Whereas, when you're designing a language you have the flexibility to do anything you

00:05:07,719 --> 00:05:09,689
like with the syntax.

00:05:09,689 --> 00:05:16,169
But in fact, whether you're designing a language or an API, you are creating a tool for programmers

00:05:16,169 --> 00:05:21,259
to express their intent to the machine and to other programmers, who read the program,

00:05:21,259 --> 00:05:24,680
maintain it, modify it and so forth.

00:05:24,680 --> 00:05:31,759
Finally, these days you don't really think in terms of a language or a library alone.

00:05:31,759 --> 00:05:37,460
A language and a library together comprise a platform and when you're designing a language,

00:05:37,460 --> 00:05:42,259
you design the core libraries hand in hand with the language.

00:05:42,259 --> 00:05:46,719
So, really the skill set for designing good APIs and for designing languages is pretty

00:05:46,719 --> 00:05:47,740
much the same.

00:05:47,740 --> 00:05:51,789
So, what are the characteristics of a good API?

00:05:51,789 --> 00:05:56,860
First of all, it's easy to learn and it's easy to use, even without documentation.

00:05:56,860 --> 00:05:59,710
So, a good API should be easy to memorize.

00:05:59,710 --> 00:06:02,439
It should just plain make sense.

00:06:02,439 --> 00:06:06,490
And the flip side of that is, not only should it be easy to use a good API but it should

00:06:06,490 --> 00:06:09,840
hard to misuse a good API.

00:06:09,840 --> 00:06:14,360
It should be hard or impossible to use--misuse a good API.

00:06:14,360 --> 00:06:18,699
That is basically, a good API should simply force you to do the right thing.

00:06:18,699 --> 00:06:22,660
It should be easy to read and to maintain code written to that API.

00:06:22,660 --> 00:06:27,719
The API should be sufficiently powerful to do what it has to do.

00:06:27,719 --> 00:06:30,509
Note that I didn't say the API should be powerful.

00:06:30,509 --> 00:06:35,249
It is not the case that the more powerful an API is, the better it is.

00:06:35,249 --> 00:06:39,529
It should basically be just powerful enough to do what it needs to do.

00:06:39,529 --> 00:06:44,249
But it should be easy to evolve the API over time because there will be new needs later

00:06:44,249 --> 00:06:45,249
on.

00:06:45,249 --> 00:06:48,419
So, what you want to do is want to write an API that meets its requirements and that can

00:06:48,419 --> 00:06:50,330
evolve to meet future requirements.

00:06:50,330 --> 00:06:53,610
And finally, the API has to be appropriate to the audience.

00:06:53,610 --> 00:07:03,300
What is a good API for let's say a Wall Street analyst is probably not a good API for a physicist

00:07:03,300 --> 00:07:05,139
because they have different terminology.

00:07:05,139 --> 00:07:06,139
They think differently.

00:07:06,139 --> 00:07:10,060
So their API has to be aimed at its audience.

00:07:10,060 --> 00:07:12,099
So now, we know what the characteristics are.

00:07:12,099 --> 00:07:13,369
How do we achieve them?

00:07:13,369 --> 00:07:15,339
And that's what's the rest of this talk is about.

00:07:15,339 --> 00:07:18,120
The talk is divided into five sections.

00:07:18,120 --> 00:07:20,560
The first one is on the process of the API design.

00:07:20,560 --> 00:07:25,009
I'm not a big process weenie but I found over the years that there are certain things that

00:07:25,009 --> 00:07:29,190
all good API designs have in common in terms of the process used to create them.

00:07:29,190 --> 00:07:30,430
So, I'll try to get over that.

00:07:30,430 --> 00:07:35,139
Then, the general principles of API design, then those principles as they apply to classes,

00:07:35,139 --> 00:07:37,839
as they apply to methods, and as they apply to exceptions.

00:07:37,839 --> 00:07:42,779
And finally, if I have time I'll show a couple of refactorings where we improve API designs.

00:07:42,779 --> 00:07:46,750
So, what is the process of API design like?

00:07:46,750 --> 00:07:50,821
Well, the first thing you got to do is you got to gather the requirements but do it with

00:07:50,821 --> 00:07:54,030
a healthy dose of speck--of skepticism.

00:07:54,030 --> 00:07:59,030
Because often when you ask people, you know, "Well, what does this API have to do for you?"

00:07:59,030 --> 00:08:05,699
What you'll get won't be a real set of requirements, it'll be a set of proposed solutions and a

00:08:05,699 --> 00:08:06,930
better solution may exist.

00:08:06,930 --> 00:08:12,529
So, you know, if someone tells you, let's say, "We need to precisely control the garbage

00:08:12,529 --> 00:08:17,520
collection intervals and the maximum time that each garbage collection can take."

00:08:17,520 --> 00:08:19,939
You know, that's not really a requirement.

00:08:19,939 --> 00:08:24,520
I mean, the requirement is, you know, we need to be able to run a server smoothly while

00:08:24,520 --> 00:08:26,639
any garbage collection takes place.

00:08:26,639 --> 00:08:30,469
How you choose to achieve that is up to you.

00:08:30,469 --> 00:08:37,880
Your job is to extract the requirements from the stakeholders in your API and often it's

00:08:37,880 --> 00:08:39,969
real give and take process.

00:08:39,969 --> 00:08:44,600
Once you've got the requirements, they should take the form of used cases, and by used cases,

00:08:44,600 --> 00:08:48,140
I simply mean, the problems that your API should be able to solve.

00:08:48,140 --> 00:08:52,430
And these are extremely important because they provide the benchmark against which you

00:08:52,430 --> 00:08:55,140
can measure any proposed solution.

00:08:55,140 --> 00:09:00,110
One thing you should keep in mind is that it can be easier and more rewarding to build

00:09:00,110 --> 00:09:02,910
a more general solution than what you've been asked to do.

00:09:02,910 --> 00:09:05,751
This doesn't mean you should just say, "Oh, I'm going to build a framework," every time

00:09:05,751 --> 00:09:07,510
someone asks you to do something.

00:09:07,510 --> 00:09:13,260
But sometimes the more specific thing is more difficult to build as well as being less powerful.

00:09:13,260 --> 00:09:17,760
So, always keep an open when you're--when you're looking at those initial requirements.

00:09:17,760 --> 00:09:22,120
Oh, let's see, I guess I have another example here of what they say and what they mean.

00:09:22,120 --> 00:09:25,970
When they say, "We need new data structures and RPCs with the Version 2 attributes," this

00:09:25,970 --> 00:09:29,320
actually happened to me at a company called Transarc, you know, when we were kind of upgrading.

00:09:29,320 --> 00:09:32,680
They said, you know, "Make a whole new set of data structures and a whole new set of

00:09:32,680 --> 00:09:33,690
APIs."

00:09:33,690 --> 00:09:38,300
What they really meant was, "We need a new data format that will accommodate all further

00:09:38,300 --> 00:09:41,130
evolution in the internal data structures."

00:09:41,130 --> 00:09:44,350
You know, because you don't have to want to have to make a whole new set of data structures

00:09:44,350 --> 00:09:49,080
and a whole new set of on the wire and on disk interfaces every time you decide to add

00:09:49,080 --> 00:09:50,880
a few attributes to your server.

00:09:50,880 --> 00:09:55,400
So in fact, I made the system much more dynamic and we never had to do that again.

00:09:55,400 --> 00:10:01,620
So, you should start with a really short spec, one page is ideal.

00:10:01,620 --> 00:10:05,710
At this stage in an API design, agility definitely trumps completeness.

00:10:05,710 --> 00:10:11,600
The worst thing you can do is to send six smart guys off into a room and have them sit

00:10:11,600 --> 00:10:17,200
there with the door closed for six months and come out with a 240 specification document.

00:10:17,200 --> 00:10:19,750
And believe me this has been done many, many times.

00:10:19,750 --> 00:10:23,580
It's an awful idea because at that point, first of all, their ego is invested in what

00:10:23,580 --> 00:10:24,650
they've just done.

00:10:24,650 --> 00:10:27,200
They're going to build it even if it's a piece of crap.

00:10:27,200 --> 00:10:32,710
And second of all, you know, how do you know if it's any good?

00:10:32,710 --> 00:10:34,899
It's like this big, long, hairy spec.

00:10:34,899 --> 00:10:35,899
It's no longer agile.

00:10:35,899 --> 00:10:40,810
If they made a fundamental mistake, then you've got to change all 240 pages of it.

00:10:40,810 --> 00:10:45,640
But it may fail to satisfy some sort of key requirement that they didn't really understand

00:10:45,640 --> 00:10:46,640
before they started.

00:10:46,640 --> 00:10:51,210
So, what you want to do in the beginning is have the entire API spec on one page.

00:10:51,210 --> 00:10:55,690
In this way, you can bounce that spec off as many stakeholders as possible.

00:10:55,690 --> 00:10:57,700
Listen to what they have to say and take it seriously.

00:10:57,700 --> 00:11:01,800
If they say, "No, I'm sorry, this won't do for me because I cannot write such and such

00:11:01,800 --> 00:11:03,490
a program," think about it.

00:11:03,490 --> 00:11:06,710
You know, you may say, "Well, you shouldn't be writing that kind of program.

00:11:06,710 --> 00:11:07,930
It's a really bad idea."

00:11:07,930 --> 00:11:11,030
But more likely, you may say, "Oh gee, I didn't think of that.

00:11:11,030 --> 00:11:12,510
This really is important.

00:11:12,510 --> 00:11:13,700
What if we structure it this way?"

00:11:13,700 --> 00:11:15,520
The whole thing is only a page long.

00:11:15,520 --> 00:11:17,960
You can do major refactorings in ten minutes.

00:11:17,960 --> 00:11:20,720
If you keep the spec short, it's easy to modify.

00:11:20,720 --> 00:11:25,920
And you flesh that spec out only as you gain confidence that you're on the right track.

00:11:25,920 --> 00:11:28,500
And this necessarily involves coding.

00:11:28,500 --> 00:11:33,010
In particular, it involves coding to the API that you are defining.

00:11:33,010 --> 00:11:35,450
It doesn't involve implementing the API.

00:11:35,450 --> 00:11:38,220
It involves pretending it's already been implemented.

00:11:38,220 --> 00:11:40,520
So, what does it look like when you do it right?

00:11:40,520 --> 00:11:44,320
Well, here's an example that I was writing at about the time that I was putting this

00:11:44,320 --> 00:11:49,180
talk together for OOPSLA some number of months ago.

00:11:49,180 --> 00:11:53,460
Someone wanted the ability to retry a computation in the face of failure.

00:11:53,460 --> 00:11:57,740
And I said, "Oh well, you know, we have this executor framework, otherwise known as the

00:11:57,740 --> 00:11:59,320
executor framework."

00:11:59,320 --> 00:12:06,350
And really, all we want here is a retry policy that tells you how you might choose to retry

00:12:06,350 --> 00:12:07,480
the thing in the face of failure.

00:12:07,480 --> 00:12:12,180
So, you know, here's a little interface and it's got a couple of methods.

00:12:12,180 --> 00:12:15,690
One tells you, if a given failure is recoverable.

00:12:15,690 --> 00:12:18,590
You pass in the exception and it just gives you true or false.

00:12:18,590 --> 00:12:21,430
We should try to recover from this one or we shouldn't.

00:12:21,430 --> 00:12:27,590
And the second one computes the next delay in terms of, the initial start time and the

00:12:27,590 --> 00:12:33,230
number of previous retries and by passing in all these data, the actual retry policy

00:12:33,230 --> 00:12:34,230
can be stateless.

00:12:34,230 --> 00:12:36,270
So, you can have singletons.

00:12:36,270 --> 00:12:38,860
You can have a retry policy called exponential backoff.

00:12:38,860 --> 00:12:42,170
But you're going to have to store any data in each exponential back-off instance.

00:12:42,170 --> 00:12:46,750
It really is just a retry policy and it's called exponential backoff.

00:12:46,750 --> 00:12:48,370
And that's kind of all there is to that one.

00:12:48,370 --> 00:12:49,760
And this isn't really very complete.

00:12:49,760 --> 00:12:54,310
This is not, you know, a spec of a quality that I could use for Java doc.

00:12:54,310 --> 00:12:58,250
It's not a spec that someone could use to implement to but it's a spec that's good enough

00:12:58,250 --> 00:12:59,830
for someone to look at it and say, "Yes.

00:12:59,830 --> 00:13:01,590
It does do what I need or it doesn't."

00:13:01,590 --> 00:13:04,720
The rest of it is on another slide here.

00:13:04,720 --> 00:13:09,990
This is a set of static utilities that lets you actually use retry policies.

00:13:09,990 --> 00:13:11,380
So, what can you do?

00:13:11,380 --> 00:13:16,140
Well, the first thing you can is you can pass in an executor service and retry policy and

00:13:16,140 --> 00:13:17,740
get a retrying executor service.

00:13:17,740 --> 00:13:20,580
It implements the same interface, which is executor service.

00:13:20,580 --> 00:13:24,260
So, if you already know how to use an executor service, you know how to use the retrying

00:13:24,260 --> 00:13:26,400
executor service and that's great by the way.

00:13:26,400 --> 00:13:30,370
That's a good way to keep the sort of the conceptual weight of an API small.

00:13:30,370 --> 00:13:36,640
Use interfaces that have already been designed--defined, in this case, executor service.

00:13:36,640 --> 00:13:37,970
And what else do we have?

00:13:37,970 --> 00:13:41,300
We have another kind of a retrying executor service.

00:13:41,300 --> 00:13:42,870
What are--what are the difference between the first two?

00:13:42,870 --> 00:13:46,700
I haven't looked at this for a while so, I apologize for that.

00:13:46,700 --> 00:13:50,520
Anyway, it doesn't--it doesn't matter.

00:13:50,520 --> 00:13:54,650
And then, we have a couple of wrappers, one of which takes a callable and returns a retrying

00:13:54,650 --> 00:13:57,430
callable and takes a runnable, returns to retrying runnable.

00:13:57,430 --> 00:14:01,590
And then, we have a couple examples of the retry policies themselves.

00:14:01,590 --> 00:14:05,870
These are static factories, we have, if you want an exponential backoff, you get one.

00:14:05,870 --> 00:14:09,580
And these are the parameters that describe your exponential backoff.

00:14:09,580 --> 00:14:11,510
What's the initial delay?

00:14:11,510 --> 00:14:21,290
In what unit, you know, 10 seconds, a hundred milliseconds, whatever and then, the timeout,

00:14:21,290 --> 00:14:22,490
which I'm not sure what that means.

00:14:22,490 --> 00:14:24,082
So, by the way, this is actually interesting.

00:14:24,082 --> 00:14:26,220
This tells me this wasn't quite good enough, you know.

00:14:26,220 --> 00:14:29,100
What I wanted to show you is that something that's really simple.

00:14:29,100 --> 00:14:32,960
It fits on the slide or two, is enough to communicate your intent and enough to sort

00:14:32,960 --> 00:14:37,400
of, figure out whether it's good enough and you know, try it out.

00:14:37,400 --> 00:14:41,600
And I think the answer here is it's almost good enough but not quite good enough.

00:14:41,600 --> 00:14:44,970
I guess, the timeout probably, is the overall timeout.

00:14:44,970 --> 00:14:49,520
Like after how long of trying and retrying do you finally give up.

00:14:49,520 --> 00:14:52,430
But I think it should have said that somewhere on this.

00:14:52,430 --> 00:14:53,652
But anyway, you get the idea.

00:14:53,652 --> 00:14:57,670
The idea is that this is a very small description of an API.

00:14:57,670 --> 00:15:00,860
But it's big enough to find out if it's good enough to do what needs to be done.

00:15:00,860 --> 00:15:03,640
And if it's not, it's easy to modify it.

00:15:03,640 --> 00:15:05,830
You should write to the API early and often.

00:15:05,830 --> 00:15:09,080
Of course, you should start before you've implemented the API because this saves you

00:15:09,080 --> 00:15:13,080
from having to throw away an implementation of a bad API.

00:15:13,080 --> 00:15:17,340
You know if you--if you first specify it, then implement it, then try the implementation

00:15:17,340 --> 00:15:21,330
and decide that the API was garbage, well, you've wasted lots of time implementing it.

00:15:21,330 --> 00:15:25,950
And as I said, you should start before you've even specified it properly because that saves

00:15:25,950 --> 00:15:30,680
you from having to throw away detailed specifications for broken APIs.

00:15:30,680 --> 00:15:35,620
You should continue writing to the API as you flesh it out and this is important.

00:15:35,620 --> 00:15:40,000
Some people, sort of stop writing to the API about halfway through the process and just

00:15:40,000 --> 00:15:42,350
go on this death march to implementation.

00:15:42,350 --> 00:15:46,371
The problem with that is you get nasty surprises about a week before you ship when you try

00:15:46,371 --> 00:15:49,410
writing to it again and you find that, you know, "Oh, my gosh.

00:15:49,410 --> 00:15:53,120
It actually doesn't solve this important case that we thought it solved."

00:15:53,120 --> 00:15:54,400
And some people worry.

00:15:54,400 --> 00:15:58,250
They worry that, you know, that all these coding to the API is a waste of time when

00:15:58,250 --> 00:16:00,050
they should be implementing it.

00:16:00,050 --> 00:16:02,280
But that nothing could be further from the truth.

00:16:02,280 --> 00:16:07,730
Those initial pieces of code that you write to any API are among the most important pieces

00:16:07,730 --> 00:16:09,660
of code that you'll ever write to it.

00:16:09,660 --> 00:16:17,220
The code lives on in the examples that you publish for how to use that API.

00:16:17,220 --> 00:16:20,250
And those examples tend to get emulated heavily.

00:16:20,250 --> 00:16:24,800
If you get them right, you seeded the market with good uses of your API.

00:16:24,800 --> 00:16:29,690
If you get them wrong, conversely, you know, you've ensured that there will be broken programs

00:16:29,690 --> 00:16:32,320
floating around the web for the next ten years.

00:16:32,320 --> 00:16:35,380
And I used to, you know believe this with all my heart and soul.

00:16:35,380 --> 00:16:37,661
But now, I actually can point to a proof of it.

00:16:37,661 --> 00:16:42,050
It turns out in the last OOPSLA, there was a paper published called Design Fragments

00:16:42,050 --> 00:16:44,710
by Fairbanks, Garlan and Scherlis from CMU.

00:16:44,710 --> 00:16:51,620
And they actually traced mistakes in the original applets that were shipped out with, you know,

00:16:51,620 --> 00:16:57,580
the first release of Java into broken concurrent programs, thousands of them that still exist

00:16:57,580 --> 00:16:58,860
on the web today.

00:16:58,860 --> 00:17:03,320
So, you know, the way I put this is, example program should be exemplary.

00:17:03,320 --> 00:17:05,240
There's a reason they call them example programs.

00:17:05,240 --> 00:17:09,610
And the programs that--the first programs that you write to an API, as you are fleshing

00:17:09,610 --> 00:17:13,480
it out, invariably become the example programs.

00:17:13,480 --> 00:17:17,390
You know, so, you know, my rule of thumb is you should spend ten times as much time on

00:17:17,390 --> 00:17:20,809
every line of example code as you do production code.

00:17:20,809 --> 00:17:24,520
That may sound backwards to you but I really believe it.

00:17:24,520 --> 00:17:29,020
Writing to an SPI, that is a Service Provider Interface is even more important than writing

00:17:29,020 --> 00:17:31,410
to any other kind of API.

00:17:31,410 --> 00:17:34,920
You all probably what SPIs are or maybe you don't.

00:17:34,920 --> 00:17:37,140
If you know an SPI is, raise your hand.

00:17:37,140 --> 00:17:38,140
Okay.

00:17:38,140 --> 00:17:45,510
So, an SPI is a special kind of an API which you use to provide a new means of doing something.

00:17:45,510 --> 00:17:51,821
It's not the API which the programmers write to rather, it's the plug-in API that, let's

00:17:51,821 --> 00:17:57,760
say, lets--RSADSI Incorporated provides their encryption methods and Sun Microsystems provide

00:17:57,760 --> 00:17:58,900
their encryption methods.

00:17:58,900 --> 00:18:03,690
So, the user of this encryption API can use a higher level API, which then dispatches

00:18:03,690 --> 00:18:04,790
to these encryption methods.

00:18:04,790 --> 00:18:11,100
And the thing about SPIs is that you're supposed to be able to hide very, very different implementations

00:18:11,100 --> 00:18:12,650
underneath them.

00:18:12,650 --> 00:18:17,520
And if you, you know, write an SPI and you only have one provider it turns out that is

00:18:17,520 --> 00:18:21,780
a practical matter, you will probably never be able to support another.

00:18:21,780 --> 00:18:25,430
Once you try to do the second, you'll find that there's something about that SPI that

00:18:25,430 --> 00:18:29,510
ties it forever to the only implementation you actually thought about.

00:18:29,510 --> 00:18:32,550
If on the other hand, you do two implementations rather than one.

00:18:32,550 --> 00:18:34,450
Then, you'll probably be good enough.

00:18:34,450 --> 00:18:38,240
You'll probably be able to support subsequent ones with some difficulty.

00:18:38,240 --> 00:18:41,930
But if you do three, it will probably work fine for any number.

00:18:41,930 --> 00:18:46,730
If it works for three, the fourth won't all be that different from each of the first three.

00:18:46,730 --> 00:18:50,920
I found this out myself and then, I saw it in a book, Will Tracz discovered this and

00:18:50,920 --> 00:18:55,920
called it The Rule of Threes in a book, which was subtitled Confessions of a Used Program

00:18:55,920 --> 00:18:58,980
Salesman because it was a book about a software reuse.

00:18:58,980 --> 00:19:03,930
And by the way, here we explain the subtle coding that is used throughout this talk.

00:19:03,930 --> 00:19:07,010
Whenever you see something green, it means this is good, do it this way.

00:19:07,010 --> 00:19:14,040
And when you see something in red, it means this is bad, don't do it that way.

00:19:14,040 --> 00:19:17,970
You should maintain realistic expectations throughout the process of API design.

00:19:17,970 --> 00:19:21,080
It turns out that most API designs are over constrained.

00:19:21,080 --> 00:19:23,420
People want them to do more than they can possibly do.

00:19:23,420 --> 00:19:26,180
So, you are going to have to make compromises.

00:19:26,180 --> 00:19:28,300
You cannot please everyone.

00:19:28,300 --> 00:19:31,110
If you try to please everyone, you come up with a pig.

00:19:31,110 --> 00:19:35,320
You come with big, nasty APIs that no one will ever be able to use properly.

00:19:35,320 --> 00:19:36,360
So, what you should do?

00:19:36,360 --> 00:19:42,460
And this may sound strange, is you should aim to displease everyone equally.

00:19:42,460 --> 00:19:48,470
The idea is that, you know if one of your important stakeholders is very displeased

00:19:48,470 --> 00:19:52,770
and the others are really pleased, that's probably a problem because your API isn't

00:19:52,770 --> 00:19:54,440
doing something it has to do.

00:19:54,440 --> 00:19:58,960
If everyone is like less than a 100% happy but they're all happy enough then, you've

00:19:58,960 --> 00:20:00,130
probably done the right thing.

00:20:00,130 --> 00:20:04,850
But do not misinterpret this as saying I favor design by committee and you should take everyone's

00:20:04,850 --> 00:20:06,580
ideas and mush them altogether.

00:20:06,580 --> 00:20:11,400
You do need one sort of strong design lead that can ensure that the API that you're design

00:20:11,400 --> 00:20:19,340
is cohesive and pretty and clearly the work of, you know, one single mind or at least

00:20:19,340 --> 00:20:21,210
a single minded body.

00:20:21,210 --> 00:20:24,290
And that's always a little bit of a trade off, being able to satisfy the needs of many

00:20:24,290 --> 00:20:30,010
costumers and yet produce something that is, you know, beautiful and cohesive.

00:20:30,010 --> 00:20:31,080
Expect to make mistakes.

00:20:31,080 --> 00:20:32,450
API design is hard.

00:20:32,450 --> 00:20:37,130
Now luckily, a few years of real world use will always flush out the mistakes.

00:20:37,130 --> 00:20:40,330
Unfortunately, by that time it's like too late to do anything about them.

00:20:40,330 --> 00:20:43,510
Although, you can write nice talks and tell people about the mistakes so they don't make

00:20:43,510 --> 00:20:46,510
them again and it's kind of what I'm doing here today.

00:20:46,510 --> 00:20:50,100
So, given that you're going to make mistakes and you're going to be stuck with the original

00:20:50,100 --> 00:20:54,870
API, write the API so that at least you can sort of add to it and produce something that

00:20:54,870 --> 00:20:58,960
will help you get around the shortcomings of your original designs.

00:20:58,960 --> 00:21:04,059
The recent example of that in my life is in the collections API which I did around 1997,

00:21:04,059 --> 00:21:05,059
1998.

00:21:05,059 --> 00:21:09,610
There were some real flaws in the sorted sets and sort of map implementations.

00:21:09,610 --> 00:21:11,980
In particular, you know, they're a little bit asymmetric.

00:21:11,980 --> 00:21:16,050
It's much easier to a forward than backward and there are couple other things.

00:21:16,050 --> 00:21:19,130
I knew about these flaws at that time but I didn't know how to fix them.

00:21:19,130 --> 00:21:21,660
However, we were able to extend that API.

00:21:21,660 --> 00:21:24,980
So, if you look at the most recent release of Java 6.

00:21:24,980 --> 00:21:28,830
You'll see something called the Navigable Set and Navigable Map, which extends sorted

00:21:28,830 --> 00:21:34,040
set and sorted map and provide, you know, additional methods that basically fix those

00:21:34,040 --> 00:21:35,040
difficulties.

00:21:35,040 --> 00:21:38,570
You know and it's not a perfect solution because there are some things that implement the old--the

00:21:38,570 --> 00:21:41,080
older interfaces and they're not fixed yet.

00:21:41,080 --> 00:21:45,770
But at least all the standard collection implementations from Sun now are fixed.

00:21:45,770 --> 00:21:49,350
So, what are the general principles of good API design?

00:21:49,350 --> 00:21:52,490
First all, an API should do one thing and do it well.

00:21:52,490 --> 00:21:57,870
And I should say that almost all of what I'm going to say for the next five minutes may

00:21:57,870 --> 00:22:00,220
just sound like motherhood and apple pie.

00:22:00,220 --> 00:22:02,260
But, there's more to it than that.

00:22:02,260 --> 00:22:04,370
I'm going to try to give you actionable advice.

00:22:04,370 --> 00:22:08,660
I'm going to try to take the sort of the standard old souls like in API should do one thing

00:22:08,660 --> 00:22:12,900
and do it well and see what it really means and tell you how to achieve it.

00:22:12,900 --> 00:22:18,370
So, you know, in this case, the functionality should be easy to explain.

00:22:18,370 --> 00:22:23,720
If it's not easy to explain, then it's not doing one thing and doing it well.

00:22:23,720 --> 00:22:24,810
It's a mess.

00:22:24,810 --> 00:22:29,460
If you can't come up with a good name for it, then it's a mess.

00:22:29,460 --> 00:22:33,290
The names are the API talking back to you, so listen to them.

00:22:33,290 --> 00:22:37,300
When you try to name those methods and those classes, you know, if you come up with the

00:22:37,300 --> 00:22:44,800
really complicated name like DynAnyFactoryOperations or underscore BindingIteratorImplBase switch,

00:22:44,800 --> 00:22:49,840
you know, actually violates the naming conventions of platen--platform, sorry.

00:22:49,840 --> 00:22:54,600
ENCODING_CDR_ENCAPS, you know, clearly you've got problems.

00:22:54,600 --> 00:22:57,630
Any API that contains this sort of stuff is a mess.

00:22:57,630 --> 00:22:59,580
Oh, what about this, OMGVMCID?

00:22:59,580 --> 00:23:04,480
I know OMG is, "Oh, my god," but I can't--I can't figure out the rest of it.

00:23:04,480 --> 00:23:08,240
And by the way least you think I'm just making this stuff up, all of these comes from an

00:23:08,240 --> 00:23:10,770
actual Java platform API.

00:23:10,770 --> 00:23:18,800
And I won't tell what it is except to say that it's club Good API names are like a font.

00:23:18,800 --> 00:23:20,309
Yeah, I know what a font is.

00:23:20,309 --> 00:23:23,480
Sure, you know, it's like, it's italic or bold or whatever.

00:23:23,480 --> 00:23:25,190
You know, a set, I know what a set is.

00:23:25,190 --> 00:23:32,170
A private key, a lock, a ThreadFactory, these things are, you know, they instantly communicate

00:23:32,170 --> 00:23:33,220
what they are.

00:23:33,220 --> 00:23:37,560
And the methods, you know the classes all of them should be like that.

00:23:37,560 --> 00:23:39,960
Looking at them, you know, it should be clear what they are.

00:23:39,960 --> 00:23:42,680
And good names drive good designs.

00:23:42,680 --> 00:23:44,890
You know, once you have something that's called a set.

00:23:44,890 --> 00:23:46,010
You know what the operations are.

00:23:46,010 --> 00:23:50,370
You insert things from sets, you remove, you test for containments.

00:23:50,370 --> 00:23:56,040
So, good names drive good designs and bad names are an indication of bad designs.

00:23:56,040 --> 00:23:58,430
So, listen to those names speaking to you.

00:23:58,430 --> 00:24:02,860
And if you just you can't get it to work out right, then you probably not trying to build

00:24:02,860 --> 00:24:03,960
something reasonable.

00:24:03,960 --> 00:24:08,450
So, always remain amenable to splitting a module up if you're trying to cramp too much

00:24:08,450 --> 00:24:13,460
into a module, or to putting multiple modules together, if you're trying to expose sort

00:24:13,460 --> 00:24:15,840
of internal details that ought to be hidden.

00:24:15,840 --> 00:24:19,280
Maybe you should just make a bigger module that hides some of those details.

00:24:19,280 --> 00:24:23,200
An API should be as small as possible but no smaller.

00:24:23,200 --> 00:24:25,770
This principle is usually attributed to Einstein.

00:24:25,770 --> 00:24:29,309
Although I looked really, really hard and I don't believe he ever said it.

00:24:29,309 --> 00:24:33,630
I believe that it's, you know--he probably believed it but he didn't say it.

00:24:33,630 --> 00:24:39,610
At any rate the API should satisfy its requirements and if you only remember one thing from the

00:24:39,610 --> 00:24:42,040
talk today, please remember this.

00:24:42,040 --> 00:24:45,030
When it doubt, leave it out.

00:24:45,030 --> 00:24:46,179
That applies to everything.

00:24:46,179 --> 00:24:51,960
It applies to functionality, to classes, to methods, to parameters within a method, anything.

00:24:51,960 --> 00:24:57,210
If you have any doubts about whether to include something, leave it out.

00:24:57,210 --> 00:25:00,980
You'll probably be able to add it later, but you most certainly will not be able to take

00:25:00,980 --> 00:25:03,090
it out once you put it into an API.

00:25:03,090 --> 00:25:06,730
Once you put it in people will be using it, if you take it out they will scream bloody

00:25:06,730 --> 00:25:07,730
murder.

00:25:07,730 --> 00:25:11,050
So, if you ever have any doubts about whether to include something, leave it out.

00:25:11,050 --> 00:25:15,240
And if that's all you take away with you from today's talk, then, I think it's been worth

00:25:15,240 --> 00:25:16,450
your hour.

00:25:16,450 --> 00:25:18,540
Of course, that's just my judgment.

00:25:18,540 --> 00:25:23,300
Anyway, the--when you're thinking about the size of an API, the conceptual weight is more

00:25:23,300 --> 00:25:24,800
important than the bulk.

00:25:24,800 --> 00:25:29,380
By bulk, I mean the number of methods, the number of class, the number parameters.

00:25:29,380 --> 00:25:32,299
What's really important is the number of concepts.

00:25:32,299 --> 00:25:36,380
When I'm learning this API, how many different things do I have to learn about?

00:25:36,380 --> 00:25:41,350
And there are a number of ways to decrease the conceptual weight of an API.

00:25:41,350 --> 00:25:44,299
The most important one is reusing interfaces.

00:25:44,299 --> 00:25:48,510
So, for example, if you look at the collection's framework, there are many implementations

00:25:48,510 --> 00:25:51,990
of the set interface, you know, whether it's TreeSet.

00:25:51,990 --> 00:25:56,700
The original ones were, you know, a HashSet, TreeSet and then we add a LinkedHashSet and

00:25:56,700 --> 00:25:59,960
more recently a whole slew of concurrent set implementations.

00:25:59,960 --> 00:26:01,670
You don't have to learn any new APIs.

00:26:01,670 --> 00:26:07,870
You learn the Set API and we can add new functionality, you know, we can richness without making you

00:26:07,870 --> 00:26:08,970
learn any new API.

00:26:08,970 --> 00:26:12,800
So, that's one of the great ways to increase the power to weight ratio.

00:26:12,800 --> 00:26:13,850
That's the important thing.

00:26:13,850 --> 00:26:19,010
You want to be able to do a lot without learning a lot.

00:26:19,010 --> 00:26:21,890
The implementation shouldn't impact the API.

00:26:21,890 --> 00:26:25,350
Once again this is motherhood but what does it really mean?

00:26:25,350 --> 00:26:29,090
It means don't put any implementation details into the API.

00:26:29,090 --> 00:26:32,960
They confuse the users and they inhibit their freedom to decide.

00:26:32,960 --> 00:26:35,710
They inhibit the implementer's freedom to change the API later.

00:26:35,710 --> 00:26:41,720
So, you know, for example, let us say, if you have some API that's about phone numbers

00:26:41,720 --> 00:26:48,660
but it throw a sequel exceptions and now you want to re-implement it on top of some proprietary

00:26:48,660 --> 00:26:52,140
data store rather than a sequel data store.

00:26:52,140 --> 00:26:55,890
But your clients are already trying to catch the sequel exceptions.

00:26:55,890 --> 00:26:56,890
You know, what do you do?

00:26:56,890 --> 00:26:59,870
Well, you can emulate those olds sequel exceptions but that's crazy.

00:26:59,870 --> 00:27:03,960
So that means that you should make sure that the exceptions that you throw are kind of

00:27:03,960 --> 00:27:09,070
at the same layer of abstraction as the rest of the API is.

00:27:09,070 --> 00:27:13,071
That's just one example where implementation details kind of leak into APIs.

00:27:13,071 --> 00:27:18,960
The important thing is you have to be aware of what actually is an implementation detail.

00:27:18,960 --> 00:27:21,590
You don't want to over specify your methods.

00:27:21,590 --> 00:27:27,890
You don't want the specification of a method to involve something that is in the implementation

00:27:27,890 --> 00:27:30,630
detail and that you would like to be able to change later on.

00:27:30,630 --> 00:27:33,400
So, here's an example where we did that.

00:27:33,400 --> 00:27:36,000
Don't specify your hash functions.

00:27:36,000 --> 00:27:40,200
You might think that, you know, exactly what value is returned by the hash code method

00:27:40,200 --> 00:27:42,299
is a proper part of a spec but it isn't.

00:27:42,299 --> 00:27:43,640
It's an implementation detail.

00:27:43,640 --> 00:27:48,510
The spec should simply say it returns an integer and, you know, with high probability the integer

00:27:48,510 --> 00:27:52,180
will differ for two different objects and furthermore it should be cheap to calculate

00:27:52,180 --> 00:27:53,180
the thing.

00:27:53,180 --> 00:27:56,820
But exactly what number is returned you should have the flexibility to change that from release

00:27:56,820 --> 00:28:03,020
to release as you learn about flaws in your old hash functions and as the technology improves

00:28:03,020 --> 00:28:04,190
and hash functions improve.

00:28:04,190 --> 00:28:07,590
Of course, you cannot do that if you're writing a persistent data store.

00:28:07,590 --> 00:28:11,809
If those hash functions are going to be use to store data on disk then they can't change.

00:28:11,809 --> 00:28:14,280
But that's a very special kind of hash function.

00:28:14,280 --> 00:28:18,110
Those ones must be specified but the great majority of hash functions out there shouldn't

00:28:18,110 --> 00:28:19,110
be.

00:28:19,110 --> 00:28:23,700
And we got this very wrong in initial releases of Java and unfortunately that tradition has

00:28:23,700 --> 00:28:27,080
stuck to the point where almost all of these hash functions are specified.

00:28:27,080 --> 00:28:28,640
But they really shouldn't be.

00:28:28,640 --> 00:28:32,980
Finally, you shouldn't let the implementation details kind of just leak into the API.

00:28:32,980 --> 00:28:38,049
The example I gave you before with an exception is an example where, you know, you didn't

00:28:38,049 --> 00:28:41,840
really think hard about them and say, "Oh yeah, you know, we should maybe throw a sequel

00:28:41,840 --> 00:28:42,840
exception here."

00:28:42,840 --> 00:28:45,510
You probably just wrote it and you realized, "Gee, I'm calling something that throws a

00:28:45,510 --> 00:28:48,370
sequel exception, so I have to propagate it out."

00:28:48,370 --> 00:28:52,110
That's a case where an implementation detail is just sort of leaking.

00:28:52,110 --> 00:28:58,809
Another example, a really notorious example in Java is, if you simply say, "Implements

00:28:58,809 --> 00:29:00,200
serializable."

00:29:00,200 --> 00:29:06,549
Once you've done that, your entire implementation has just sort of leaked out as part of your

00:29:06,549 --> 00:29:13,140
API because the serial form consists of the entire field that comprise your object even

00:29:13,140 --> 00:29:17,170
your private fields, so all of the sudden the private fields are part of the public

00:29:17,170 --> 00:29:20,090
API and that's really, really bad.

00:29:20,090 --> 00:29:23,309
And the way around that by the way is to design your serial forms carefully.

00:29:23,309 --> 00:29:26,650
Don't just say implement serializable.

00:29:26,650 --> 00:29:30,370
You should minimize the accessibility of everything.

00:29:30,370 --> 00:29:36,090
That means you should make your classes, your members, your fields, all, as private as possible.

00:29:36,090 --> 00:29:40,960
One specific case is that public classes should have no public fields with the exception of

00:29:40,960 --> 00:29:44,610
their constants, which aren't really fields.

00:29:44,610 --> 00:29:47,370
This maximizes what they call information hiding.

00:29:47,370 --> 00:29:49,080
Parnas is the guy who came up with that term.

00:29:49,080 --> 00:29:53,660
And it minimizes--minimizes the coupling between APIs.

00:29:53,660 --> 00:29:59,070
You know, if things are kind of hidden behind inter-modular boundaries, they can be change

00:29:59,070 --> 00:30:00,230
freely.

00:30:00,230 --> 00:30:05,220
And this allows modules to be understood, to be used, to be built, to be optimized,

00:30:05,220 --> 00:30:09,360
debugged, tested, and what have you individually and in parallel.

00:30:09,360 --> 00:30:14,330
So you can have multiple teams, you know, dealing with multiple APIs concurrently.

00:30:14,330 --> 00:30:19,410
If on the other hand the APIs sort of expose everything and each, you know, module is sort

00:30:19,410 --> 00:30:23,310
of messing around with other modules, then there is very little that you can do to any

00:30:23,310 --> 00:30:28,750
module without affecting a whole slew of modules around it.

00:30:28,750 --> 00:30:29,750
Names matter a lot.

00:30:29,750 --> 00:30:33,370
There are some people who think that names don't matter and, you know, when sit down

00:30:33,370 --> 00:30:35,309
and you say, "Well, this isn't named right."

00:30:35,309 --> 00:30:36,480
They say, "Don't waste your time.

00:30:36,480 --> 00:30:37,480
Let's just move on.

00:30:37,480 --> 00:30:38,670
It's good enough."

00:30:38,670 --> 00:30:44,570
Names in an API that are going to be used by anyone else and that includes yourself

00:30:44,570 --> 00:30:48,120
in a few months, matter an awful lot.

00:30:48,120 --> 00:30:54,419
The idea is that every API is kind of a little language and people who are going to use your

00:30:54,419 --> 00:30:58,330
API have to learn that language and then speak in that language and that means names should

00:30:58,330 --> 00:31:00,290
be largely self explanatory.

00:31:00,290 --> 00:31:02,429
You should avoid cryptic abbreviations.

00:31:02,429 --> 00:31:07,290
So the original Unix names I think, failed this one miserably.

00:31:07,290 --> 00:31:08,290
You should be consistent.

00:31:08,290 --> 00:31:12,610
It's very important that same word means the same things when you used repeatedly in your

00:31:12,610 --> 00:31:13,610
API.

00:31:13,610 --> 00:31:15,350
And that you don't have multiple words meaning that same thing.

00:31:15,350 --> 00:31:19,090
So let us say you have a remove and a delete in the same API.

00:31:19,090 --> 00:31:20,690
That's almost always wrong.

00:31:20,690 --> 00:31:22,740
You know, what's the difference between remove and delete?

00:31:22,740 --> 00:31:23,740
Well, I don't know.

00:31:23,740 --> 00:31:26,870
When I listen to those two things, they seem to mean the same thing.

00:31:26,870 --> 00:31:30,000
If they do mean the same thing, then call them both the same thing.

00:31:30,000 --> 00:31:33,510
If they don't, then make the names different enough to tell you how they differ.

00:31:33,510 --> 00:31:38,419
If they were called, let's say delete and expunge, I would know that expunge was a more--a

00:31:38,419 --> 00:31:41,840
permanent kind of removal or something like that.

00:31:41,840 --> 00:31:44,860
Not only should you strive for consistency but you should strive for symmetry.

00:31:44,860 --> 00:31:52,570
So, if your API has, let's say two verbs, add and remove, and two nouns, entry and key,

00:31:52,570 --> 00:31:56,360
I'd like to see, you know, add entry, add key, remove entry and remove key.

00:31:56,360 --> 00:31:59,340
If one of them is missing, there should be a very good reason for it.

00:31:59,340 --> 00:32:02,570
I'm not saying that all API should be symmetric but the great bulk of them should.

00:32:02,570 --> 00:32:06,200
And if you get it right, the code will read like prose.

00:32:06,200 --> 00:32:07,200
That's the prize.

00:32:07,200 --> 00:32:11,010
So, you know, in this case the code reads, "If the car's speed is more than twice a speed

00:32:11,010 --> 00:32:15,150
limit and the speaker should generate in alert that says watch out for cops."

00:32:15,150 --> 00:32:16,380
That's pretty much English.

00:32:16,380 --> 00:32:22,460
It reads like prose and that's an indication that API is reasonably decent.

00:32:22,460 --> 00:32:23,990
Documentation matters as well.

00:32:23,990 --> 00:32:27,470
And Parnas, the aforementioned Parnas said it much better than I could, so I'm simply

00:32:27,470 --> 00:32:29,549
going to read what he had to say.

00:32:29,549 --> 00:32:34,590
He said, "Reuse is something that is far easier to say than to do.

00:32:34,590 --> 00:32:39,030
Doing it requires both good design and very good documentation.

00:32:39,030 --> 00:32:42,679
Even when we see good design, which is still infrequently, we won't see the components

00:32:42,679 --> 00:32:45,070
reused without good documentation."

00:32:45,070 --> 00:32:47,240
He said that in 1994.

00:32:47,240 --> 00:32:51,230
And I don't know about you but, you know, when I--when I read that I get religion.

00:32:51,230 --> 00:32:55,539
And the only thing I can do then is to document religiously.

00:32:55,539 --> 00:32:59,940
Document every single class, every interface, every method, every constructor, every parameter

00:32:59,940 --> 00:33:02,300
and every exception in my public API.

00:33:02,300 --> 00:33:05,590
Of course all of you do that, right?

00:33:05,590 --> 00:33:10,030
And when you go out on the web, whenever you look Javadoc, it's always the case that every

00:33:10,030 --> 00:33:14,760
public or protected method has a Javadoc comment, right?

00:33:14,760 --> 00:33:15,920
No.

00:33:15,920 --> 00:33:19,850
You know, it's really terrible because if you don't have a comment telling you what

00:33:19,850 --> 00:33:22,700
the specification is, what is the specification?

00:33:22,700 --> 00:33:24,610
Who knows?

00:33:24,610 --> 00:33:25,620
You have two choices.

00:33:25,620 --> 00:33:30,710
Either you guess, in much case your program probably doesn't work, or you read the code

00:33:30,710 --> 00:33:35,880
in which case, the implementation becomes the specification and it's over specified

00:33:35,880 --> 00:33:39,929
and you no longer have the freedom to change that implementation at all.

00:33:39,929 --> 00:33:43,809
So document everything and there are--you know, what does this mean for classes?

00:33:43,809 --> 00:33:46,650
Just tell me what an instance of that class represents.

00:33:46,650 --> 00:33:50,809
From methods, tell me the contract between the method and its client.

00:33:50,809 --> 00:33:52,420
That is what must be true before I call it.

00:33:52,420 --> 00:33:55,840
What will be true after it returns and any side effects.

00:33:55,840 --> 00:33:56,840
Those are particularly important.

00:33:56,840 --> 00:34:00,789
If you had side effect and you don't document them, people will shoot themselves in the

00:34:00,789 --> 00:34:01,789
foot.

00:34:01,789 --> 00:34:02,940
I'll give you an example of this later.

00:34:02,940 --> 00:34:05,580
For parameters, people often forget.

00:34:05,580 --> 00:34:09,720
Don't just say, "Hmm, the size of the block."

00:34:09,720 --> 00:34:13,500
It's the size of the block in bytes or in megabytes or whatever.

00:34:13,500 --> 00:34:17,359
You've got to tell me what the units are, the form, if it's a string, especially.

00:34:17,359 --> 00:34:18,369
I've got to know.

00:34:18,369 --> 00:34:19,829
Is it XML?

00:34:19,829 --> 00:34:23,520
You know what form is this string in and finally, the ownership.

00:34:23,520 --> 00:34:27,879
If I'm passing an object into an API, do I still only object?

00:34:27,879 --> 00:34:33,320
Am I free to modify it after I passed it in or have I transferred ownership from my self

00:34:33,320 --> 00:34:37,740
to the object to which I passed that other object?

00:34:37,740 --> 00:34:44,340
If the thing that you're defining is mutable, that is, can be modified, then you must document

00:34:44,340 --> 00:34:46,500
the state space very carefully.

00:34:46,500 --> 00:34:52,090
If you have a badly documented space--state space, then you have no hope of being able

00:34:52,090 --> 00:34:53,730
to use that API properly.

00:34:53,730 --> 00:34:57,840
Because people won't know when it's legal to call what and what will happen after the

00:34:57,840 --> 00:34:59,580
call is made.

00:34:59,580 --> 00:35:04,410
I may discuss this elsewhere but an example of how to do this very badly, our date and

00:35:04,410 --> 00:35:07,980
calendar, in particular the calendar API in Java.

00:35:07,980 --> 00:35:12,540
The state space is almost undocumented and it caused numerous bugs over time.

00:35:12,540 --> 00:35:20,270
I'm happy to say by the way, that just days ago, Sun decided that we would be pursuing

00:35:20,270 --> 00:35:25,900
any JSR to improve the date and calendar APIs based in part on [INDISTINCT] time and who

00:35:25,900 --> 00:35:27,150
knows what or else.

00:35:27,150 --> 00:35:31,290
But to me--we may finally be, you know, free of that mess.

00:35:31,290 --> 00:35:34,390
You should consider performance consequences of API design decisions.

00:35:34,390 --> 00:35:37,300
And this is funny because this tends to, you know, contradict the advice.

00:35:37,300 --> 00:35:40,359
You've all heard that, you know, a premature optimization is evil.

00:35:40,359 --> 00:35:44,300
In fact, I have an old essay about that in effective Java.

00:35:44,300 --> 00:35:47,369
However, that doesn't mean that you can just ignore performance.

00:35:47,369 --> 00:35:49,190
Jon Bentley was big on this fact.

00:35:49,190 --> 00:35:55,950
And in particular, it turns out that bad API decisions can limit performance.

00:35:55,950 --> 00:35:59,660
Examples of things that can limit it are making the type mutable when it should be immutable

00:35:59,660 --> 00:36:04,990
or vice versa, providing a constructor instead of a static factory, using implementation

00:36:04,990 --> 00:36:08,900
type in an API instead of an interface, which means that people will always have to use

00:36:08,900 --> 00:36:13,310
that particular implementation even if a better one comes along later.

00:36:13,310 --> 00:36:17,620
But the converse of this is, never work an API to gain performance.

00:36:17,620 --> 00:36:21,620
Every once in a while you have something that sort of temporarily broken.

00:36:21,620 --> 00:36:27,150
You know, this thing is slow and in order to avoid this slow thing, you break your API.

00:36:27,150 --> 00:36:32,990
The thing that used to get slow becomes fast but your API is still broken, you know.

00:36:32,990 --> 00:36:35,900
So, design your APIs for the long haul.

00:36:35,900 --> 00:36:40,109
Luckily, good API design usually coincides with good performance.

00:36:40,109 --> 00:36:46,030
Here's an example of an API design decision that led to bad performance.

00:36:46,030 --> 00:36:50,560
In the original AWT, there was something called a dimension.

00:36:50,560 --> 00:36:54,950
If you had a component and you ask for its size, you got back a dimension object, which

00:36:54,950 --> 00:36:56,350
contained two coordinates.

00:36:56,350 --> 00:36:59,430
It's simply couple of longs that were wrapped.

00:36:59,430 --> 00:37:02,610
The problem is that the dimension object was mutable.

00:37:02,610 --> 00:37:04,440
Those longs weren't really wrapped.

00:37:04,440 --> 00:37:08,750
You know, they were--they were publicly visible, mutable fields.

00:37:08,750 --> 00:37:14,270
And what that meant was every time you called getSize, you had to allocate a new dimension

00:37:14,270 --> 00:37:19,010
object because otherwise I might, you know, get the dimension object, give it to you,

00:37:19,010 --> 00:37:23,270
you might ask for it and then you might modify it modifying his copy as well.

00:37:23,270 --> 00:37:24,540
And that would be really bad.

00:37:24,540 --> 00:37:30,570
Now these two, you know, independent threads or computations will be tied together in nasty

00:37:30,570 --> 00:37:31,570
ways.

00:37:31,570 --> 00:37:32,570
Is that bad?

00:37:32,570 --> 00:37:36,440
You know, is it really expensive to allocate a little object containing two longs?

00:37:36,440 --> 00:37:41,210
No, it's dirt cheap but unfortunately this thing gets called millions, literally millions

00:37:41,210 --> 00:37:45,910
of times in a goyap So, you know, all of a sudden, you're basically allocating megabytes

00:37:45,910 --> 00:37:48,160
of garbage and that really does cost you.

00:37:48,160 --> 00:37:50,800
It's garbage collector pressure that you just don't need.

00:37:50,800 --> 00:37:57,230
And it was fixed in 1.2 by adding methods that return each dimension individually as

00:37:57,230 --> 00:37:59,640
a primitive type which is in fact immutable.

00:37:59,640 --> 00:38:04,570
But, you know unfortunately, old codes that used the 1.1 APIs is still slow and will always

00:38:04,570 --> 00:38:06,760
be slow.

00:38:06,760 --> 00:38:10,530
The APIs that you write have to coexist peacefully with the platform.

00:38:10,530 --> 00:38:14,760
So, that means that you have to do what's customary for that platform.

00:38:14,760 --> 00:38:16,480
You have to obey its naming conventions.

00:38:16,480 --> 00:38:20,720
You have to avoid anything that's just verboten in that platform.

00:38:20,720 --> 00:38:24,910
You know, whatever it is, if you're in java, you know, if you are in C++, everybody knows

00:38:24,910 --> 00:38:27,480
that there are certain things that you just shouldn't do or shouldn't use.

00:38:27,480 --> 00:38:30,080
So, learn what those things are and then avoid them.

00:38:30,080 --> 00:38:33,619
And there are--there are generally books that tell you the traps and pitfalls for every

00:38:33,619 --> 00:38:34,619
platform.

00:38:34,619 --> 00:38:37,730
I could recommend one for Java but, you know.

00:38:37,730 --> 00:38:45,510
Anyway, the thing you've got to do is mimic the patterns and the core APIs in the platform,

00:38:45,510 --> 00:38:48,580
because everyone who uses a platform knows its core APIs.

00:38:48,580 --> 00:38:53,800
So, if your API feel just like one of the core APIs, then everyone, because they already

00:38:53,800 --> 00:38:57,150
know how to use core API will already know how to use your API.

00:38:57,150 --> 00:38:58,710
It's as simple as that.

00:38:58,710 --> 00:39:06,710
And the real trap here is you should never simply transliterate APIs.

00:39:06,710 --> 00:39:08,710
That is the worst way to design an API.

00:39:08,710 --> 00:39:10,210
And what do I mean by that?

00:39:10,210 --> 00:39:15,390
Suppose you have a C++ API, and you want a Java version of the same facility.

00:39:15,390 --> 00:39:21,460
What you should not do is take every C++ class and make a complementary Java class that contains

00:39:21,460 --> 00:39:26,730
all the same methods as the C++ class because what was reasonable in C++ will almost certainly

00:39:26,730 --> 00:39:29,550
be unreasonable in Java and vice versa.

00:39:29,550 --> 00:39:31,660
So, you have to basically take a step back.

00:39:31,660 --> 00:39:36,870
You have to say, "What is this class doing and how would I do this in Java?"

00:39:36,870 --> 00:39:38,490
That's the right way to do it.

00:39:38,490 --> 00:39:41,660
Transliterated APIs are almost always broken.

00:39:41,660 --> 00:39:42,840
Okay.

00:39:42,840 --> 00:39:47,190
On to class design, I have 15 minutes to finish the whole--rest of the talk.

00:39:47,190 --> 00:39:50,970
So that gives me five minutes each for the next three sections and zero minutes for the

00:39:50,970 --> 00:39:52,280
last section.

00:39:52,280 --> 00:39:56,260
So, first of all minimize mutability.

00:39:56,260 --> 00:40:00,440
Classes should be immutable unless there's a very good reason to make them mutable.

00:40:00,440 --> 00:40:05,240
And the advantages are that the class you get are simple, they are thread safe, they

00:40:05,240 --> 00:40:07,270
are--instances of reusable.

00:40:07,270 --> 00:40:10,100
You never have to generate a new one.

00:40:10,100 --> 00:40:14,060
The only disadvantage is that you need a separate object for each value.

00:40:14,060 --> 00:40:19,791
So, if you a huge object, let's say a big integer that's a million digits long and you

00:40:19,791 --> 00:40:25,090
want to throw it away but you just want to change a last bit, if it were mutable, you

00:40:25,090 --> 00:40:27,820
could do that in place, you know, at virtually no cost.

00:40:27,820 --> 00:40:32,330
But because they're immutable, you have to basically copy a megabit of data and then

00:40:32,330 --> 00:40:35,500
throw away the old megabit, which is a little bit unpleasant.

00:40:35,500 --> 00:40:39,599
But if you do have to make things mutable, and you often do, you should still make them

00:40:39,599 --> 00:40:41,180
as immutable as possible.

00:40:41,180 --> 00:40:44,960
You should give them a nice small, well defined state space.

00:40:44,960 --> 00:40:49,310
You should make it clear--you should make it clear when it's legal to call which method.

00:40:49,310 --> 00:40:51,381
So, bad examples, as I mentioned before, are date and calendar.

00:40:51,381 --> 00:40:55,910
Calendar has this, you know, like the roll method and when you, you know, you put date

00:40:55,910 --> 00:40:58,330
into it, who knows what state is behind it?

00:40:58,330 --> 00:40:59,630
When it's legal to call what?

00:40:59,630 --> 00:41:02,130
What state the calendar is in after if you've used it?

00:41:02,130 --> 00:41:05,860
And, you know, did you know that when you're using a date formatter, if one thread uses

00:41:05,860 --> 00:41:10,610
a date formatter and other thread tries to use at the same time, both threads are hosed.

00:41:10,610 --> 00:41:14,430
You know, it kind of feels like an immutable object, except that it has state inside it.

00:41:14,430 --> 00:41:16,250
You can't read that state but it's there.

00:41:16,250 --> 00:41:19,220
You know, so, these are--these are things that are more mutable than they should be.

00:41:19,220 --> 00:41:20,800
A good example is TimerTask.

00:41:20,800 --> 00:41:24,170
It's not immutable, but it minimizes mutability.

00:41:24,170 --> 00:41:29,630
In particular, a TimerTask is inherently mutable because it represents an actual or current

00:41:29,630 --> 00:41:30,970
computation and that mutates.

00:41:30,970 --> 00:41:34,540
But, you know, a TimerTask, what you do?

00:41:34,540 --> 00:41:39,790
You create it, you schedule it, it runs as many times as it has to run, and then it's

00:41:39,790 --> 00:41:40,790
dead.

00:41:40,790 --> 00:41:41,790
It's gone.

00:41:41,790 --> 00:41:42,790
End of story.

00:41:42,790 --> 00:41:46,320
Now, there were people, who asked us, when we were designing the timer API, "We want

00:41:46,320 --> 00:41:47,320
to reuse them, you know.

00:41:47,320 --> 00:41:49,109
It's like expensive to make a TimerTask."

00:41:49,109 --> 00:41:51,490
And the answer is, "No, let it die in peace."

00:41:51,490 --> 00:41:55,890
If you need another one, make another one but by eliminating that sort of loop from

00:41:55,890 --> 00:42:01,010
the state space, you make the API much simpler and much less bug-prone.

00:42:01,010 --> 00:42:03,070
You should subclass only when it makes to do so.

00:42:03,070 --> 00:42:05,599
This is the Liskov Substitution Principle.

00:42:05,599 --> 00:42:06,830
And it's actually very simple.

00:42:06,830 --> 00:42:08,600
You just have to ask yourself a question.

00:42:08,600 --> 00:42:13,440
When you have two classes, in a public API, and you're thinking of making one of subclass

00:42:13,440 --> 00:42:18,800
to another, like through a subclass of bar, ask yourself, "Is every foo a bar?"

00:42:18,800 --> 00:42:22,980
If you can answer that with a straight face, then make it a subclass.

00:42:22,980 --> 00:42:24,150
If not, don't.

00:42:24,150 --> 00:42:28,530
So, a bad example is, in Java properties extends Hash table.

00:42:28,530 --> 00:42:31,119
Is every property's object a Hash table?

00:42:31,119 --> 00:42:32,190
Heavens, no.

00:42:32,190 --> 00:42:37,260
A property's object is a special thing that map certain strings to certain other string.

00:42:37,260 --> 00:42:41,099
So, every property's object has a Hash table, perhaps.

00:42:41,099 --> 00:42:45,220
Typically, it's implemented a top Hash table but you can't answer that answer--that is

00:42:45,220 --> 00:42:48,920
a question with a straight face or what about Stack extends Vector?

00:42:48,920 --> 00:42:50,300
Is every stack a vector?

00:42:50,300 --> 00:42:51,300
No.

00:42:51,300 --> 00:42:53,890
You push and pump on stacks and that's pretty much all you do them.

00:42:53,890 --> 00:42:57,020
You might also have a peek method and a size method.

00:42:57,020 --> 00:43:01,860
But, you know a vector allows random access, accessing by index, a stack doesn't.

00:43:01,860 --> 00:43:04,890
So, it was really wrong to have Stack extends Vector.

00:43:04,890 --> 00:43:07,869
And the really bad thing about it was they took away great piece of real estate.

00:43:07,869 --> 00:43:12,330
We can't use the name stack for a class that actually does implement stack anymore because

00:43:12,330 --> 00:43:13,990
the name has been taken.

00:43:13,990 --> 00:43:15,640
Good is Set extends Collections.

00:43:15,640 --> 00:43:16,710
Is every set a collection?

00:43:16,710 --> 00:43:17,980
Yes, it really is.

00:43:17,980 --> 00:43:19,940
Set is just a special kind of a collection.

00:43:19,940 --> 00:43:23,610
It's a collection that does not allow duplicate elements.

00:43:23,610 --> 00:43:25,570
This is a fairly controversial one.

00:43:25,570 --> 00:43:30,690
But I believe that you should design and document a class for inheritance or else prohibit it

00:43:30,690 --> 00:43:34,820
outright, to make the class final or have no publicly accessible constructor.

00:43:34,820 --> 00:43:39,290
The reason for that is, is that in heritance violates in encapsulation in a--in a subtle

00:43:39,290 --> 00:43:40,290
way.

00:43:40,290 --> 00:43:46,599
And that is to say that subclassing violates encapsulation in a way that mere method invocation

00:43:46,599 --> 00:43:47,599
does not.

00:43:47,599 --> 00:43:51,450
This is sometimes called the fragile base class problem, where basically if you have

00:43:51,450 --> 00:43:55,420
one class, it's implemented atop second class.

00:43:55,420 --> 00:43:59,370
And you override a method in the first class.

00:43:59,370 --> 00:44:05,150
It may modify the behavior of other methods in the subclass because the original implementations

00:44:05,150 --> 00:44:10,040
of those methods dispatched to the method that you just overrode.

00:44:10,040 --> 00:44:14,720
And then if in the future implementation of the super class, they re-implement all of

00:44:14,720 --> 00:44:19,930
these methods, so that this method no longer is implemented in terms of this one but both

00:44:19,930 --> 00:44:22,660
of them are implemented in terms of some third method.

00:44:22,660 --> 00:44:30,720
Then, you know, this new version of the super class will break the subclass.

00:44:30,720 --> 00:44:37,490
And the way to avoid that is either come clean on exactly how every method uses every other

00:44:37,490 --> 00:44:38,490
method.

00:44:38,490 --> 00:44:41,090
That is document the self-use patterns of a class.

00:44:41,090 --> 00:44:44,470
If you've done that, then you documented it and designed it for inheritance.

00:44:44,470 --> 00:44:46,030
So, it's okay to make it non-final.

00:44:46,030 --> 00:44:47,920
Otherwise, it could just be final.

00:44:47,920 --> 00:44:52,109
Now, if you look at the Java API, we got this wrong in many places.

00:44:52,109 --> 00:44:56,681
So, most of the concrete class in the J2SE libraries, in particular, collection classes

00:44:56,681 --> 00:44:58,970
like, HashMap and HashSet.

00:44:58,970 --> 00:45:02,790
They're all non-final, but they don't exactly define their self-use patterns.

00:45:02,790 --> 00:45:04,470
So, they're a bit fragile.

00:45:04,470 --> 00:45:08,450
Abstract set and abstract map and the other abstract xxx classes are good.

00:45:08,450 --> 00:45:11,740
They really are designed and documented for inheritance.

00:45:11,740 --> 00:45:14,150
Okay, onto methods.

00:45:14,150 --> 00:45:19,700
So, this is--if you remember only two things from the talk today, this is the second thing.

00:45:19,700 --> 00:45:22,230
By the way what was the first thing I told you to remember?

00:45:22,230 --> 00:45:23,910
>> [INDISTINCT] >> BLOCH: Excellent.

00:45:23,910 --> 00:45:24,910
When in doubt, leave it out.

00:45:24,910 --> 00:45:30,680
The second one is, don't make the client do anything the module could do.

00:45:30,680 --> 00:45:33,710
Those two things are like the fundamental rules of API design.

00:45:33,710 --> 00:45:38,390
So, the worst thing you can do is write an API that just requires the client to call

00:45:38,390 --> 00:45:42,970
in and out, and in and out just doing repeated calls, passing junk from the first call to

00:45:42,970 --> 00:45:44,230
the second call.

00:45:44,230 --> 00:45:47,210
These causes boilerplate code, which as you can see it's red.

00:45:47,210 --> 00:45:48,610
It's really, really bad.

00:45:48,610 --> 00:45:50,630
Why is boilerplate code bad?

00:45:50,630 --> 00:45:55,619
Because it's an opportunity for bugs, you make boilerplate code by doing cut-and-paste

00:45:55,619 --> 00:45:56,619
and then modify.

00:45:56,619 --> 00:45:59,849
But if you don't do all the modification that you should, it may still compile but it won't

00:45:59,849 --> 00:46:00,849
do the right thing.

00:46:00,849 --> 00:46:03,230
It is ugly, it is annoying, and it's error prone.

00:46:03,230 --> 00:46:09,740
And here is a real live example from the W3Cs DOM API.

00:46:09,740 --> 00:46:14,590
Suppose you have in hand an XML document and you want to print it to an output stream.

00:46:14,590 --> 00:46:16,170
That's a very reasonable thing to do.

00:46:16,170 --> 00:46:21,839
It should take one call, you know, print, it takes an output stream and you're done.

00:46:21,839 --> 00:46:22,839
But it doesn't.

00:46:22,839 --> 00:46:24,410
Here is what you actually have to do.

00:46:24,410 --> 00:46:30,800
First you have to import, in addition to w3c.dom, that's fine and java.io, you also have to

00:46:30,800 --> 00:46:35,750
import XML Transform, xmltransform.dom and xmltransform.stream.

00:46:35,750 --> 00:46:37,210
Why?

00:46:37,210 --> 00:46:39,450
I don't know but I do know you have to do it.

00:46:39,450 --> 00:46:41,730
And then here's how the call should've looked.

00:46:41,730 --> 00:46:44,510
It should've been called Right Doc and, you know, the document perhaps should have been

00:46:44,510 --> 00:46:48,160
the receiver and you pass in an output stream and it would throw an IO exception.

00:46:48,160 --> 00:46:49,280
But here's what you actually have to do.

00:46:49,280 --> 00:46:52,119
First, you get a transformer and what is a transformer?

00:46:52,119 --> 00:46:53,520
I don't know, but I know you need one.

00:46:53,520 --> 00:46:54,550
How do you get one?

00:46:54,550 --> 00:47:03,020
Well, you take the new instance method on the transformer factory and then that gives

00:47:03,020 --> 00:47:07,250
you a transformer factory and once you get the factory you ask for a new transformer.

00:47:07,250 --> 00:47:09,320
So, as you can see, they read design patterns.

00:47:09,320 --> 00:47:10,320
It's great.

00:47:10,320 --> 00:47:11,430
It's like filled with patterns.

00:47:11,430 --> 00:47:17,280
So now, you've got your transformer out of your transformer factory and then you have

00:47:17,280 --> 00:47:20,420
to set an output properly on that transformer.

00:47:20,420 --> 00:47:26,730
You have to set its doc type system to be the doc type from the doc.

00:47:26,730 --> 00:47:29,720
I don't know what any of these means but I know you have to do all of it.

00:47:29,720 --> 00:47:37,570
And then, you have to get the system I.D. and you have to--that's part of this output

00:47:37,570 --> 00:47:38,680
property that you're setting.

00:47:38,680 --> 00:47:42,270
And then when you're all done, you can actually do the output.

00:47:42,270 --> 00:47:45,390
The way you do that is you call transform on the transformer.

00:47:45,390 --> 00:47:48,650
And you just don't pass in the doc source because that doesn't implement the right thing.

00:47:48,650 --> 00:47:54,230
You use the adaptor pattern here to take your doc and you turn it into a DOM source and

00:47:54,230 --> 00:47:58,010
then also you can't quite just pass in your output stream.

00:47:58,010 --> 00:48:03,030
You wrap it in a stream result and now you get your output, right?

00:48:03,030 --> 00:48:06,700
Except for one tiny problem, which is it can throw a transformer exception?

00:48:06,700 --> 00:48:07,700
When can it throw it?

00:48:07,700 --> 00:48:13,349
Well, never actually but the API says it can and it's a checked exception, so we have to

00:48:13,349 --> 00:48:16,619
catch it if it gets thrown and then we throw an insertion there because it can never happen.

00:48:16,619 --> 00:48:21,240
So, you know, you've got like, whatever it is, six lines of just unreadable garbage code

00:48:21,240 --> 00:48:22,609
give you something very simple.

00:48:22,609 --> 00:48:29,210
If they had started with a used case, people might want to print their xml documents.

00:48:29,210 --> 00:48:31,660
You get the idea.

00:48:31,660 --> 00:48:35,560
Another general rule when you're designing class--a method is, don't violate the Principle

00:48:35,560 --> 00:48:36,839
of Least Astonishments.

00:48:36,839 --> 00:48:40,339
The user of an API should never be surprised by its behavior.

00:48:40,339 --> 00:48:42,020
It's worth extra implementation effort.

00:48:42,020 --> 00:48:47,440
It's even sometimes worth a reduced performance not to surprise the users of your API because

00:48:47,440 --> 00:48:49,020
if you surprise them, what will happen?

00:48:49,020 --> 00:48:51,000
They'll simply do the wrong thing.

00:48:51,000 --> 00:48:53,720
They'll think it does something, it'll actually do something else and their program will be

00:48:53,720 --> 00:48:54,910
broken.

00:48:54,910 --> 00:48:58,380
Here's a real example from the thread API in Java.

00:48:58,380 --> 00:49:02,859
So, we have this method called interrupted.

00:49:02,859 --> 00:49:04,940
You got a thread and you want to check if it's interrupted.

00:49:04,940 --> 00:49:07,070
You call thread.interrupted.

00:49:07,070 --> 00:49:08,070
And what does it do?

00:49:08,070 --> 00:49:10,440
Well, it tests whether the current thread has been interrupted.

00:49:10,440 --> 00:49:16,180
Oh, and by the way, it clears the interrupted status of the current thread.

00:49:16,180 --> 00:49:17,670
That's just like a little side effect.

00:49:17,670 --> 00:49:20,720
It clears the interrupted status of the current thread.

00:49:20,720 --> 00:49:24,580
Looking at the name, you know, thread.interrupted, there'll be no way to guess that it does this.

00:49:24,580 --> 00:49:28,990
But it does this and many people have, you now, spent hours chasing bugs because of it.

00:49:28,990 --> 00:49:32,020
You know what is the primary thing that this call does?

00:49:32,020 --> 00:49:33,730
It clears the interrupted status.

00:49:33,730 --> 00:49:38,400
It's not an unreasonable call but it should've been named clear interrupt status and by the

00:49:38,400 --> 00:49:41,910
way, it could've returned the old interrupt status as a favor to you.

00:49:41,910 --> 00:49:46,580
But they named it based on--so, the second most important thing it did, instead of the

00:49:46,580 --> 00:49:48,230
first most important thing it did.

00:49:48,230 --> 00:49:52,230
And in doing so, they violated this Principle of Least Astonishment.

00:49:52,230 --> 00:49:53,660
You should fail fast.

00:49:53,660 --> 00:49:57,880
Whenever there's an error, you should tell the user of your API as soon as possible after

00:49:57,880 --> 00:49:59,270
the error has happened.

00:49:59,270 --> 00:50:03,980
Ideally, you should tell him at compile time, you know, because this way it happens in the

00:50:03,980 --> 00:50:09,510
lab or in the, you know, here where the program is being written, instead of out in the field

00:50:09,510 --> 00:50:11,670
where the program is being run.

00:50:11,670 --> 00:50:16,150
And that means that I believe that static typing is a very good thing.

00:50:16,150 --> 00:50:18,150
It moves errors from runtime to compile time.

00:50:18,150 --> 00:50:23,080
I understand that this is another highly controversial topic.

00:50:23,080 --> 00:50:24,460
But I do believe it.

00:50:24,460 --> 00:50:26,680
You know, I've seen it happened.

00:50:26,680 --> 00:50:30,380
You know, for example, when increased the static typing in Java by adding generics.

00:50:30,380 --> 00:50:35,780
I found bugs in preexisting code, you know, because it forced to me to be more specific

00:50:35,780 --> 00:50:39,780
about the types that were expected and they told me where things were wrong.

00:50:39,780 --> 00:50:44,450
If you are only going to be able to find out an error at runtime, you want to find out

00:50:44,450 --> 00:50:47,000
the first time you do something wrong.

00:50:47,000 --> 00:50:51,350
Like, if you pass some garbage into something else, you should find out as soon as you pass

00:50:51,350 --> 00:50:53,849
the garbage in, not ten minutes later.

00:50:53,849 --> 00:50:56,260
Here's the example of how not to do it.

00:50:56,260 --> 00:50:59,770
In the aforementioned properties class that extends hash table.

00:50:59,770 --> 00:51:04,330
If you look at the spec, it has properties instance maps strings to strings.

00:51:04,330 --> 00:51:09,430
But if you look at this put call, it takes an object key and an object value.

00:51:09,430 --> 00:51:14,650
Any object, maybe a string, maybe something else, but it tells you right away if you pass

00:51:14,650 --> 00:51:17,020
in something that's not a string, right?

00:51:17,020 --> 00:51:19,180
If only it were so.

00:51:19,180 --> 00:51:20,870
It doesn't, in fact, tell you right away.

00:51:20,870 --> 00:51:27,190
It lets you put in any garbage you want and then, ten minutes later when you try--when

00:51:27,190 --> 00:51:31,440
you call the save call to an output stream, which basically takes his property's object

00:51:31,440 --> 00:51:35,280
and translate into some garbage that isn't quite XML.

00:51:35,280 --> 00:51:38,950
Then and only then does it blow up with a class cast exception because you put something

00:51:38,950 --> 00:51:41,079
wrong into it ten minutes before.

00:51:41,079 --> 00:51:43,820
But by that time, debugging becomes almost impossible.

00:51:43,820 --> 00:51:49,260
You don't know where the call was that put the garbage into your properties object.

00:51:49,260 --> 00:51:53,670
You should provide programmatic access to all data that is also available in string

00:51:53,670 --> 00:51:54,670
form.

00:51:54,670 --> 00:51:55,670
This is really important.

00:51:55,670 --> 00:51:59,310
Whenever you have a method that return something as a string you should also have a method

00:51:59,310 --> 00:52:01,980
that returns the same stuff in programmatic form.

00:52:01,980 --> 00:52:06,340
If you don't do that, then clients will have to parse the string.

00:52:06,340 --> 00:52:13,480
Not only is that a pain in the butt but it turns the string into a de facto part of the

00:52:13,480 --> 00:52:14,600
API.

00:52:14,600 --> 00:52:18,740
You can never add information to that string because there's code out there that pausing

00:52:18,740 --> 00:52:19,740
that string.

00:52:19,740 --> 00:52:22,590
And if you change the format of the string, you break that code.

00:52:22,590 --> 00:52:26,580
So, what you should do is along with the API that gives you the printable string, you should

00:52:26,580 --> 00:52:31,589
have other APIs that give you access to--excuse me, to the actual information and this way

00:52:31,589 --> 00:52:33,820
you can add more information to the string later.

00:52:33,820 --> 00:52:37,810
And in fact, the spec should say that you are not specifying the format of the string

00:52:37,810 --> 00:52:42,380
and that anyone who writes code to parse the string is taking their lives into their hands.

00:52:42,380 --> 00:52:48,900
So, you know, a bad example is, initially the only way to get the stack trace in Java

00:52:48,900 --> 00:52:56,010
was to call this gets stack--sorry, prints stack trace API and people actually did go

00:52:56,010 --> 00:52:57,250
parse those things.

00:52:57,250 --> 00:53:02,510
In 1.4, we finally added get stack trace API that gives you all the same information, a

00:53:02,510 --> 00:53:06,890
stack trace element consisting of the filename, a line number, class name and so forth.

00:53:06,890 --> 00:53:12,730
But this was a case of sort of the horse had already left the barn.

00:53:12,730 --> 00:53:15,660
You should overload with care.

00:53:15,660 --> 00:53:19,000
Method overloading can be a good thing but it tends overused.

00:53:19,000 --> 00:53:21,010
You should avoid ambiguous overloading.

00:53:21,010 --> 00:53:26,960
That is multiple overloading that can do different things when passed the same values.

00:53:26,960 --> 00:53:32,670
And a bad example, which I am guilty of here myself, is TreeSet has two constructors; one

00:53:32,670 --> 00:53:35,140
that takes collection, one that takes a sorted set.

00:53:35,140 --> 00:53:37,990
The first one ignores the order of the thing that was passed in.

00:53:37,990 --> 00:53:41,580
The second one says, "Gee, I'm making a tree set out of another sorted set, I might as

00:53:41,580 --> 00:53:43,150
well order it in the same way."

00:53:43,150 --> 00:53:44,150
Well, here's the problem.

00:53:44,150 --> 00:53:48,760
If you have a sorted set that's cast to a collection, then you're calling this constructor

00:53:48,760 --> 00:53:50,110
and you get one result.

00:53:50,110 --> 00:53:54,050
Whereas, if you don't cast it, if you just pass it in, you get another result, so I really

00:53:54,050 --> 00:53:55,109
should not have done that way.

00:53:55,109 --> 00:53:56,869
I should've done a dynamic test.

00:53:56,869 --> 00:54:00,619
If the thing was the instance of sorted of set, then I should've preserved the order.

00:54:00,619 --> 00:54:05,339
So, you know, the basic rule here is just because you can doesn't mean you should.

00:54:05,339 --> 00:54:10,400
Often, it's better to simply give something another name rather than overloading.

00:54:10,400 --> 00:54:11,869
Overloading can be a real trap.

00:54:11,869 --> 00:54:18,080
If you use appropriate parameter and return types that means you should favor interfaces

00:54:18,080 --> 00:54:19,760
that were specific classes.

00:54:19,760 --> 00:54:22,849
You should use the most specific possible input parameter type.

00:54:22,849 --> 00:54:27,610
If you accept, let's say, a collection but you'll blow up unless somebody passes you

00:54:27,610 --> 00:54:32,050
a set that's broken, you've just taken something that could've been caught at compile time

00:54:32,050 --> 00:54:34,270
and instead you're catching it at runtime.

00:54:34,270 --> 00:54:38,750
Here's a really, sort of, another trap, don't use a string if a better type exist.

00:54:38,750 --> 00:54:43,320
In these days of, you know, XML and web services, people always start off with strings.

00:54:43,320 --> 00:54:44,780
Strings come in over the web.

00:54:44,780 --> 00:54:47,980
Just because it started as a string doesn't mean it should stay as string.

00:54:47,980 --> 00:54:50,530
You should turn it into something more reasonable and leave it there.

00:54:50,530 --> 00:54:56,369
A really bad example of this that I saw in a program years ago, was a program that passed

00:54:56,369 --> 00:55:02,570
around a string for its whole duration of its execution, that was either yes or no.

00:55:02,570 --> 00:55:05,450
We have a good data type for that it's called boolean.

00:55:05,450 --> 00:55:08,550
You should never use floating point types at Google.

00:55:08,550 --> 00:55:13,130
You guys already know all these but never use the floating point types, float or double

00:55:13,130 --> 00:55:15,050
for monetary values.

00:55:15,050 --> 00:55:16,859
They're not good enough to represent money.

00:55:16,859 --> 00:55:23,740
You cannot do exact computations base 10 using floating point numbers--binary numbers because

00:55:23,740 --> 00:55:27,760
of the fact that 1/10th is not representable as a binary fraction.

00:55:27,760 --> 00:55:28,850
So, don't do it.

00:55:28,850 --> 00:55:32,349
If you have you know, an amount of money, use big decimal.

00:55:32,349 --> 00:55:37,560
Perhaps, use long big integer or what have you but do not use float or double.

00:55:37,560 --> 00:55:40,660
And when you are faced with the choice of using float or double, you should almost use

00:55:40,660 --> 00:55:48,170
double rather than float because, you know, typically double will run just as fast and,

00:55:48,170 --> 00:55:52,180
you know, you lose real and important precision by going down to float.

00:55:52,180 --> 00:55:55,860
Let see, I'm going to have to just run through the rest of this.

00:55:55,860 --> 00:55:57,619
This one is really important.

00:55:57,619 --> 00:56:00,619
Use consistent parameter ordering across methods.

00:56:00,619 --> 00:56:02,900
So, you know, here is an example of what not to do.

00:56:02,900 --> 00:56:04,210
A real example from Unix.

00:56:04,210 --> 00:56:06,200
We have two methods to copy data.

00:56:06,200 --> 00:56:07,460
One is called store and copy.

00:56:07,460 --> 00:56:09,380
One is called b-copy.

00:56:09,380 --> 00:56:12,030
The first one takes a destination, a source and a size.

00:56:12,030 --> 00:56:16,320
The second takes a source, a destination and a size.

00:56:16,320 --> 00:56:22,050
So, what happens, you know, if somebody assumes one ordering when they call the other method?

00:56:22,050 --> 00:56:26,450
They clobber their source data with whatever garbage was in their destination array.

00:56:26,450 --> 00:56:29,440
And how long does that take to find that bug?

00:56:29,440 --> 00:56:31,510
Probably a really, really long time.

00:56:31,510 --> 00:56:35,500
This is particularly important when the types of the two parameters are identical because

00:56:35,500 --> 00:56:38,950
if you switch them around, you will not know at compile time.

00:56:38,950 --> 00:56:44,500
A good example here is in Java.util.Collections, the first value is always the collection being

00:56:44,500 --> 00:56:46,880
mutated or manipulated.

00:56:46,880 --> 00:56:52,480
Similarly, in util concurrent, when you have an amount of time, you always specify it as

00:56:52,480 --> 00:56:54,820
a delay followed by time unit never other a way around.

00:56:54,820 --> 00:56:57,960
And even if it were the other a way around, the compiler would tell you because these

00:56:57,960 --> 00:57:00,690
are strong types that are incompatible.

00:57:00,690 --> 00:57:03,630
A long and the time unit are two different things.

00:57:03,630 --> 00:57:05,670
You should avoid long parameter list.

00:57:05,670 --> 00:57:07,130
Ideally, you should limit them to three.

00:57:07,130 --> 00:57:11,590
It's really easy to remember three things especially, you should avoid long list of

00:57:11,590 --> 00:57:14,490
identically typed parameters because of the problems that I've told you before.

00:57:14,490 --> 00:57:16,310
If you get the order wrong, you're hosed.

00:57:16,310 --> 00:57:18,760
So here's an example of what not to do.

00:57:18,760 --> 00:57:22,530
This is from the Win3 to API, to create a window.

00:57:22,530 --> 00:57:26,650
You know, if you look in the middle of these, whatever 15 parameters, you see Int x, Int

00:57:26,650 --> 00:57:28,030
y, Int end with, Int height.

00:57:28,030 --> 00:57:31,200
So, here's, you know, a whole string of Ints and by the way some of these other things

00:57:31,200 --> 00:57:33,100
are also Ints, just Int by another name.

00:57:33,100 --> 00:57:37,770
So, you know, without support from an IDE it's pretty much impossible to use this API.

00:57:37,770 --> 00:57:41,339
Luckily, there are number of great techniques for shorting parameter list.

00:57:41,339 --> 00:57:44,540
One thing you can do is break up a method into a multiple methods, or you can create

00:57:44,540 --> 00:57:46,740
a helper classes to hold the parameters.

00:57:46,740 --> 00:57:51,950
A specific example of the helper class is the builder pattern, where if you got a constructor

00:57:51,950 --> 00:57:56,280
or a static factory that naturally would take 10 parameters, most of which you don't have

00:57:56,280 --> 00:57:58,430
to specify, most of which have good defaults.

00:57:58,430 --> 00:58:03,119
Instead, make a builder and then just plug-in the ones you actually care about and then

00:58:03,119 --> 00:58:04,170
call a build method.

00:58:04,170 --> 00:58:08,020
And that code will be much easier to write and to read.

00:58:08,020 --> 00:58:11,420
You should avoid return values that demand exceptional processing.

00:58:11,420 --> 00:58:17,790
In particular, you should never return a, "No," instead of a zero-length array or collections.

00:58:17,790 --> 00:58:20,520
Here is an example of something we got wrong.

00:58:20,520 --> 00:58:25,390
The--in the buffered image op-class, we have a method called get rendering hints.

00:58:25,390 --> 00:58:31,079
And either, it returns a rendering hints collection or it returns, "No."

00:58:31,079 --> 00:58:32,950
And what's the consequence of this?

00:58:32,950 --> 00:58:37,270
Almost all code that calls this thing is wrong because it rarely returns, "No."

00:58:37,270 --> 00:58:39,930
So, people forget to code for that special case.

00:58:39,930 --> 00:58:41,710
If they do get a no, what happens?

00:58:41,710 --> 00:58:45,569
No point or exception and it's completely unnecessary.

00:58:45,569 --> 00:58:50,210
If they just returned a zero-length collection, then they wouldn't got into any trouble.

00:58:50,210 --> 00:58:55,280
So, I think I'm actually going to skip the rest of the talk because I'm out of time.

00:58:55,280 --> 00:58:58,250
In fact, I've already used up five minutes more time than I have.

00:58:58,250 --> 00:59:00,079
But if you have any other collection--try again.

00:59:00,079 --> 00:59:04,910
If you have any other questions, I'll be around for a while afterwards and you can ask me

00:59:04,910 --> 00:59:05,910
anything you'd like.

00:59:05,910 --> 00:59:09,970
So, thanks for coming.

00:59:09,970 --> 00:59:17,130
Oh, one other thing, which is I have a--I have a give-away for you, which is--when I

00:59:17,130 --> 00:59:25,520
gave this at OOPSLA in the proceedings, they gave me two pages to put in a--what do you

00:59:25,520 --> 00:59:26,520
call that?

00:59:26,520 --> 00:59:27,520
Like an extended abstract.

00:59:27,520 --> 00:59:30,740
And instead of doing that, I tried to do API design by bumper sticker.

00:59:30,740 --> 00:59:36,520
I try to basically take this entire talk and break it down into 50 little maxims, like,

00:59:36,520 --> 00:59:41,490
when in doubt, leave it out or, you know, all programmers are API designers, each with

00:59:41,490 --> 00:59:43,890
a sort of a sentence describing, you know, in a bit more detail.

00:59:43,890 --> 00:59:47,359
So here, pass this out amongst yourselves, as best you can.

00:59:47,359 --> 00:59:53,460
And I'll put it up on, you know--and tell the JJB in case there are more of you than

00:59:53,460 --> 00:59:55,130
there are piece of paper.

00:59:55,130 --> 01:00:08,249

YouTube URL: https://www.youtube.com/watch?v=aAb7hSCtvGw


