Title: Larry Wall Speaks at Google
Publication date: 2011-03-09
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talks
June 19, 2008

ABSTRACT

While visiting Chicago for Yet Another Perl Conference, Larry Wall will be visiting the Chicago Google office to speak about the conference, the language, and the community.

Speaker: Larry Wall
Captions: 
	00:00:22,430 --> 00:00:27,230
I often get get this sort of question

00:00:25,850 --> 00:00:29,060
over the years I've gotten it many many

00:00:27,230 --> 00:00:31,400
times usually from people interviewing

00:00:29,060 --> 00:00:32,630
me for a magazine if you had to do it

00:00:31,400 --> 00:00:34,670
all over what would you do differently

00:00:32,630 --> 00:00:37,360
and there's really only two good answers

00:00:34,670 --> 00:00:40,730
to that one of them of course is nothing

00:00:37,360 --> 00:00:42,739
and that was the purl answer for many

00:00:40,730 --> 00:00:44,960
years and the other good answer is

00:00:42,739 --> 00:00:49,790
everything and that's more or less the

00:00:44,960 --> 00:00:52,580
Pearl six answer when we decided do

00:00:49,790 --> 00:00:54,680
pearl six we decided on the one hand to

00:00:52,580 --> 00:00:57,380
clean up a lot of the cruft no we

00:00:54,680 --> 00:01:03,040
decided to clean up follow the craft for

00:00:57,380 --> 00:01:07,160
our definition and so in particular you

00:01:03,040 --> 00:01:09,470
know when Pearl started out it was you

00:01:07,160 --> 00:01:11,899
didn't have a following of course so I

00:01:09,470 --> 00:01:14,810
had to borrow a lot of UNIX culture into

00:01:11,899 --> 00:01:17,930
Pearl and a lot of that culture was

00:01:14,810 --> 00:01:23,750
already crufty namely regular expression

00:01:17,930 --> 00:01:27,280
syntax and we only made it worse so that

00:01:23,750 --> 00:01:31,310
was part of our mandate to clean that up

00:01:27,280 --> 00:01:35,510
but on a deeper level we we didn't just

00:01:31,310 --> 00:01:37,159
want to fix the syntax we wanted to fix

00:01:35,510 --> 00:01:40,670
all these there's the fundamental flaws

00:01:37,159 --> 00:01:45,229
in that in the think O's and the design

00:01:40,670 --> 00:01:47,150
O's so one of the major bad decisions

00:01:45,229 --> 00:01:50,950
that I made early on was to treat

00:01:47,150 --> 00:01:50,950
regular expressions as a kind of string

00:01:52,659 --> 00:01:57,530
instead in Perl 6 we tried to treat them

00:01:55,189 --> 00:02:00,200
as a kind of language more specifically

00:01:57,530 --> 00:02:01,180
a sub language and I'll get into what I

00:02:00,200 --> 00:02:04,100
mean by that

00:02:01,180 --> 00:02:06,079
here's a statement that you could make

00:02:04,100 --> 00:02:10,940
in either Perl 5 or Perl 6 but they mean

00:02:06,079 --> 00:02:13,570
somewhat different things declare a

00:02:10,940 --> 00:02:17,680
matched variable and initialize it in

00:02:13,570 --> 00:02:20,900
Perl 5 it treats this as a string and

00:02:17,680 --> 00:02:23,860
interpolates that variable and then it

00:02:20,900 --> 00:02:28,250
reparse --is it as a regular expression

00:02:23,860 --> 00:02:30,880
that's bad in Perl 6 it's just a

00:02:28,250 --> 00:02:30,880
language and

00:02:31,420 --> 00:02:36,950
we'll see how that works as we go along

00:02:33,680 --> 00:02:40,489
but it only does one pass of parsing and

00:02:36,950 --> 00:02:42,770
it treats it as a sub language so when

00:02:40,489 --> 00:02:45,739
is the language not a language well

00:02:42,770 --> 00:02:48,590
actually when it's many languages and so

00:02:45,739 --> 00:02:51,410
what we've discovered was with the Perl

00:02:48,590 --> 00:02:55,400
6 effort is that Perl 6 isn't a single

00:02:51,410 --> 00:02:58,160
language you know Perl 5 is one language

00:02:55,400 --> 00:03:00,080
that's how we thought of it we're

00:02:58,160 --> 00:03:01,910
thinking that Perl 6 is many languages

00:03:00,080 --> 00:03:11,540
or if you're British Perl 6 are many

00:03:01,910 --> 00:03:14,540
languages but in Perl culture we don't

00:03:11,540 --> 00:03:18,560
tell you how to think and people think

00:03:14,540 --> 00:03:20,690
in different languages well actually we

00:03:18,560 --> 00:03:22,430
want you to think that we do tell you

00:03:20,690 --> 00:03:27,709
how to think we just don't tell you what

00:03:22,430 --> 00:03:29,599
to think well we do that too oh well and

00:03:27,709 --> 00:03:31,130
what you should think is there's more

00:03:29,599 --> 00:03:34,459
than one way to do it which is one of

00:03:31,130 --> 00:03:37,820
the Perl slogans and that's my nickname

00:03:34,459 --> 00:03:40,070
Tim toady is a pun on that but one of

00:03:37,820 --> 00:03:43,340
the things that has always been the case

00:03:40,070 --> 00:03:45,140
with Perl is that you're allowed to talk

00:03:43,340 --> 00:03:47,269
at different levels of linguistic

00:03:45,140 --> 00:03:49,160
sophistication we don't expect a

00:03:47,269 --> 00:03:52,060
fifty-year-old to speak with the same

00:03:49,160 --> 00:03:55,390
diction as a five-year-old or vice-versa

00:03:52,060 --> 00:03:58,069
so you're allowed to do baby talk and

00:03:55,390 --> 00:04:00,350
you're allowed in fact to do cargo cult

00:03:58,069 --> 00:04:02,060
programming at the beginning you don't

00:04:00,350 --> 00:04:04,250
necessarily have to understand it you

00:04:02,060 --> 00:04:06,290
just sort of put the things there and

00:04:04,250 --> 00:04:09,790
bow down to them and they do the right

00:04:06,290 --> 00:04:11,870
thing and later as you're going along

00:04:09,790 --> 00:04:13,430
when you have to change it and it

00:04:11,870 --> 00:04:14,989
doesn't work you have to learn why it

00:04:13,430 --> 00:04:21,560
didn't work and then you start learning

00:04:14,989 --> 00:04:23,990
the the underlying um semantics

00:04:21,560 --> 00:04:31,040
but I would like to say or at least

00:04:23,990 --> 00:04:35,330
assert today that the computing culture

00:04:31,040 --> 00:04:39,530
as a whole as has gotten stuck in a

00:04:35,330 --> 00:04:45,200
level of cargo cult thinking with regard

00:04:39,530 --> 00:04:47,470
to parsing instead of that I would like

00:04:45,200 --> 00:04:50,000
to think in terms of derived languages

00:04:47,470 --> 00:04:52,160
where we don't copy and paste our

00:04:50,000 --> 00:04:54,110
compilers oh I want a new compiler I

00:04:52,160 --> 00:04:55,970
let's I want it to be kind of like that

00:04:54,110 --> 00:04:59,690
one so I'll copy the Yak grammar over

00:04:55,970 --> 00:05:01,130
and then I'll start tweaking it instead

00:04:59,690 --> 00:05:04,040
we should do something a little more

00:05:01,130 --> 00:05:05,720
modern modern you know polymorphism

00:05:04,040 --> 00:05:19,040
isn't that modern but it's modern er

00:05:05,720 --> 00:05:20,680
than cut and paste so when you see a we

00:05:19,040 --> 00:05:27,050
want to parse something like this

00:05:20,680 --> 00:05:28,789
instead of instead of a standard parser

00:05:27,050 --> 00:05:31,910
where you have a yak grammar that's kind

00:05:28,789 --> 00:05:38,050
of fixed and and just there's there's a

00:05:31,910 --> 00:05:39,950
special rule for for this and on you go

00:05:38,050 --> 00:05:41,510
you know there you see some

00:05:39,950 --> 00:05:43,220
commonalities here this this is a

00:05:41,510 --> 00:05:46,250
different language than that than the

00:05:43,220 --> 00:05:48,080
outside of it so when you're when you're

00:05:46,250 --> 00:05:49,610
parsing at this point you want to be

00:05:48,080 --> 00:05:51,710
parsing against a different set of rules

00:05:49,610 --> 00:05:53,960
than when you're out here on the other

00:05:51,710 --> 00:05:56,870
hand when you're parsing a variable

00:05:53,960 --> 00:05:59,260
you'd like them to be the using the same

00:05:56,870 --> 00:06:05,720
rules you don't want to duplicate rules

00:05:59,260 --> 00:06:09,410
likewise well likewise if you're if

00:06:05,720 --> 00:06:11,539
you're going on to to use double coated

00:06:09,410 --> 00:06:14,030
strings that do interpolation here's a

00:06:11,539 --> 00:06:15,710
language where dollars means something

00:06:14,030 --> 00:06:17,930
special and backslashes means something

00:06:15,710 --> 00:06:21,560
sub special if you change it to two

00:06:17,930 --> 00:06:24,410
single quotes it's a different language

00:06:21,560 --> 00:06:27,410
and that's the way we are choosing to

00:06:24,410 --> 00:06:29,750
think of it here so I bypass this little

00:06:27,410 --> 00:06:34,609
thing here which how we're doing this

00:06:29,750 --> 00:06:38,589
regular expressions are in fact derived

00:06:34,609 --> 00:06:40,939
from the Perl grammar here let me

00:06:38,589 --> 00:06:46,489
actually show you the prick let me move

00:06:40,939 --> 00:06:52,449
this a little closer to the other space

00:06:46,489 --> 00:06:52,449
here 12 okay

00:06:52,669 --> 00:06:57,319
here's the the standard pearl grammar

00:06:54,919 --> 00:07:01,189
don't worry about the comments and read

00:06:57,319 --> 00:07:05,330
if you can't see them now this is

00:07:01,189 --> 00:07:07,249
actually written in Perl 6 and it's

00:07:05,330 --> 00:07:11,029
probably nothing like any Perl 6 you've

00:07:07,249 --> 00:07:13,189
you've ever seen before or nothing like

00:07:11,029 --> 00:07:14,419
any Perl 5 you've seen before if you've

00:07:13,189 --> 00:07:19,069
seen pearl 6 and it'd probably be

00:07:14,419 --> 00:07:21,830
something like it but it has grammars

00:07:19,069 --> 00:07:24,949
that are essentially just classes so if

00:07:21,830 --> 00:07:26,900
I go down here and find the rate write a

00:07:24,949 --> 00:07:29,990
regular expression grammar it is derived

00:07:26,900 --> 00:07:35,439
from the Perl grammar and it overrides

00:07:29,990 --> 00:07:35,439
some of the methods and off you go

00:07:38,259 --> 00:07:43,360
here's another example let's go back to

00:07:46,150 --> 00:07:52,630
when you're parsing quotes here such as

00:07:50,340 --> 00:07:57,010
those single and double quotes you just

00:07:52,630 --> 00:08:00,250
saw here's the double quotes find a find

00:07:57,010 --> 00:08:02,680
a double quote call this special rule

00:08:00,250 --> 00:08:04,930
that is parameterised as parameterised

00:08:02,680 --> 00:08:07,990
on the language that you want to parse

00:08:04,930 --> 00:08:10,180
inside take start with the base Q

00:08:07,990 --> 00:08:11,979
language tweak that to have double quote

00:08:10,180 --> 00:08:15,970
semantics tweak that to have a

00:08:11,979 --> 00:08:20,440
terminator of a double and a double

00:08:15,970 --> 00:08:25,440
quote and parse that and then look for a

00:08:20,440 --> 00:08:25,440
terminating double quote the actual

00:08:27,510 --> 00:08:41,110
nibbler regular expression using the

00:08:33,070 --> 00:08:42,849
term loosely is right here and so this

00:08:41,110 --> 00:08:45,990
is going to loop over all the characters

00:08:42,849 --> 00:08:48,190
first it's going to if it finds a a

00:08:45,990 --> 00:08:52,150
whatever the stopper is which in this

00:08:48,190 --> 00:08:54,339
case double quote and then it quits if

00:08:52,150 --> 00:08:56,230
you're doing nested bracketing sort of

00:08:54,339 --> 00:08:58,000
quoting it's got to find a starter and

00:08:56,230 --> 00:09:00,910
keep the nesting straight and calls

00:08:58,000 --> 00:09:03,160
itself recursively if it finds an escape

00:09:00,910 --> 00:09:07,150
which is like the dollar signs the back

00:09:03,160 --> 00:09:08,890
slashes it handles those two but again

00:09:07,150 --> 00:09:10,779
it's polymorphic over whichever language

00:09:08,890 --> 00:09:13,420
you're dealing with and finally at the

00:09:10,779 --> 00:09:20,650
bottom just grab another character and

00:09:13,420 --> 00:09:22,810
and add it to the text so that that's

00:09:20,650 --> 00:09:24,310
one aspect of it another words that I'd

00:09:22,810 --> 00:09:29,800
like to describe is called transitive

00:09:24,310 --> 00:09:31,980
alternation here's another rule which if

00:09:29,800 --> 00:09:31,980
I uh

00:09:33,300 --> 00:09:38,629
yeah

00:09:34,889 --> 00:09:38,629
I actually show it here

00:09:41,110 --> 00:09:46,209
it looks like that in long-form it's got

00:09:44,709 --> 00:09:49,570
a label on the front of a statement and

00:09:46,209 --> 00:09:52,209
since various modifiers but in essence

00:09:49,570 --> 00:09:54,250
this is doing this it says a statement

00:09:52,209 --> 00:09:58,140
is composed of a statement control or an

00:09:54,250 --> 00:10:01,390
expression or just a bear let me call it

00:09:58,140 --> 00:10:06,850
well but that can be expanded out an

00:10:01,390 --> 00:10:09,279
expression starts off with a term and we

00:10:06,850 --> 00:10:11,890
actually have a an operator precedence

00:10:09,279 --> 00:10:14,529
parser sandwiched in the middle of a

00:10:11,890 --> 00:10:16,930
recursive descent parser and that is

00:10:14,529 --> 00:10:18,550
that is what the the operator precedence

00:10:16,930 --> 00:10:20,019
parser is going to look for first so

00:10:18,550 --> 00:10:21,910
that's what that really means in terms

00:10:20,019 --> 00:10:23,260
of what we're looking for at that moment

00:10:21,910 --> 00:10:26,019
the exact language that we're matching

00:10:23,260 --> 00:10:27,100
well but that expands out the if you're

00:10:26,019 --> 00:10:30,490
looking for a term you're looking for

00:10:27,100 --> 00:10:32,890
some sort of prefix or a noun and that

00:10:30,490 --> 00:10:37,510
expands out to various kinds of nouns

00:10:32,890 --> 00:10:39,570
and prefix operators and on you go the

00:10:37,510 --> 00:10:41,950
point of this is that that purl fives

00:10:39,570 --> 00:10:45,640
alternation the vertical bar is not the

00:10:41,950 --> 00:10:48,519
same as purl sixes in purl 5 you know in

00:10:45,640 --> 00:10:52,510
the purl compatible regular expressions

00:10:48,519 --> 00:10:54,579
that everybody is borrowed it means

00:10:52,510 --> 00:10:56,500
check the left thing and if that doesn't

00:10:54,579 --> 00:11:00,730
match check the right thing it's like a

00:10:56,500 --> 00:11:04,209
short-circuit operator instead in purl 6

00:11:00,730 --> 00:11:07,570
we go back to sort of the the original

00:11:04,209 --> 00:11:10,959
definitions of irregular expressions for

00:11:07,570 --> 00:11:14,350
DFAS and single vertical bar is is

00:11:10,959 --> 00:11:16,959
parallel matching of all the

00:11:14,350 --> 00:11:20,949
alternatives simultaneously and then we

00:11:16,959 --> 00:11:22,750
then we use the double vertical bar much

00:11:20,949 --> 00:11:26,350
more consistently for the serial

00:11:22,750 --> 00:11:27,760
matching but the question is who wins

00:11:26,350 --> 00:11:30,760
when there's a conflict in these

00:11:27,760 --> 00:11:34,149
alternatives is the first the oldest

00:11:30,760 --> 00:11:37,480
newest is it a core rule that should

00:11:34,149 --> 00:11:42,760
match or easier to find the problem with

00:11:37,480 --> 00:11:44,170
the core is Perl 6 is got this little

00:11:42,760 --> 00:11:48,220
problem if you're going to define it

00:11:44,170 --> 00:11:50,380
that way is in that it has no core Perl

00:11:48,220 --> 00:11:52,870
6 has no keywords to the first

00:11:50,380 --> 00:11:55,320
approximation and it has no built-in

00:11:52,870 --> 00:11:58,029
operators

00:11:55,320 --> 00:12:01,839
instead everything is is built up out of

00:11:58,029 --> 00:12:05,470
out of these rules you can think of the

00:12:01,839 --> 00:12:08,949
entire Perl 6 language as just the

00:12:05,470 --> 00:12:11,730
result of matching a fairly fancy

00:12:08,949 --> 00:12:15,120
regular expression against the string so

00:12:11,730 --> 00:12:19,350
this is the way you define sub rules and

00:12:15,120 --> 00:12:24,339
so the built in operators like + + + + I

00:12:19,350 --> 00:12:26,050
just come in that way should

00:12:24,339 --> 00:12:29,889
user-defined operators take precedence

00:12:26,050 --> 00:12:35,199
over built-in ones well maybe if I

00:12:29,889 --> 00:12:42,610
define my own prefix symbol like + - I

00:12:35,199 --> 00:12:47,259
can do that ok let's try it here you

00:12:42,610 --> 00:12:54,790
know there there there is no there's no

00:12:47,259 --> 00:12:57,690
+ - in the standard grammar here but if

00:12:54,790 --> 00:13:00,760
I have a grammar that is derived from

00:12:57,690 --> 00:13:06,449
the one you just saw and I define a

00:13:00,760 --> 00:13:06,449
token + - I can actually use that

00:13:12,700 --> 00:13:20,440
and up here we see that we get good as

00:13:16,090 --> 00:13:26,710
actually get a symbol plus - that's a

00:13:20,440 --> 00:13:31,660
prefix operator so that actually you

00:13:26,710 --> 00:13:33,310
know works rather nicely but and that

00:13:31,660 --> 00:13:34,750
obviously it takes precedence over it

00:13:33,310 --> 00:13:36,940
over the plus operator so it doesn't

00:13:34,750 --> 00:13:40,000
parse that as plus and then a minus and

00:13:36,940 --> 00:13:43,270
then that on the other hand is suppose I

00:13:40,000 --> 00:13:45,100
define an infix cm operator you know

00:13:43,270 --> 00:13:47,350
maybe it maybe it compares to Roman

00:13:45,100 --> 00:13:49,830
numerals to see if they're 900 apart or

00:13:47,350 --> 00:13:49,830
something like that

00:13:52,520 --> 00:13:56,290
all taking your afternoon nap huh

00:13:57,379 --> 00:14:02,569
caffeine works wonders well should

00:14:00,269 --> 00:14:05,609
easily defined take precedence well

00:14:02,569 --> 00:14:07,439
probably not because if there's a pee

00:14:05,609 --> 00:14:10,409
after it you probably want to do the

00:14:07,439 --> 00:14:12,689
comparison operator instead I wanted to

00:14:10,409 --> 00:14:15,989
do what I mean which usually means that

00:14:12,689 --> 00:14:17,609
I want longest talking magic and we talk

00:14:15,989 --> 00:14:22,709
about this so much is just short

00:14:17,609 --> 00:14:24,269
shortened to LTM but you know longest

00:14:22,709 --> 00:14:25,619
talking matching is is great but what

00:14:24,269 --> 00:14:28,439
about how does how does that play out

00:14:25,619 --> 00:14:32,159
with all this polymorphism because

00:14:28,439 --> 00:14:33,719
polymorphism means very light binding so

00:14:32,159 --> 00:14:35,609
what it comes out to is that we need a

00:14:33,719 --> 00:14:38,159
just-in-time lexer for every language

00:14:35,609 --> 00:14:40,019
now we're considering the inside of

00:14:38,159 --> 00:14:42,539
quotes and regular expressions to be a

00:14:40,019 --> 00:14:45,059
different language so it has to create

00:14:42,539 --> 00:14:50,369
those languages let's see I already

00:14:45,059 --> 00:14:55,709
showed you the plus/minus pearl sort of

00:14:50,369 --> 00:15:04,349
mini language and where'd it go here but

00:14:55,709 --> 00:15:06,269
when I ran that it actually Malec sirs

00:15:04,349 --> 00:15:07,649
here you it's hard to see but there

00:15:06,269 --> 00:15:10,799
there's a standard pearl lexer and

00:15:07,649 --> 00:15:14,219
there's a plus - pearl Lexor they're

00:15:10,799 --> 00:15:16,799
just kept out as a handy cash it could

00:15:14,219 --> 00:15:26,839
be all in memory so if I go down to Lex

00:15:16,799 --> 00:15:26,839
and plus - pearl and look here let's see

00:15:27,530 --> 00:15:36,530
yeah just in time Luxor okay so there is

00:15:32,900 --> 00:15:39,670
let's see it's a prefix operator so

00:15:36,530 --> 00:15:39,670
let's look at see what

00:15:42,370 --> 00:15:53,350
under the prefix operators that

00:15:44,319 --> 00:15:54,790
generated this this Luxor here and we

00:15:53,350 --> 00:15:57,850
see right up to the front here is our

00:15:54,790 --> 00:16:00,339
plus/minus operator that we defined in

00:15:57,850 --> 00:16:02,470
our derived grammar plus all that all of

00:16:00,339 --> 00:16:06,730
the operators that came in from the

00:16:02,470 --> 00:16:09,279
standard grammar this part of it can be

00:16:06,730 --> 00:16:13,360
matched by a DFA engine with the longest

00:16:09,279 --> 00:16:16,420
token semantics and once we do that it

00:16:13,360 --> 00:16:19,480
immediately knows as soon as it matches

00:16:16,420 --> 00:16:20,920
that what the next few steps are in the

00:16:19,480 --> 00:16:24,009
recursive descent parser so it doesn't

00:16:20,920 --> 00:16:25,660
have to decide anything it just cascades

00:16:24,009 --> 00:16:27,850
down rapidly and I wish I had more time

00:16:25,660 --> 00:16:30,339
to show that to you but then I couldn't

00:16:27,850 --> 00:16:32,259
tell you about the other cool stuff so

00:16:30,339 --> 00:16:35,410
you know there's an old saying only Perl

00:16:32,259 --> 00:16:39,279
can parse Perl and it sort of extends to

00:16:35,410 --> 00:16:40,480
Perl 6 as well it's not it's only

00:16:39,279 --> 00:16:43,709
slightly true because we're actually

00:16:40,480 --> 00:16:47,050
bootstrapping it in other languages but

00:16:43,709 --> 00:16:50,889
we can at least modify it too it's

00:16:47,050 --> 00:16:52,540
easier to parse Perl 6 in Perl 6 the

00:16:50,889 --> 00:16:56,009
fact is all of these regular expressions

00:16:52,540 --> 00:16:58,959
if you scratch them they're just methods

00:16:56,009 --> 00:17:01,240
it relies on multiple dispatch semantics

00:16:58,959 --> 00:17:05,470
and this concept of short and long names

00:17:01,240 --> 00:17:07,600
where if I say match a prefix that's the

00:17:05,470 --> 00:17:10,270
short name of a rule but it's really

00:17:07,600 --> 00:17:12,730
standing in for a bunch of long names

00:17:10,270 --> 00:17:16,299
where it's prefixed this prefix that

00:17:12,730 --> 00:17:18,520
prefix the other thing this auto lexing

00:17:16,299 --> 00:17:20,649
with the transitive alternation all

00:17:18,520 --> 00:17:22,659
these every time you come to a new

00:17:20,649 --> 00:17:24,130
alternative it hoists all these things

00:17:22,659 --> 00:17:27,339
up and builds a new lecture if it needs

00:17:24,130 --> 00:17:28,809
to for that and all the alternatives are

00:17:27,339 --> 00:17:32,230
considered equal all the way down

00:17:28,809 --> 00:17:35,200
there's no first class second second

00:17:32,230 --> 00:17:36,309
class operators no built-ins vs.

00:17:35,200 --> 00:17:42,130
user-defined

00:17:36,309 --> 00:17:44,440
it's all on equal on an equal footing so

00:17:42,130 --> 00:17:49,750
when you when you see this this sort of

00:17:44,440 --> 00:17:52,240
an alternate alternation it all just

00:17:49,750 --> 00:17:54,809
works out and it keeps hoisting it

00:17:52,240 --> 00:17:54,809
upwards so

00:17:55,419 --> 00:18:02,000
so well the well we saw the Akiko in the

00:18:00,230 --> 00:18:05,289
wrong direction it's because I had it

00:18:02,000 --> 00:18:08,559
the other side before I can fix that

00:18:05,289 --> 00:18:08,559
excuse me

00:18:12,450 --> 00:18:15,450
okay

00:18:20,310 --> 00:18:29,580
if we go to the standard pearl looks

00:18:22,530 --> 00:18:32,120
here here and look a statement did I use

00:18:29,580 --> 00:18:32,120
the statement

00:18:38,450 --> 00:18:47,150
I did not so let's uh saw you improve

00:18:42,950 --> 00:18:49,730
its generating it on the fly here I will

00:18:47,150 --> 00:18:52,190
I will parse a one of the tests out of

00:18:49,730 --> 00:18:54,620
the test suite it's about eight thousand

00:18:52,190 --> 00:18:58,060
bytes that parsed in about four seconds

00:18:54,620 --> 00:19:00,050
so it's doing about with no special

00:18:58,060 --> 00:19:01,400
optimizations about doing doing about

00:19:00,050 --> 00:19:04,460
two thousand characters a second at the

00:19:01,400 --> 00:19:08,450
moment so now if I go back to Lex

00:19:04,460 --> 00:19:11,210
or I'll let's see what we have okay now

00:19:08,450 --> 00:19:15,050
we have statement one which is the first

00:19:11,210 --> 00:19:17,390
alternative inside statements and we can

00:19:15,050 --> 00:19:20,120
see all the statement controls at the

00:19:17,390 --> 00:19:22,820
front they're just like the rule has if

00:19:20,120 --> 00:19:28,340
we go on down we see the terms that

00:19:22,820 --> 00:19:30,680
start off an expression nouns keep on

00:19:28,340 --> 00:19:34,250
going down more nouns more nouns prefix

00:19:30,680 --> 00:19:36,020
operators and this is hosted up that

00:19:34,250 --> 00:19:38,470
lexer into the ends of the higher-level

00:19:36,020 --> 00:19:38,470
lexer

00:19:41,790 --> 00:19:47,940
we're doing that time okay time flies

00:19:46,020 --> 00:19:50,910
now of course I'm going the other

00:19:47,940 --> 00:19:53,520
direction don't have time to talk about

00:19:50,910 --> 00:19:56,070
back off on longest tokens it's just a

00:19:53,520 --> 00:19:59,160
form of backtracking

00:19:56,070 --> 00:20:03,240
but the Thais are reserved by the order

00:19:59,160 --> 00:20:07,200
they came they were declared the longest

00:20:03,240 --> 00:20:08,970
tokens are by and large they're derived

00:20:07,200 --> 00:20:12,540
automatically from the grammar that you

00:20:08,970 --> 00:20:14,100
write it knows which things which

00:20:12,540 --> 00:20:15,210
matters have side effects and which ones

00:20:14,100 --> 00:20:16,920
don't and the ones that have side

00:20:15,210 --> 00:20:20,160
effects terminate your longest token

00:20:16,920 --> 00:20:24,180
matter but you can explicitly use this

00:20:20,160 --> 00:20:26,190
this symbol which is both a backtracking

00:20:24,180 --> 00:20:28,590
control and essentially means this is

00:20:26,190 --> 00:20:32,580
the end of the token if you don't match

00:20:28,590 --> 00:20:34,650
after this it's an error and these are

00:20:32,580 --> 00:20:37,170
all sorts of other things that Perl 6

00:20:34,650 --> 00:20:39,600
provides which I don't have time to talk

00:20:37,170 --> 00:20:43,290
about that but they're the sort of the

00:20:39,600 --> 00:20:45,420
the boring things that that are very

00:20:43,290 --> 00:20:48,240
useful in writing a grammar I'd like to

00:20:45,420 --> 00:20:49,680
talk more about the handy stuff about

00:20:48,240 --> 00:20:52,290
putting the regular back into regular

00:20:49,680 --> 00:20:55,950
expressions and about how we've powered

00:20:52,290 --> 00:20:58,710
them up while we regularize them and

00:20:55,950 --> 00:21:00,810
yeah we we expect people to steal these

00:20:58,710 --> 00:21:05,550
regular expressions like they did Perl

00:21:00,810 --> 00:21:06,840
5s regular expressions that's great I

00:21:05,550 --> 00:21:10,820
talked about the difference between

00:21:06,840 --> 00:21:13,470
those gotten to handy new back back back

00:21:10,820 --> 00:21:16,980
mattress for horizontal and vertical

00:21:13,470 --> 00:21:19,140
work whitespace how often do you want to

00:21:16,980 --> 00:21:21,000
just say well I want them I want to

00:21:19,140 --> 00:21:23,250
match whitespace but I don't want to go

00:21:21,000 --> 00:21:27,060
to a new line if it don't match the new

00:21:23,250 --> 00:21:28,890
light things like that in Perl 5 we

00:21:27,060 --> 00:21:30,510
discovered the extent and extended

00:21:28,890 --> 00:21:32,900
syntax which was white space between

00:21:30,510 --> 00:21:36,090
tokens was wonderful for readability and

00:21:32,900 --> 00:21:39,240
so wonderful it's it's now sort of

00:21:36,090 --> 00:21:43,290
mandatory so you don't have to specify

00:21:39,240 --> 00:21:45,570
it there's no more / s modifier because

00:21:43,290 --> 00:21:47,190
you just you just ambigú 8 right there

00:21:45,570 --> 00:21:49,190
in the regular expressions if you want

00:21:47,190 --> 00:21:52,020
to match not a newline

00:21:49,190 --> 00:21:53,860
you know backslash lower case n is match

00:21:52,020 --> 00:21:56,590
a newline so

00:21:53,860 --> 00:21:59,170
by the rule that we uppercase the

00:21:56,590 --> 00:22:01,299
matches that are negated that's not a

00:21:59,170 --> 00:22:05,620
new line and dot always matches every

00:22:01,299 --> 00:22:08,620
character similarly we don't have modes

00:22:05,620 --> 00:22:10,600
on the on the multi-line matching you

00:22:08,620 --> 00:22:12,840
use a different token for matching the

00:22:10,600 --> 00:22:14,920
beginning of the string versus matching

00:22:12,840 --> 00:22:17,740
the beginning of a line within the

00:22:14,920 --> 00:22:19,179
string and it's very readable because

00:22:17,740 --> 00:22:20,590
right there you don't have to look to

00:22:19,179 --> 00:22:22,799
the end of the regular expression for it

00:22:20,590 --> 00:22:24,940
we've regularized all the brackets

00:22:22,799 --> 00:22:27,429
friends are always for capturing that's

00:22:24,940 --> 00:22:33,250
that's the same we stole in the square

00:22:27,429 --> 00:22:35,470
brackets for non capturing bracketing we

00:22:33,250 --> 00:22:38,350
stolen the curlies for embedded code

00:22:35,470 --> 00:22:41,650
closures we call them because they

00:22:38,350 --> 00:22:43,660
aren't I've stolen the the angle

00:22:41,650 --> 00:22:46,390
brackets for all the other where most

00:22:43,660 --> 00:22:48,760
the other meta notations in particular

00:22:46,390 --> 00:22:51,820
character classes are demoted to being

00:22:48,760 --> 00:22:54,160
inside of angle brackets because usually

00:22:51,820 --> 00:22:55,840
in the age of Unicode if you're using a

00:22:54,160 --> 00:22:57,460
character class that's wrong anyway

00:22:55,840 --> 00:23:03,580
so we'll give it a slightly longer

00:22:57,460 --> 00:23:09,360
Huffman coding and since we stole the

00:23:03,580 --> 00:23:13,030
Curly's for the general quantification

00:23:09,360 --> 00:23:17,890
then we have our new notation that's

00:23:13,030 --> 00:23:19,929
much more readable I think and a cool

00:23:17,890 --> 00:23:21,669
quantifier you can quantify not just

00:23:19,929 --> 00:23:23,980
based on it on a range of numbers but

00:23:21,669 --> 00:23:28,030
you can quantify saying as long as there

00:23:23,980 --> 00:23:32,110
is a comma between these things match as

00:23:28,030 --> 00:23:32,980
many digits as you can that's you're

00:23:32,110 --> 00:23:36,540
probably bt+

00:23:32,980 --> 00:23:36,540
to match a sequence of digits

00:23:36,679 --> 00:23:43,090
word boundary operators that are

00:23:39,080 --> 00:23:46,820
directional using fancy French quotes

00:23:43,090 --> 00:23:50,139
you can you can now use all of the the

00:23:46,820 --> 00:23:52,249
the all of the non alphanumeric

00:23:50,139 --> 00:23:54,529
characters are now considered

00:23:52,249 --> 00:23:56,059
potentially meta characters so you don't

00:23:54,529 --> 00:24:04,190
have to keep a list in your head of is

00:23:56,059 --> 00:24:06,379
this thing a meta character or not since

00:24:04,190 --> 00:24:08,779
we are not doing interpolation like

00:24:06,379 --> 00:24:12,860
strings we can we can match whatever is

00:24:08,779 --> 00:24:16,039
in a variable literally which is the

00:24:12,860 --> 00:24:18,889
right default unlike in Perl 5 in

00:24:16,039 --> 00:24:22,249
particular back references match

00:24:18,889 --> 00:24:24,220
literally so we don't have to

00:24:22,249 --> 00:24:27,110
distinguish between back references

00:24:24,220 --> 00:24:29,119
inside a regular expression versus

00:24:27,110 --> 00:24:35,419
outside they'll now all use the same

00:24:29,119 --> 00:24:36,679
notation lots of other just very handy

00:24:35,419 --> 00:24:44,539
things that I don't have time to talk

00:24:36,679 --> 00:24:45,860
about today okay but I really like

00:24:44,539 --> 00:24:53,749
talking about some of them you know the

00:24:45,860 --> 00:24:55,429
cool things the you know all these

00:24:53,749 --> 00:24:58,039
languages that lets you add new

00:24:55,429 --> 00:25:00,710
operators they sort of tend to make you

00:24:58,039 --> 00:25:03,200
specify what the precedence level of

00:25:00,710 --> 00:25:04,879
those operators is and for some reason

00:25:03,200 --> 00:25:09,549
those precedents levels are almost

00:25:04,879 --> 00:25:13,460
always numbers and to me that that's a

00:25:09,549 --> 00:25:17,029
kind of magical constant that you

00:25:13,460 --> 00:25:18,289
shouldn't be talking about so if you go

00:25:17,029 --> 00:25:22,850
back and look at the standard grammar

00:25:18,289 --> 00:25:27,679
here where we define our operator

00:25:22,850 --> 00:25:28,800
precedence table somewhere here did I go

00:25:27,679 --> 00:25:32,190
by it

00:25:28,800 --> 00:25:36,870
I almost have gone past it it's so short

00:25:32,190 --> 00:25:39,150
these days yeah there it is okay you

00:25:36,870 --> 00:25:44,580
notice our precedence levels are

00:25:39,150 --> 00:25:46,710
actually specified with strings here and

00:25:44,580 --> 00:25:49,920
they just happen to end with equals

00:25:46,710 --> 00:25:52,080
because that makes it very easy to add a

00:25:49,920 --> 00:25:53,460
character replace the equals with a

00:25:52,080 --> 00:25:55,680
different character less than or greater

00:25:53,460 --> 00:25:58,590
than and add more characters on the end

00:25:55,680 --> 00:26:01,110
and so you can go on forever inserting

00:25:58,590 --> 00:26:02,700
new new precedence levels and you don't

00:26:01,110 --> 00:26:04,350
actually specify these you just say I

00:26:02,700 --> 00:26:07,320
want the same thing the same precedence

00:26:04,350 --> 00:26:12,420
as a multiplication or I want it tighter

00:26:07,320 --> 00:26:15,540
than exponentiation or looser than you

00:26:12,420 --> 00:26:19,530
know an and operator or something so

00:26:15,540 --> 00:26:21,390
that's that's one cool thing another

00:26:19,530 --> 00:26:23,820
cool thing that we're doing in the in

00:26:21,390 --> 00:26:26,070
the standard grammar here is recognizing

00:26:23,820 --> 00:26:27,600
when people accidentally there's going

00:26:26,070 --> 00:26:29,910
to be very easy for people especially

00:26:27,600 --> 00:26:31,980
coming from 4:05 culture to use the Perl

00:26:29,910 --> 00:26:40,830
type idiom when it has changed to

00:26:31,980 --> 00:26:43,710
something more irrational so oops we we

00:26:40,830 --> 00:26:45,210
checked check the various you know most

00:26:43,710 --> 00:26:53,970
of the special variables are gone for

00:26:45,210 --> 00:26:56,970
instance but if you say you know if you

00:26:53,970 --> 00:26:59,250
use this variable dollar at and it

00:26:56,970 --> 00:27:02,520
recognized it will say you dollar at

00:26:59,250 --> 00:27:05,070
variable use of dollar at variable as an

00:27:02,520 --> 00:27:07,760
eval error is obsolete please use dollar

00:27:05,070 --> 00:27:07,760
bang instead

00:27:10,930 --> 00:27:19,300
and there's lots of those inventors

00:27:15,070 --> 00:27:23,110
there that's really excuse me it's a

00:27:19,300 --> 00:27:26,340
pretty cool they also see some nice use

00:27:23,110 --> 00:27:26,340
of the switch statements in here

00:27:28,900 --> 00:27:36,860
which are not spelled switch and case

00:27:32,060 --> 00:27:39,800
because that's talking about the

00:27:36,860 --> 00:27:44,020
constructs rather than just using

00:27:39,800 --> 00:27:49,000
natural functional words from English

00:27:44,020 --> 00:27:53,260
one of my Elizabeth whist ik prejudices

00:27:49,000 --> 00:27:53,260
another cool thing is meta operators

00:27:54,070 --> 00:27:59,900
assignment operators and the gated

00:27:56,950 --> 00:28:02,510
operators none of them are built in

00:27:59,900 --> 00:28:09,710
they're all derived from existing infix

00:28:02,510 --> 00:28:12,050
operators as appropriate so and if you

00:28:09,710 --> 00:28:14,300
add a user operator in the appropriate

00:28:12,050 --> 00:28:16,340
class you get this automatically get the

00:28:14,300 --> 00:28:21,980
assignment operators or the negated

00:28:16,340 --> 00:28:26,510
operators they go with that have

00:28:21,980 --> 00:28:28,580
built-in reduction operator take any and

00:28:26,510 --> 00:28:30,950
fix operator including user-defined ones

00:28:28,580 --> 00:28:34,250
and put them inside at the beginning of

00:28:30,950 --> 00:28:38,170
a list and it will apply that operator

00:28:34,250 --> 00:28:41,840
between each of the elements of the list

00:28:38,170 --> 00:28:45,020
hyper operators we have done a lot of

00:28:41,840 --> 00:28:46,550
thinking about various notations to

00:28:45,020 --> 00:28:50,240
support various kinds of parallel

00:28:46,550 --> 00:28:54,530
programming and for you know vector

00:28:50,240 --> 00:28:58,190
processing and parallel lockstep kind of

00:28:54,530 --> 00:29:01,970
processing hyper operators take any any

00:28:58,190 --> 00:29:06,050
existing scalar operator and say apply

00:29:01,970 --> 00:29:09,430
it equally to both sides and it can do

00:29:06,050 --> 00:29:13,960
that and there's various ways of

00:29:09,430 --> 00:29:13,960
expanding out one side or the other if

00:29:14,650 --> 00:29:19,990
if one of them is lacking in dimensions

00:29:20,730 --> 00:29:26,490
these are all just met operators another

00:29:24,390 --> 00:29:29,160
cool thing is the use of what we call

00:29:26,490 --> 00:29:31,320
rolls some of you perhaps have heard of

00:29:29,160 --> 00:29:36,950
small talk traits we've incorporated

00:29:31,320 --> 00:29:44,630
that idea into purl with some with some

00:29:36,950 --> 00:29:47,520
extensions and christened them rolls so

00:29:44,630 --> 00:30:03,799
we also use that concept within the

00:29:47,520 --> 00:30:03,799
grammar where's a good example okay yeah

00:30:04,549 --> 00:30:15,480
for example when we when we derived our

00:30:09,840 --> 00:30:19,710
quoting languages different quoting

00:30:15,480 --> 00:30:22,500
languages have different sets of back

00:30:19,710 --> 00:30:27,630
slashes for instance and here are here

00:30:22,500 --> 00:30:30,080
are the the backslash sequences for for

00:30:27,630 --> 00:30:30,080
double quotes

00:30:32,230 --> 00:30:37,930
and there you can even define roles that

00:30:34,990 --> 00:30:42,520
will take them back out again simply by

00:30:37,930 --> 00:30:46,990
defining a role a rule with them that

00:30:42,520 --> 00:30:52,030
gets mixed in to your grammar that just

00:30:46,990 --> 00:30:54,760
has a failure and that hides the the

00:30:52,030 --> 00:30:57,400
original thing so you can you can just

00:30:54,760 --> 00:30:59,740
pull in these things as you will as your

00:30:57,400 --> 00:31:02,430
as you're defining new languages with

00:30:59,740 --> 00:31:05,710
different various sets of features

00:31:02,430 --> 00:31:10,330
here's here's your basic cue role which

00:31:05,710 --> 00:31:12,910
defines the essence of single quote and

00:31:10,330 --> 00:31:16,740
none of this is none of this is

00:31:12,910 --> 00:31:16,740
hardwired into your compiler anymore

00:31:20,960 --> 00:31:29,890
okay ratchet and six space usually this

00:31:27,020 --> 00:31:36,680
shows up as as the difference between

00:31:29,890 --> 00:31:39,160
most okay if you if you write a normal

00:31:36,680 --> 00:31:41,570
regular expression we see this as a

00:31:39,160 --> 00:31:44,030
regular expression here then then it has

00:31:41,570 --> 00:31:45,560
semantics more or less that you expect

00:31:44,030 --> 00:31:49,250
this does the star here does

00:31:45,560 --> 00:31:51,800
backtracking it's greedy it's gonna

00:31:49,250 --> 00:31:54,170
match as many posts as as it can and

00:31:51,800 --> 00:32:04,460
tried further and if they can't then it

00:31:54,170 --> 00:32:10,280
backs off if you instead are looking for

00:32:04,460 --> 00:32:12,680
a token then it turns on what we call

00:32:10,280 --> 00:32:17,570
ratchet mode I don't see a good example

00:32:12,680 --> 00:32:21,830
off hand here but in that case well

00:32:17,570 --> 00:32:28,340
here's one okay we're looking for a some

00:32:21,830 --> 00:32:31,430
number of traits to parse and in this

00:32:28,340 --> 00:32:33,500
case it parses them all but if this

00:32:31,430 --> 00:32:37,340
fails it's not going to backtrack and

00:32:33,500 --> 00:32:39,140
try shorter ones that's what we call

00:32:37,340 --> 00:32:41,600
ratchet sometimes it's called possessive

00:32:39,140 --> 00:32:48,140
quantifiers and that's that's the

00:32:41,600 --> 00:32:52,100
default within tokens rules are what's a

00:32:48,140 --> 00:32:54,290
good example here the rules are just

00:32:52,100 --> 00:32:57,440
like tokens except that anywhere there's

00:32:54,290 --> 00:32:59,990
white space in here it also allows white

00:32:57,440 --> 00:33:02,600
space within what is matching so it's

00:32:59,990 --> 00:33:07,730
good for matching things at a higher

00:33:02,600 --> 00:33:10,010
abstraction level so up here you're

00:33:07,730 --> 00:33:12,860
getting more into sort of the the Yak

00:33:10,010 --> 00:33:16,300
frame of mind and assuming that a lexer

00:33:12,860 --> 00:33:20,290
has already dealt with the white space

00:33:16,300 --> 00:33:20,290
are we doing on time here

00:33:20,519 --> 00:33:32,249
okay I'll go about five more minutes

00:33:24,479 --> 00:33:34,349
here and then we can have questions but

00:33:32,249 --> 00:33:37,320
the the really cool thing that's going

00:33:34,349 --> 00:33:40,649
on here is that for so long there has

00:33:37,320 --> 00:33:44,309
been a this deep divide between the the

00:33:40,649 --> 00:33:47,669
people who wanted to do DFA matching in

00:33:44,309 --> 00:33:49,859
this pure computer science sense and the

00:33:47,669 --> 00:33:51,719
sort of a lot of the practical people

00:33:49,859 --> 00:33:52,979
who would like the NSA matching because

00:33:51,719 --> 00:33:55,169
it gives them a great deal of power and

00:33:52,979 --> 00:33:57,329
flexibility but you have to worry about

00:33:55,169 --> 00:34:02,369
the order of things happen because it's

00:33:57,329 --> 00:34:05,389
really a programming language not a it's

00:34:02,369 --> 00:34:09,599
really a more more procedural than it is

00:34:05,389 --> 00:34:14,190
declarative but all we have here is the

00:34:09,599 --> 00:34:17,609
opportunity to mesh these in an almost

00:34:14,190 --> 00:34:20,520
transparent way with the longest token

00:34:17,609 --> 00:34:22,889
match or automatically pulling out

00:34:20,520 --> 00:34:26,909
everything that is makes sense to match

00:34:22,889 --> 00:34:31,950
with a DFA engine and it can run very

00:34:26,909 --> 00:34:35,190
fast and then as it gets to a certain

00:34:31,950 --> 00:34:37,139
point it switches over to the to the NFA

00:34:35,190 --> 00:34:39,260
semantics which can have very parallel

00:34:37,139 --> 00:34:43,169
powerful actions and very powerful

00:34:39,260 --> 00:34:44,700
assertion semantics and most time you

00:34:43,169 --> 00:34:48,929
don't have to worry about it it just

00:34:44,700 --> 00:34:52,319
happens I think that's that integration

00:34:48,929 --> 00:34:55,889
will turn out to be a quite a powerful

00:34:52,319 --> 00:35:01,460
idea and we're still exploring the

00:34:55,889 --> 00:35:04,440
ramifications on it we now just parse

00:35:01,460 --> 00:35:06,180
the whole we swept in the whole program

00:35:04,440 --> 00:35:08,460
we've got lots of memory these days and

00:35:06,180 --> 00:35:10,470
almost never does the program exceed

00:35:08,460 --> 00:35:13,500
your your amount of memory so we don't

00:35:10,470 --> 00:35:16,079
you know pull it in a line at a time and

00:35:13,500 --> 00:35:17,670
then count the line and somewhere down

00:35:16,079 --> 00:35:19,170
in some rule or other we have to

00:35:17,670 --> 00:35:22,500
increment the line counter and if it

00:35:19,170 --> 00:35:24,779
gets off it's off you know we just we

00:35:22,500 --> 00:35:26,490
know where our position is in the buffer

00:35:24,779 --> 00:35:27,539
and if we get an error or something we

00:35:26,490 --> 00:35:30,829
just count the number of new lines

00:35:27,539 --> 00:35:30,829
before it and we know our line number

00:35:32,940 --> 00:35:44,460
we don't even we don't even really parse

00:35:36,140 --> 00:35:46,950
ternary operators here the the rule for

00:35:44,460 --> 00:35:50,640
parsing the the ternary operator just

00:35:46,950 --> 00:35:52,349
treats some treats that as a real fat in

00:35:50,640 --> 00:35:56,099
fix operator that happens to have an

00:35:52,349 --> 00:36:01,710
expression embedded in the middle and

00:35:56,099 --> 00:36:03,720
it's a this this is calling into the the

00:36:01,710 --> 00:36:06,450
rule that is the that happens to be the

00:36:03,720 --> 00:36:08,099
operator precedence parser and as as

00:36:06,450 --> 00:36:09,990
with any rule since they're all just

00:36:08,099 --> 00:36:11,849
methods underneath any way they can be

00:36:09,990 --> 00:36:17,490
parameterised and we've parameterised it

00:36:11,849 --> 00:36:19,349
with the the the maximum precedence

00:36:17,490 --> 00:36:20,960
level that's allowed in there and if it

00:36:19,349 --> 00:36:24,390
doesn't get that then we know very

00:36:20,960 --> 00:36:27,059
fairly accurately which mistake they

00:36:24,390 --> 00:36:29,490
made you know they put an assignment

00:36:27,059 --> 00:36:32,579
inside when it where it doesn't make

00:36:29,490 --> 00:36:40,380
sense something like that and a lot of

00:36:32,579 --> 00:36:44,099
this is it is designed to give a very

00:36:40,380 --> 00:36:45,539
useful compiler to the end user to give

00:36:44,099 --> 00:36:47,369
them a message where they don't have to

00:36:45,539 --> 00:36:49,609
scratch their head for for five minutes

00:36:47,369 --> 00:36:52,609
to try to figure out what went wrong

00:36:49,609 --> 00:36:52,609
another

00:36:57,130 --> 00:37:02,320
another notion we have here that has not

00:37:00,700 --> 00:37:05,020
been thoroughly explored yet but is the

00:37:02,320 --> 00:37:07,960
idea of suppose points as you're going

00:37:05,020 --> 00:37:10,830
through and doing a parse oftentimes

00:37:07,960 --> 00:37:14,230
you'll come to a spot where you say well

00:37:10,830 --> 00:37:15,460
the right way to parse it is this but it

00:37:14,230 --> 00:37:17,140
looks like they might have made a

00:37:15,460 --> 00:37:20,020
mistake here I don't know if they did or

00:37:17,140 --> 00:37:23,530
not they might mean this so we will

00:37:20,020 --> 00:37:25,680
suppose that that they knew what they

00:37:23,530 --> 00:37:30,100
were doing but we'll remember this and

00:37:25,680 --> 00:37:33,250
if some somewhere later on we get a

00:37:30,100 --> 00:37:35,590
panic and and start and and we got a

00:37:33,250 --> 00:37:37,750
parse error it's going to come back to

00:37:35,590 --> 00:37:41,170
here to this suppose point and it's

00:37:37,750 --> 00:37:43,540
going to say well what if they had

00:37:41,170 --> 00:37:45,460
written it the other way so we do a

00:37:43,540 --> 00:37:47,470
hypothetical parse at this point going

00:37:45,460 --> 00:37:49,780
forward again and if it gets further

00:37:47,470 --> 00:37:51,280
than we did before we can be almost

00:37:49,780 --> 00:37:52,080
certain that that is the mistake they

00:37:51,280 --> 00:37:54,520
made

00:37:52,080 --> 00:37:56,740
now we don't go as far as a lot of the

00:37:54,520 --> 00:38:00,880
compilers in the 1960s and try to fix it

00:37:56,740 --> 00:38:04,710
for them that would be bad but we can

00:38:00,880 --> 00:38:04,710
give them a very very good error message

00:38:06,120 --> 00:38:12,049
[Music]

00:38:08,599 --> 00:38:17,239
and skip that we're we're all over

00:38:12,049 --> 00:38:21,949
Unicode so we prejudice things in in

00:38:17,239 --> 00:38:25,069
terms of assuming that we don't just

00:38:21,949 --> 00:38:27,109
chop our backslash X's after two

00:38:25,069 --> 00:38:30,079
characters that's sort of a 8-bit

00:38:27,109 --> 00:38:33,589
assumption we're biased towards

00:38:30,079 --> 00:38:36,380
characters so it'll chew up as many x

00:38:33,589 --> 00:38:39,859
digits as you can little little tweaks

00:38:36,380 --> 00:38:41,599
like that but my overall thesis is is

00:38:39,859 --> 00:38:44,329
essentially no computer language has

00:38:41,599 --> 00:38:48,769
ever taken extensibility seriously they

00:38:44,329 --> 00:38:55,929
tend to fort fall into the the fallacy

00:38:48,769 --> 00:38:55,929
of any color as long as this black and

00:38:56,829 --> 00:39:03,679
you know as language did language

00:39:00,739 --> 00:39:05,299
designers as a class of people tend to

00:39:03,679 --> 00:39:09,109
think that they know how it ought to be

00:39:05,299 --> 00:39:12,589
and try to impose the one true syntax on

00:39:09,109 --> 00:39:16,099
on their users whether that's lots of

00:39:12,589 --> 00:39:20,719
lots of silly parentheses or mandatory

00:39:16,099 --> 00:39:25,189
whitespace or various other ways that

00:39:20,719 --> 00:39:29,509
language designers go wrong and I think

00:39:25,189 --> 00:39:32,589
I'm pretty much out of time here yeah

00:39:29,509 --> 00:39:32,589
it's time for questions

00:39:38,510 --> 00:39:47,830
pardon me like that's the usual question

00:39:43,520 --> 00:39:47,830
and the usual answer is Christmas

00:39:48,820 --> 00:39:55,580
we just don't say which one the flip

00:39:53,510 --> 00:39:58,930
side of that is after pearl fix comes

00:39:55,580 --> 00:39:58,930
out every day will seem like Christmas

00:39:59,530 --> 00:40:04,760
but you know seriously we've made an

00:40:03,440 --> 00:40:06,500
awful lot of progress you can see that

00:40:04,760 --> 00:40:10,700
I'm actually running a parser here is

00:40:06,500 --> 00:40:12,080
still pretty buggy but I'm actually what

00:40:10,700 --> 00:40:13,520
I've got here I mean there's other

00:40:12,080 --> 00:40:15,740
people who have written other parsers

00:40:13,520 --> 00:40:17,450
that are sort of hardwired for standard

00:40:15,740 --> 00:40:19,760
Perl 6 I'm trying to do the parsers

00:40:17,450 --> 00:40:21,530
right according to this polymorphism and

00:40:19,760 --> 00:40:27,020
longest token matching so that's that's

00:40:21,530 --> 00:40:31,310
my field of expertise and so I'm working

00:40:27,020 --> 00:40:32,930
on compiling this using this and it

00:40:31,310 --> 00:40:34,630
actually will compile several hundred

00:40:32,930 --> 00:40:39,280
bytes into this before it blows up now

00:40:34,630 --> 00:40:39,280
and the way I'm doing it actually is

00:40:39,370 --> 00:40:46,880
I've got a cheering gum and baling wire

00:40:42,710 --> 00:40:52,520
program called gimme five which takes

00:40:46,880 --> 00:40:54,620
the standard it's really you don't want

00:40:52,520 --> 00:40:57,980
to do language translation like this but

00:40:54,620 --> 00:41:00,650
for for a one-shot translate this chunk

00:40:57,980 --> 00:41:03,410
of this specific chunk of Perl 6 to this

00:41:00,650 --> 00:41:05,060
specific chunk of Perl 5 it does that

00:41:03,410 --> 00:41:09,190
the only thing it does a real parse on

00:41:05,060 --> 00:41:14,930
is the is the rules and the tokens and

00:41:09,190 --> 00:41:18,620
then so this standard grammar is you

00:41:14,930 --> 00:41:21,860
know one hundred hundred thousand is

00:41:18,620 --> 00:41:23,540
it's a less than four thousand lines and

00:41:21,860 --> 00:41:27,950
that's got a lot of comments in it and

00:41:23,540 --> 00:41:29,810
the this that if you want a idea of the

00:41:27,950 --> 00:41:33,520
sort of power we're adding with the

00:41:29,810 --> 00:41:35,840
notations translating that to Perl 5

00:41:33,520 --> 00:41:44,140
ends up with forty five thousand lines

00:41:35,840 --> 00:41:44,140
of code which ends up looking like

00:41:46,619 --> 00:41:59,860
like this

00:41:49,040 --> 00:42:04,970
so a little teeny rule like this so

00:41:59,860 --> 00:42:09,190
regular expression food ends up turning

00:42:04,970 --> 00:42:09,190
into interesting

00:42:14,750 --> 00:42:22,970
an interesting bit of code there and

00:42:21,410 --> 00:42:26,060
there's other ways to write that but it

00:42:22,970 --> 00:42:30,349
was just a convenient way to do the

00:42:26,060 --> 00:42:32,270
backtracking and it and it's very

00:42:30,349 --> 00:42:35,720
inefficiently written right now right

00:42:32,270 --> 00:42:36,890
now the the notations is assuming all

00:42:35,720 --> 00:42:39,349
over the place that you're doing

00:42:36,890 --> 00:42:42,829
backtracking even though most of these

00:42:39,349 --> 00:42:44,300
things are tokens and are guaranteed not

00:42:42,829 --> 00:42:45,710
to backtrack they're they're quantifiers

00:42:44,300 --> 00:42:50,569
and that could be optimized very easily

00:42:45,710 --> 00:42:54,829
and but for bootstrapping purposes 2,000

00:42:50,569 --> 00:42:57,230
bytes seconds probably enough so we're

00:42:54,829 --> 00:42:59,810
making progress and to get way back to

00:42:57,230 --> 00:43:01,220
the original question I talk like a

00:42:59,810 --> 00:43:02,450
politician you know you give me one

00:43:01,220 --> 00:43:02,869
question oh I'd give you a different

00:43:02,450 --> 00:43:04,430
answer

00:43:02,869 --> 00:43:10,550
that's or the question I want to ask

00:43:04,430 --> 00:43:13,760
answer but it'll get done when it gets

00:43:10,550 --> 00:43:15,819
done but in my my look out is just to

00:43:13,760 --> 00:43:18,800
make sure things continue to converge

00:43:15,819 --> 00:43:21,440
and as long as they're converging is is

00:43:18,800 --> 00:43:23,210
not like a business project where you

00:43:21,440 --> 00:43:25,400
know you have a burn rate and if you

00:43:23,210 --> 00:43:28,550
don't get it by done by date X you're

00:43:25,400 --> 00:43:30,530
just dead meat it's an open source

00:43:28,550 --> 00:43:33,470
project it's all volunteer labor it

00:43:30,530 --> 00:43:34,790
happens when it happens but as long as

00:43:33,470 --> 00:43:38,000
it's converging it will happen

00:43:34,790 --> 00:43:39,900
eventually and then hopefully we'll be

00:43:38,000 --> 00:43:42,730
happy

00:43:39,900 --> 00:43:45,780
you have it

00:43:42,730 --> 00:43:45,780
his characteristics

00:43:48,500 --> 00:43:51,710
correction there

00:43:52,680 --> 00:43:55,859
well right now it'll be a lot slower

00:43:54,660 --> 00:44:01,349
because we haven't got any of the

00:43:55,859 --> 00:44:03,869
engines to to you know run the full

00:44:01,349 --> 00:44:08,299
semantics yet and we're sort of you know

00:44:03,869 --> 00:44:12,859
prototyping it here and bootstrapping

00:44:08,299 --> 00:44:15,569
it is certainly the case that we we bear

00:44:12,859 --> 00:44:18,930
potential performance in mind down the

00:44:15,569 --> 00:44:20,250
road and that's part of the reason you

00:44:18,930 --> 00:44:21,990
know we want to do the longest tolkien

00:44:20,250 --> 00:44:26,569
matcher thing in a DFA because we know

00:44:21,990 --> 00:44:29,730
that's very fast and that will control

00:44:26,569 --> 00:44:32,010
the the parts of the a recursive descent

00:44:29,730 --> 00:44:33,720
parser that would be very slow which is

00:44:32,010 --> 00:44:35,599
you know probe this probe that probe the

00:44:33,720 --> 00:44:37,950
other thing keep keep track tracking

00:44:35,599 --> 00:44:40,980
we're just doing away with that every

00:44:37,950 --> 00:44:44,270
time we recognize a token so we expect

00:44:40,980 --> 00:44:46,950
it to be very fast now that being said

00:44:44,270 --> 00:44:51,900
you know computers are getting faster

00:44:46,950 --> 00:44:55,980
and that's an old argument but a lot of

00:44:51,900 --> 00:44:57,510
the theory for parsing was done sort of

00:44:55,980 --> 00:44:59,190
back in the Dark Ages when people were

00:44:57,510 --> 00:45:03,960
trying to shoehorn parsers into small

00:44:59,190 --> 00:45:07,529
memories and slow CPUs and they tended

00:45:03,960 --> 00:45:11,640
to warp the language in favor of the

00:45:07,529 --> 00:45:13,559
computer rather than the user so just as

00:45:11,640 --> 00:45:14,970
a for instance a yak grammar something

00:45:13,559 --> 00:45:20,210
goes wrong it can't tell you much more

00:45:14,970 --> 00:45:22,589
than syntax error you know near here

00:45:20,210 --> 00:45:24,000
with a recursive descent parser you can

00:45:22,589 --> 00:45:25,859
give much better feedback because you

00:45:24,000 --> 00:45:29,369
know what you're looking for and if we

00:45:25,859 --> 00:45:31,529
can make a recursive descent parser with

00:45:29,369 --> 00:45:33,270
that as largely recursive descent least

00:45:31,529 --> 00:45:34,890
for the tokens and high-level stuff and

00:45:33,270 --> 00:45:38,010
sandwich operator precedence and where

00:45:34,890 --> 00:45:40,049
it makes sense then we can give really

00:45:38,010 --> 00:45:41,760
good error messages and get most of the

00:45:40,049 --> 00:45:45,690
performance - and we think that's a good

00:45:41,760 --> 00:45:47,930
a good disruptive technology kind of

00:45:45,690 --> 00:45:47,930
trade-off

00:45:53,030 --> 00:45:56,790
we're already a second really free

00:45:55,220 --> 00:45:58,260
language

00:45:56,790 --> 00:46:00,480
why the

00:45:58,260 --> 00:46:03,270
you know drawback to settlement when a

00:46:00,480 --> 00:46:06,240
language is so free that over the years

00:46:03,270 --> 00:46:10,320
as you write this thing you did you get

00:46:06,240 --> 00:46:12,640
a really wide set of being set to know I

00:46:10,320 --> 00:46:15,520
understand what's going on

00:46:12,640 --> 00:46:18,610
when Pearl six comes out we have you

00:46:15,520 --> 00:46:20,470
know a way of you know having probably

00:46:18,610 --> 00:46:22,599
Mormonism for everything that

00:46:20,470 --> 00:46:24,130
so what are some of the ways that we can

00:46:22,599 --> 00:46:27,060
kind of

00:46:24,130 --> 00:46:34,630
you know stop it from being like wild

00:46:27,060 --> 00:46:38,050
yeah that's that's a fair question and I

00:46:34,630 --> 00:46:40,920
think that by and large it comes down to

00:46:38,050 --> 00:46:45,970
a cultural question now at that point

00:46:40,920 --> 00:46:48,850
and we've already seen what was Pearl

00:46:45,970 --> 00:46:52,510
five that the culture tends to enforce

00:46:48,850 --> 00:46:54,100
use of of the strict pragma and the the

00:46:52,510 --> 00:46:55,720
warnings Pregnant's so much so we're

00:46:54,100 --> 00:46:57,520
doing that we made that default in Pearl

00:46:55,720 --> 00:46:59,020
sakes

00:46:57,520 --> 00:47:05,680
and they'll come up with other things

00:46:59,020 --> 00:47:07,590
like that another take on it is on the

00:47:05,680 --> 00:47:09,790
one hand we we try to provide maximum

00:47:07,590 --> 00:47:15,910
flexibility but on the other hand we

00:47:09,790 --> 00:47:19,360
also try to provide you with a better

00:47:15,910 --> 00:47:22,150
idea of what you should do by default we

00:47:19,360 --> 00:47:24,550
discovered this with Pearl five object

00:47:22,150 --> 00:47:28,360
system which is exceedingly orthogonal

00:47:24,550 --> 00:47:30,820
and in fact two orthogonal in the sense

00:47:28,360 --> 00:47:31,410
that it gives you no obvious way to do

00:47:30,820 --> 00:47:38,830
it

00:47:31,410 --> 00:47:40,510
so the Pearl six object system is you

00:47:38,830 --> 00:47:42,820
mean you can do whatever you want with

00:47:40,510 --> 00:47:48,810
it underneath just as with Pearl five

00:47:42,820 --> 00:47:50,770
but on the top of it here it's it's got

00:47:48,810 --> 00:47:52,900
you know there's a standard way of

00:47:50,770 --> 00:47:55,180
declaring attributes a standard way of

00:47:52,900 --> 00:47:58,960
declaring methods and so on and so forth

00:47:55,180 --> 00:48:00,970
and if there are are fairly decent ways

00:47:58,960 --> 00:48:03,820
built in to do most of what you want

00:48:00,970 --> 00:48:07,870
already then the temptation to roll your

00:48:03,820 --> 00:48:13,840
own becomes less so that is sort of you

00:48:07,870 --> 00:48:16,710
know one of those oddly ironic things

00:48:13,840 --> 00:48:19,600
that that a language that is providing

00:48:16,710 --> 00:48:21,100
more flexibility would also try to

00:48:19,600 --> 00:48:25,230
prevent you from using that by giving

00:48:21,100 --> 00:48:25,230
you a way to do it already but

00:48:27,260 --> 00:48:32,720
by putting those sort making those sort

00:48:30,320 --> 00:48:35,060
of good default decisions in the base

00:48:32,720 --> 00:48:39,320
language it takes a lot of pressure off

00:48:35,060 --> 00:48:41,840
of the mean to roll your own and and I

00:48:39,320 --> 00:48:46,820
think overall for most tasks actually

00:48:41,840 --> 00:48:50,140
reduces the learning problem but other

00:48:46,820 --> 00:48:52,250
things we're doing is is actually

00:48:50,140 --> 00:48:55,160
rethinking also the the way the

00:48:52,250 --> 00:48:58,340
documentation interacts with with the

00:48:55,160 --> 00:49:02,450
syntax so that we can intermix almost in

00:48:58,340 --> 00:49:04,730
a literate programming style the the

00:49:02,450 --> 00:49:08,330
documentation such that it's active

00:49:04,730 --> 00:49:11,450
accessible so that if you if you derive

00:49:08,330 --> 00:49:13,520
a grammar you know everything is

00:49:11,450 --> 00:49:15,410
first-class objects in there you can go

00:49:13,520 --> 00:49:18,080
in there and ask the object what do you

00:49:15,410 --> 00:49:19,670
know about yourself you know in ways

00:49:18,080 --> 00:49:23,240
that other languages have explored even

00:49:19,670 --> 00:49:27,410
more than Perl has you know we steal

00:49:23,240 --> 00:49:29,030
good ideas wherever we can find them so

00:49:27,410 --> 00:49:31,940
you know there's no simple answer to

00:49:29,030 --> 00:49:34,330
that problem but yeah we have thought

00:49:31,940 --> 00:49:34,330
about it

00:49:38,589 --> 00:49:50,349
so talk to mostly about the personal

00:49:43,210 --> 00:49:53,809
talk about running of it like mm-hmm

00:49:50,349 --> 00:49:55,579
yeah I can talk about it most most of

00:49:53,809 --> 00:49:58,400
these bullet items that are you know

00:49:55,579 --> 00:50:01,039
what one one liner you know each talking

00:49:58,400 --> 00:50:04,219
themselves and people talk about their

00:50:01,039 --> 00:50:06,799
various VMs and such and parrot is is

00:50:04,219 --> 00:50:12,519
one of the VMS it's perhaps going to be

00:50:06,799 --> 00:50:19,609
the name vm but Perl 6 was a language is

00:50:12,519 --> 00:50:24,519
VM agnostic probably the the parrot VM

00:50:19,609 --> 00:50:28,069
has the longest running effort but their

00:50:24,519 --> 00:50:31,640
mandate is not just to make a VM for for

00:50:28,069 --> 00:50:39,910
a Perl 6 but a VM for that will be good

00:50:31,640 --> 00:50:42,079
for most any dynamic language and I

00:50:39,910 --> 00:50:44,390
actually have had very little to do with

00:50:42,079 --> 00:50:47,029
the parrot VM at the beginning of the

00:50:44,390 --> 00:50:51,349
Perl 6 effort the community sort of said

00:50:47,029 --> 00:50:53,989
to me well you know we how we know how

00:50:51,349 --> 00:50:56,989
you implement we've seen your Perl 5

00:50:53,989 --> 00:50:59,450
code and it's pretty darn ugly so you

00:50:56,989 --> 00:51:03,589
know but we'll do the implementation you

00:50:59,450 --> 00:51:05,119
think about the language some you know

00:51:03,589 --> 00:51:07,489
actually that's very beginning was just

00:51:05,119 --> 00:51:09,769
the community was going to do everything

00:51:07,489 --> 00:51:13,400
you know I was just gonna sit back and

00:51:09,769 --> 00:51:17,049
watch but after a few months of trying

00:51:13,400 --> 00:51:20,150
to do community wide language design and

00:51:17,049 --> 00:51:25,670
you know we asked for RFC's and I

00:51:20,150 --> 00:51:30,670
expected about 20 suggestions got 361

00:51:25,670 --> 00:51:35,569
and they were just all over the map and

00:51:30,670 --> 00:51:37,309
a mutually contradictory had each of

00:51:35,569 --> 00:51:39,589
them had tunnel vision they were gonna

00:51:37,309 --> 00:51:44,329
leave Perl 5 the way it was and fix this

00:51:39,589 --> 00:51:47,059
one thing so of course if we just

00:51:44,329 --> 00:51:49,880
implemented malls as suggested it'll be

00:51:47,059 --> 00:51:52,009
in a complete hodgepodge so we had to

00:51:49,880 --> 00:51:54,170
sit back and and the community came back

00:51:52,009 --> 00:51:58,009
to me sort of hat in hand and said we

00:51:54,170 --> 00:51:59,390
need a language designers so I've mostly

00:51:58,009 --> 00:52:01,280
been concentrating on the language

00:51:59,390 --> 00:52:02,840
design it's only just recently that I

00:52:01,280 --> 00:52:05,210
I've gotten back into implementing just

00:52:02,840 --> 00:52:08,890
this part of it so I've kind of stayed

00:52:05,210 --> 00:52:08,890
away from the implementation end of it

00:52:14,020 --> 00:52:25,600
it's Memorex Audrey Tang who was working

00:52:21,010 --> 00:52:35,080
so rapidly on on pugs and and

00:52:25,600 --> 00:52:35,080
demonstrated how to how to get people to

00:52:35,440 --> 00:52:43,160
really get going on IRC and just sort of

00:52:39,650 --> 00:52:47,150
do 24/7 programming and pugs is the

00:52:43,160 --> 00:52:50,540
result of that and it's to this day as a

00:52:47,150 --> 00:52:52,430
semantic prototype of Perl 6 is the most

00:52:50,540 --> 00:52:55,840
advanced and it's starting to show

00:52:52,430 --> 00:53:02,810
Audrey came down with severe hepatitis

00:52:55,840 --> 00:53:07,690
and to the extent that it was basically

00:53:02,810 --> 00:53:10,610
life-threatening and her doctors I mean

00:53:07,690 --> 00:53:14,420
she has some other things

00:53:10,610 --> 00:53:17,660
attention-deficit kind of problems and

00:53:14,420 --> 00:53:21,770
was you know on stimulants and she had

00:53:17,660 --> 00:53:24,290
to stop taking those stimulants so she

00:53:21,770 --> 00:53:29,630
still works in the background but she

00:53:24,290 --> 00:53:33,610
wants to keep a low key and and you know

00:53:29,630 --> 00:53:35,960
we all unfortunately as we get get older

00:53:33,610 --> 00:53:39,410
run into times when we have to learn to

00:53:35,960 --> 00:53:41,590
pace ourselves and you know she hit a

00:53:39,410 --> 00:53:45,650
brick wall that was solid and most of us

00:53:41,590 --> 00:53:53,380
I've had a few of those myself but it's

00:53:45,650 --> 00:53:53,380
never never entirely happy making but

00:53:54,010 --> 00:54:00,309
and she's she's doing doing okay

00:54:05,480 --> 00:54:10,110
I will be looking at ability with

00:54:07,700 --> 00:54:14,010
prototype modules for a second

00:54:10,110 --> 00:54:21,390
okay now we got several stories on the

00:54:14,010 --> 00:54:23,730
on that one of them one of them is is

00:54:21,390 --> 00:54:28,470
simply that we will would be doing

00:54:23,730 --> 00:54:30,840
certain amount of pro/5 emulation worst

00:54:28,470 --> 00:54:35,970
case running a Perl 5 interpreter in the

00:54:30,840 --> 00:54:37,470
same process best case on that is shared

00:54:35,970 --> 00:54:47,310
run loops so you don't run into the

00:54:37,470 --> 00:54:52,350
problems of stack full run loops and the

00:54:47,310 --> 00:54:54,900
other the other leg of that is that we

00:54:52,350 --> 00:54:57,510
already have in prototype Perl 5 - Perl

00:54:54,900 --> 00:55:01,860
6 translator it was done a couple years

00:54:57,510 --> 00:55:03,990
ago for google Summer of Code and it's

00:55:01,860 --> 00:55:09,890
probably had a little seam a little

00:55:03,990 --> 00:55:13,050
design rot since then but in principle

00:55:09,890 --> 00:55:17,540
most most Perl 5 code can be translated

00:55:13,050 --> 00:55:23,220
Beryl 6 that doesn't help with the the

00:55:17,540 --> 00:55:27,090
XS modules that interface directly to C

00:55:23,220 --> 00:55:28,800
or C++ code but that would be something

00:55:27,090 --> 00:55:33,630
that you would probably use emulation

00:55:28,800 --> 00:55:35,460
for and you know the translator is also

00:55:33,630 --> 00:55:37,350
going to be good for for educational

00:55:35,460 --> 00:55:41,760
purposes even if it doesn't get you

00:55:37,350 --> 00:55:43,590
actually get used for migration I found

00:55:41,760 --> 00:55:46,410
this to be the case with the octal

00:55:43,590 --> 00:55:47,730
translator and said to Perl when I first

00:55:46,410 --> 00:55:50,130
came out with purl 1

00:55:47,730 --> 00:55:51,950
I didn't I I delayed the release a month

00:55:50,130 --> 00:55:53,580
or so while I wrote those translators

00:55:51,950 --> 00:55:56,100
because I thought it would be better

00:55:53,580 --> 00:55:58,440
accepted and you know people did use

00:55:56,100 --> 00:56:00,420
them a little bit for actual migration

00:55:58,440 --> 00:56:01,650
but by and large they would just type in

00:56:00,420 --> 00:56:04,170
something they were familiar with and

00:56:01,650 --> 00:56:05,640
see how it came out it's probably

00:56:04,170 --> 00:56:07,860
what'll happen with this translator -

00:56:05,640 --> 00:56:11,880
but it gives people warm fuzzies to have

00:56:07,860 --> 00:56:14,130
it there but usually what we find is

00:56:11,880 --> 00:56:16,170
people get excited enough about the new

00:56:14,130 --> 00:56:18,220
new features and syntax that they they

00:56:16,170 --> 00:56:20,380
really want to rewrite it and

00:56:18,220 --> 00:56:24,160
and take it as an excuse to refactor

00:56:20,380 --> 00:56:26,230
everything you know and when this much

00:56:24,160 --> 00:56:29,980
code turns into this much code that's

00:56:26,230 --> 00:56:31,600
more readable that they'd like that if

00:56:29,980 --> 00:56:34,900
you run a translator it comes out

00:56:31,600 --> 00:56:37,590
usually a little bigger and usually a

00:56:34,900 --> 00:56:37,590
little less readable

00:56:42,000 --> 00:56:48,220
whatever you liked in this life

00:56:44,470 --> 00:56:50,610
that's good question I was I was

00:56:48,220 --> 00:56:52,930
actually the mentor for this translator

00:56:50,610 --> 00:56:57,280
what I discovered was I am NOT a good

00:56:52,930 --> 00:56:59,290
metric so I am not mentoring this year

00:56:57,280 --> 00:57:05,290
but that's that's my problem not not

00:56:59,290 --> 00:57:08,410
summer of codes problem I I am somewhere

00:57:05,290 --> 00:57:12,610
on the autistic spectrum I think and I

00:57:08,410 --> 00:57:16,330
don't do certain social interactions

00:57:12,610 --> 00:57:19,540
like initiation that is crucial to being

00:57:16,330 --> 00:57:21,640
a good manager the only reason I and

00:57:19,540 --> 00:57:24,940
manage to run the this open source

00:57:21,640 --> 00:57:26,710
project is that I I have learned to

00:57:24,940 --> 00:57:29,070
delegate even the delegation to other

00:57:26,710 --> 00:57:29,070
people

00:57:42,280 --> 00:57:45,699

YouTube URL: https://www.youtube.com/watch?v=JzIWdJVP-wo


