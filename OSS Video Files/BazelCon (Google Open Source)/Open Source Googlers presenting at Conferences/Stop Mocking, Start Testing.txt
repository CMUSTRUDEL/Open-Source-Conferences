Title: Stop Mocking, Start Testing
Publication date: 2013-03-14
Playlist: Open Source Googlers presenting at Conferences
Description: 
	Augie Fackler, Nathaniel Manista
Project Hosting at Google Code is a large, well-established system written mostly in Python. We'll share our battle-born convictions about creating tests for test-unfriendly code and the larger topic of testing.
Captions: 
	00:00:00,030 --> 00:00:05,040
please welcome for the first session

00:00:02,909 --> 00:00:12,630
stop mocking start testing Auggie

00:00:05,040 --> 00:00:15,089
Fackler and Nathaniel manista hi thank

00:00:12,630 --> 00:00:17,490
you good morning this is my friend

00:00:15,089 --> 00:00:19,770
Auggie he's a contributor to mercurial

00:00:17,490 --> 00:00:21,359
and a few other Python libraries this is

00:00:19,770 --> 00:00:23,640
my friend Nathaniel he's a contributor

00:00:21,359 --> 00:00:24,930
of pilant and we both work on this

00:00:23,640 --> 00:00:26,939
little website you might have heard of a

00:00:24,930 --> 00:00:30,359
project hosting on Google code who's

00:00:26,939 --> 00:00:33,570
heard of it good who's a user good

00:00:30,359 --> 00:00:35,910
alright we're happy to have you so

00:00:33,570 --> 00:00:38,309
project hosting has been around serving

00:00:35,910 --> 00:00:40,290
bits since July of 2006 so it's about

00:00:38,309 --> 00:00:42,469
five and a half years old plus probably

00:00:40,290 --> 00:00:45,210
nine months of development before that

00:00:42,469 --> 00:00:47,460
it's got all the things you'd expect in

00:00:45,210 --> 00:00:49,530
a project hosting website and we've got

00:00:47,460 --> 00:00:52,199
about 50 engineers in the product at

00:00:49,530 --> 00:00:55,530
this point and the medium the median

00:00:52,199 --> 00:00:58,829
engineer service tenure on the project

00:00:55,530 --> 00:01:00,510
is just about two years so it's a it's a

00:00:58,829 --> 00:01:03,059
project that people rotate on to and

00:01:00,510 --> 00:01:04,769
rotate off of which is not unusual for

00:01:03,059 --> 00:01:07,320
Google but it might be unusual for other

00:01:04,769 --> 00:01:08,790
teams we have a lot of components we

00:01:07,320 --> 00:01:10,470
offer all three of these version control

00:01:08,790 --> 00:01:12,060
systems we have an issue tracker we have

00:01:10,470 --> 00:01:14,340
a download service for your tarballs

00:01:12,060 --> 00:01:15,990
we have a wiki we have offline batch

00:01:14,340 --> 00:01:18,659
processing for stuff we don't want to do

00:01:15,990 --> 00:01:21,560
during request/response

00:01:18,659 --> 00:01:25,350
we started it off with a few languages

00:01:21,560 --> 00:01:28,229
we added a few more we're currently at

00:01:25,350 --> 00:01:30,570
at least eight languages that the site

00:01:28,229 --> 00:01:32,579
is actually written in you know people

00:01:30,570 --> 00:01:34,740
host all kinds of languages with us but

00:01:32,579 --> 00:01:39,210
we've actually got eight languages in

00:01:34,740 --> 00:01:40,950
the implementation of the site we've got

00:01:39,210 --> 00:01:43,290
a lot of servers and processes and

00:01:40,950 --> 00:01:46,259
requests come in through the box at the

00:01:43,290 --> 00:01:47,399
top of the chart which is the public

00:01:46,259 --> 00:01:49,049
series of tubes and they go to various

00:01:47,399 --> 00:01:50,820
front ends that we have either you know

00:01:49,049 --> 00:01:54,090
the mercurial front end the the actual

00:01:50,820 --> 00:01:55,829
issue tracker front end etc and then

00:01:54,090 --> 00:01:57,960
these other ovals that you see further

00:01:55,829 --> 00:01:59,340
down are different components and those

00:01:57,960 --> 00:02:02,070
might be libraries linked into a

00:01:59,340 --> 00:02:04,680
front-end or they may be some other RPC

00:02:02,070 --> 00:02:06,659
service that we talk to and then at the

00:02:04,680 --> 00:02:08,580
bottom you see the triangles and those

00:02:06,659 --> 00:02:10,800
would be the persistence services that

00:02:08,580 --> 00:02:12,480
actually store the data this is not

00:02:10,800 --> 00:02:13,260
actually what project hosting looks like

00:02:12,480 --> 00:02:14,970
this is just

00:02:13,260 --> 00:02:16,140
a dummy diagram so we can all be on the

00:02:14,970 --> 00:02:19,739
same page about what the architecture

00:02:16,140 --> 00:02:22,650
looks like so we posit that your service

00:02:19,739 --> 00:02:25,530
or any other modern scalable web service

00:02:22,650 --> 00:02:28,489
looks like this where these ovens are

00:02:25,530 --> 00:02:31,440
stateless on a per request basis and

00:02:28,489 --> 00:02:33,390
request state is managed in little

00:02:31,440 --> 00:02:35,940
message types that are sent along the

00:02:33,390 --> 00:02:38,250
edges and responses are returned along

00:02:35,940 --> 00:02:41,400
the it along you know the same or

00:02:38,250 --> 00:02:44,609
different paths and that user data is

00:02:41,400 --> 00:02:49,140
stored persistently in things like disks

00:02:44,609 --> 00:02:51,060
or databases at the very bottom and so

00:02:49,140 --> 00:02:52,709
now you've got a high-level idea of what

00:02:51,060 --> 00:02:54,269
project hosting looks like architectural

00:02:52,709 --> 00:02:56,340
II will go through the evolution of the

00:02:54,269 --> 00:02:58,639
testing practices as the team went

00:02:56,340 --> 00:03:00,690
through you know different people and

00:02:58,639 --> 00:03:02,129
talked about how we've converged on

00:03:00,690 --> 00:03:03,329
something for testing this kind of a

00:03:02,129 --> 00:03:09,000
system that we find to be very

00:03:03,329 --> 00:03:11,250
compelling so we launched in 2006 and we

00:03:09,000 --> 00:03:14,159
didn't really have a whole lot of tests

00:03:11,250 --> 00:03:17,430
we had inherited a test suite from the

00:03:14,159 --> 00:03:18,840
subversion source control system and we

00:03:17,430 --> 00:03:20,849
were able to run that against our

00:03:18,840 --> 00:03:22,560
implementation of subversion but we

00:03:20,849 --> 00:03:27,359
didn't really have any other test

00:03:22,560 --> 00:03:31,919
coverage and what we did we had was it

00:03:27,359 --> 00:03:33,030
had to be run manually and on top of

00:03:31,919 --> 00:03:34,620
that you had to run it against a

00:03:33,030 --> 00:03:36,720
pre-configured development of Aramis you

00:03:34,620 --> 00:03:38,970
had to put certain take downloads into a

00:03:36,720 --> 00:03:41,489
project with a certain name and then

00:03:38,970 --> 00:03:43,290
you'd run it and you'd have to manually

00:03:41,489 --> 00:03:44,790
inspect the output of the script so it

00:03:43,290 --> 00:03:47,069
would print you know the next line

00:03:44,790 --> 00:03:48,299
should say foo and then it would print

00:03:47,069 --> 00:03:49,650
what it got from the server and you'd

00:03:48,299 --> 00:03:53,840
have to verify that that was actually

00:03:49,650 --> 00:03:57,840
foo and so this would take all afternoon

00:03:53,840 --> 00:04:01,230
at least and so things got kind of laxed

00:03:57,840 --> 00:04:04,440
it didn't it didn't always get done so

00:04:01,230 --> 00:04:07,049
we were on a weekly release cycle and

00:04:04,440 --> 00:04:09,419
we'd have regressions more often than

00:04:07,049 --> 00:04:11,849
not and our users would helpfully tell

00:04:09,419 --> 00:04:13,919
us what those regressions were on our

00:04:11,849 --> 00:04:15,419
mailing list which is a it's a very

00:04:13,919 --> 00:04:17,789
effective way to find bugs but it's also

00:04:15,419 --> 00:04:20,190
a very stressful way to find bugs so

00:04:17,789 --> 00:04:23,969
some simple lessons from this you know

00:04:20,190 --> 00:04:25,900
Paleolithic time period your users are

00:04:23,969 --> 00:04:28,850
not a test in for

00:04:25,900 --> 00:04:30,560
if you've given yourself a pat on the

00:04:28,850 --> 00:04:33,050
back because you've written you've

00:04:30,560 --> 00:04:35,960
coated a test but running that test

00:04:33,050 --> 00:04:38,660
takes more of your time than processor

00:04:35,960 --> 00:04:41,990
time you don't get credit that's that's

00:04:38,660 --> 00:04:45,110
not a real test and a growing project

00:04:41,990 --> 00:04:46,940
just simply can't go on like this when

00:04:45,110 --> 00:04:49,100
you're in that early growth stage of

00:04:46,940 --> 00:04:53,360
your project you're probably adding

00:04:49,100 --> 00:04:56,810
features proportional to the time the

00:04:53,360 --> 00:05:00,070
total time of development on the project

00:04:56,810 --> 00:05:02,180
your feature surface area grows linearly

00:05:00,070 --> 00:05:04,790
because you're not being burdened with

00:05:02,180 --> 00:05:07,190
maintenance or those sorts of things and

00:05:04,790 --> 00:05:10,130
if you're on a regular release cycle

00:05:07,190 --> 00:05:12,860
like weekly and you want to test your

00:05:10,130 --> 00:05:14,900
entire feature surface area with every

00:05:12,860 --> 00:05:18,950
release how much time are you gonna

00:05:14,900 --> 00:05:24,770
spend testing in aggregate this is

00:05:18,950 --> 00:05:28,670
interactive sorry I'm hearing quadratic

00:05:24,770 --> 00:05:30,050
right well we weren't quadratic we don't

00:05:28,670 --> 00:05:34,670
have quadratic people working on the

00:05:30,050 --> 00:05:38,900
team right so things just just came to

00:05:34,670 --> 00:05:40,940
stop we got we got overwhelmed so in

00:05:38,900 --> 00:05:42,650
about 2009 pretty much all of the

00:05:40,940 --> 00:05:44,419
original team members had rolled off on

00:05:42,650 --> 00:05:46,910
the new projects and a second wave of

00:05:44,419 --> 00:05:49,669
engineers really started taking the

00:05:46,910 --> 00:05:51,140
project on and making it their own but

00:05:49,669 --> 00:05:52,850
this meant that almost all of the people

00:05:51,140 --> 00:05:56,360
working on the team had no idea how

00:05:52,850 --> 00:05:57,830
anything actually worked you know there

00:05:56,360 --> 00:05:59,840
are a few components that you know you

00:05:57,830 --> 00:06:02,080
may be touched but fundamentally you

00:05:59,840 --> 00:06:04,940
don't understand the guts of this system

00:06:02,080 --> 00:06:06,230
so they required tests for new code

00:06:04,940 --> 00:06:08,810
because it was the only way to make

00:06:06,230 --> 00:06:10,280
things workable and they required tests

00:06:08,810 --> 00:06:11,960
for any code that they modified so you'd

00:06:10,280 --> 00:06:13,250
go back add tests for anything that

00:06:11,960 --> 00:06:14,720
you're updating you've changed some bit

00:06:13,250 --> 00:06:17,210
of functionality make sure the old stuff

00:06:14,720 --> 00:06:18,500
and the new stuff all work but they

00:06:17,210 --> 00:06:21,380
snatch defeat from the jaws of victory

00:06:18,500 --> 00:06:23,020
and didn't write any new tests for code

00:06:21,380 --> 00:06:24,950
that remained untouched and

00:06:23,020 --> 00:06:26,450
superficially that sounds ok because if

00:06:24,950 --> 00:06:29,750
you're not touching a piece of code it

00:06:26,450 --> 00:06:31,970
can't break but it turns out that those

00:06:29,750 --> 00:06:33,169
core persistence things or the libraries

00:06:31,970 --> 00:06:35,390
immediately above them tend to get

00:06:33,169 --> 00:06:37,669
touched an awful lot you know you're

00:06:35,390 --> 00:06:38,490
gonna add an attribute to the project or

00:06:37,669 --> 00:06:40,440
something enough

00:06:38,490 --> 00:06:43,110
a method signature changes and now

00:06:40,440 --> 00:06:45,990
you're untested bit of say the issue

00:06:43,110 --> 00:06:48,569
tracker or the wiki breaks and you find

00:06:45,990 --> 00:06:50,819
out when you try and deploy because you

00:06:48,569 --> 00:06:54,569
have no tests that exercise that against

00:06:50,819 --> 00:06:56,460
your persistence layer another key

00:06:54,569 --> 00:06:59,099
takeaway from this time period was we

00:06:56,460 --> 00:07:01,229
got our continuous build that's it

00:06:59,099 --> 00:07:04,470
that's it right there it sits on top of

00:07:01,229 --> 00:07:07,130
one of our engineer akyuu Bacall's it's

00:07:04,470 --> 00:07:10,650
green most of the time when it goes red

00:07:07,130 --> 00:07:12,539
almost the whole team knows it turns out

00:07:10,650 --> 00:07:14,639
three engineers on our team had

00:07:12,539 --> 00:07:17,970
red-green color blindness and we had to

00:07:14,639 --> 00:07:20,159
spend a long time finding just the right

00:07:17,970 --> 00:07:21,270
green had to iterate on those red and

00:07:20,159 --> 00:07:24,960
greens quite a bit and that's actually

00:07:21,270 --> 00:07:27,509
white to me which is great so we thought

00:07:24,960 --> 00:07:29,009
you know we thought we were doing really

00:07:27,509 --> 00:07:30,870
well we thought we were on the mend we

00:07:29,009 --> 00:07:33,960
thought we were having really good

00:07:30,870 --> 00:07:35,699
habits and even adding tests was helping

00:07:33,960 --> 00:07:38,580
but these are actually problem tests

00:07:35,699 --> 00:07:39,659
that were writing and at first they

00:07:38,580 --> 00:07:41,759
looked really useful because they were

00:07:39,659 --> 00:07:43,610
they were preventing bugs but everyone

00:07:41,759 --> 00:07:45,810
was making their own mock objects and

00:07:43,610 --> 00:07:48,870
what happens when everyone makes their

00:07:45,810 --> 00:07:50,219
own mock objects is now you have n where

00:07:48,870 --> 00:07:52,259
n is the number of tests you've written

00:07:50,219 --> 00:07:54,180
copy you know stupid little

00:07:52,259 --> 00:07:55,919
implementations of something that you

00:07:54,180 --> 00:07:57,750
have to mock out so when you change that

00:07:55,919 --> 00:08:00,990
things behavior you have to go find all

00:07:57,750 --> 00:08:02,490
of them and this is a trivial little

00:08:00,990 --> 00:08:05,159
example right you have this real object

00:08:02,490 --> 00:08:07,139
on the top that defines you know a

00:08:05,159 --> 00:08:08,819
method that takes one required parameter

00:08:07,139 --> 00:08:11,460
and two optional keyword arguments and

00:08:08,819 --> 00:08:12,930
then one of the mocks it doesn't even

00:08:11,460 --> 00:08:14,219
accept one of them as a keyword argument

00:08:12,930 --> 00:08:16,139
and the other mock doesn't even accept

00:08:14,219 --> 00:08:17,969
the keyword arguments at all and this is

00:08:16,139 --> 00:08:19,530
not going to work because if you swap

00:08:17,969 --> 00:08:22,319
those two mocks around the test would

00:08:19,530 --> 00:08:23,940
both break and if you change the method

00:08:22,319 --> 00:08:25,500
signature of an lolcat

00:08:23,940 --> 00:08:26,940
and then you start using that

00:08:25,500 --> 00:08:29,639
functionality where one of these tests

00:08:26,940 --> 00:08:31,770
is called you're gonna break something

00:08:29,639 --> 00:08:34,020
and you may not notice or if you take

00:08:31,770 --> 00:08:38,520
away words right the user of fake one

00:08:34,020 --> 00:08:40,890
won't ever notice that it's gone but it

00:08:38,520 --> 00:08:43,169
wasn't just having proliferation it

00:08:40,890 --> 00:08:44,760
wasn't just having n mocks of a given

00:08:43,169 --> 00:08:47,970
interface that we're giving us problems

00:08:44,760 --> 00:08:50,220
even when we had one mock the mock would

00:08:47,970 --> 00:08:51,570
tell us what we wanted to hear and it

00:08:50,220 --> 00:08:52,360
would tell us what we wanted to hear

00:08:51,570 --> 00:08:55,839
because we

00:08:52,360 --> 00:08:59,649
that what to tell us it wouldn't

00:08:55,839 --> 00:09:02,380
necessarily tell us anything true to the

00:08:59,649 --> 00:09:07,060
behavior as specified in the interface

00:09:02,380 --> 00:09:09,670
that we were mocking and so we'd run our

00:09:07,060 --> 00:09:12,399
tests only against mock objects and then

00:09:09,670 --> 00:09:14,579
we deploy to continuous integration or

00:09:12,399 --> 00:09:16,959
Quality Assurance and things would break

00:09:14,579 --> 00:09:19,180
because we'd be hitting real objects

00:09:16,959 --> 00:09:21,010
that had changed slightly in ways that

00:09:19,180 --> 00:09:25,060
we weren't able to keep track of and

00:09:21,010 --> 00:09:27,310
keep updating Python doesn't do any

00:09:25,060 --> 00:09:29,290
checking right because it's dynamically

00:09:27,310 --> 00:09:32,140
typed it doesn't do any checking that

00:09:29,290 --> 00:09:36,339
two classes implement the same interface

00:09:32,140 --> 00:09:38,079
and nobody else does either and you can

00:09:36,339 --> 00:09:39,760
say you know we do code review at Google

00:09:38,079 --> 00:09:41,260
you can say that oh well the part of

00:09:39,760 --> 00:09:42,550
your code review processes go check for

00:09:41,260 --> 00:09:45,130
mocks and make sure they get updated

00:09:42,550 --> 00:09:50,640
this doesn't work it we try and work for

00:09:45,130 --> 00:09:53,529
us so the lessons from this time period

00:09:50,640 --> 00:09:55,420
you should share your mocks absolutely

00:09:53,529 --> 00:09:57,940
share your mocks I didn't given some bad

00:09:55,420 --> 00:09:59,709
advice a few years back about how you

00:09:57,940 --> 00:10:02,380
should write separate mocks for every

00:09:59,709 --> 00:10:06,850
test we don't believe that we don't

00:10:02,380 --> 00:10:08,949
subscribe to that we reject that you

00:10:06,850 --> 00:10:11,740
don't even necessarily have to mock

00:10:08,949 --> 00:10:14,769
every interface that's used we believe

00:10:11,740 --> 00:10:17,079
that if an object type is very cheap if

00:10:14,769 --> 00:10:20,199
it's just a stack allocation a few

00:10:17,079 --> 00:10:22,300
storage elements so it's not an event

00:10:20,199 --> 00:10:24,910
the data container a date of any

00:10:22,300 --> 00:10:29,430
behavior you shouldn't be mocking it at

00:10:24,910 --> 00:10:33,910
all you should never mock a tuple or and

00:10:29,430 --> 00:10:36,760
we've seen this and if you need a mock

00:10:33,910 --> 00:10:39,490
you should have exactly one well tested

00:10:36,760 --> 00:10:41,500
mock and by well tested we mean you

00:10:39,490 --> 00:10:44,620
write your tests to the interface of

00:10:41,500 --> 00:10:46,959
what the mock object is mocking and you

00:10:44,620 --> 00:10:49,510
run that test against both the mock

00:10:46,959 --> 00:10:51,519
object and the real implementation and

00:10:49,510 --> 00:10:53,470
confirm that both have the same behavior

00:10:51,519 --> 00:10:55,390
and that's the behavior that's specified

00:10:53,470 --> 00:10:58,630
in the interface and I've actually

00:10:55,390 --> 00:11:00,370
actually found a bug in the BigTable

00:10:58,630 --> 00:11:02,319
library at Google at one point this way

00:11:00,370 --> 00:11:04,000
because the mock had the behavior I

00:11:02,319 --> 00:11:06,310
expected and I found a regression

00:11:04,000 --> 00:11:07,750
because the mock I was using didn't

00:11:06,310 --> 00:11:09,550
have the bug and I was able to go back

00:11:07,750 --> 00:11:13,630
and find a regression that was breaking

00:11:09,550 --> 00:11:15,610
one of our components now another thing

00:11:13,630 --> 00:11:18,070
is that if you if you don't necessarily

00:11:15,610 --> 00:11:19,720
have the resources of time available to

00:11:18,070 --> 00:11:21,730
write this this full test of this

00:11:19,720 --> 00:11:23,860
interface there's a really really cheap

00:11:21,730 --> 00:11:25,870
thing you can do to get a lot of the way

00:11:23,860 --> 00:11:29,589
there which is to use linguistic

00:11:25,870 --> 00:11:31,839
reflection to just very cheaply check

00:11:29,589 --> 00:11:34,540
that the interface of your maka object

00:11:31,839 --> 00:11:36,279
is a superset of the interface of the

00:11:34,540 --> 00:11:38,230
real object being mocked or the

00:11:36,279 --> 00:11:39,670
interface is specified so that's that

00:11:38,230 --> 00:11:42,250
all the the methods have the same

00:11:39,670 --> 00:11:44,410
signature the same parameters yes so you

00:11:42,250 --> 00:11:46,330
use the inspect module in Python and

00:11:44,410 --> 00:11:47,980
you'd loop over all of the public

00:11:46,330 --> 00:11:49,510
attributes that exist on both classes

00:11:47,980 --> 00:11:50,980
and make sure that they take all the

00:11:49,510 --> 00:11:52,210
same arguments in the same order and you

00:11:50,980 --> 00:11:54,550
just check that by looking at the name

00:11:52,210 --> 00:11:55,900
inspect actually isn't that scary we

00:11:54,550 --> 00:11:57,550
have a test that does this and it's

00:11:55,900 --> 00:11:59,380
bailed us out more times than I can

00:11:57,550 --> 00:12:02,529
count at this point yeah

00:11:59,380 --> 00:12:06,430
me personally five times at least

00:12:02,529 --> 00:12:10,630
so about 2010 or so we really felt we

00:12:06,430 --> 00:12:13,240
had unit testing fully fully in hand and

00:12:10,630 --> 00:12:15,670
was going well and our units were

00:12:13,240 --> 00:12:16,930
separate they were isolated and we felt

00:12:15,670 --> 00:12:20,560
like there was still a need for

00:12:16,930 --> 00:12:23,020
something beyond unit testing yeah so to

00:12:20,560 --> 00:12:24,550
expand beyond unit tests that we decided

00:12:23,020 --> 00:12:26,620
to use full system test to make up for

00:12:24,550 --> 00:12:28,660
gaps in the unit level coverage so what

00:12:26,620 --> 00:12:30,040
we mean by this is in particular we were

00:12:28,660 --> 00:12:32,470
using selenium to remote-control a

00:12:30,040 --> 00:12:34,510
browser and click through parts of the

00:12:32,470 --> 00:12:36,610
site that had terrible unit test

00:12:34,510 --> 00:12:38,650
coverage because that was better than

00:12:36,610 --> 00:12:40,780
nothing but these tests were very

00:12:38,650 --> 00:12:42,370
frustrating to work with if you've ever

00:12:40,780 --> 00:12:45,790
used selenium it's a lot slower than he

00:12:42,370 --> 00:12:47,860
tests the Diagnostics are often terrible

00:12:45,790 --> 00:12:49,780
in our case we didn't know selenium very

00:12:47,860 --> 00:12:51,190
well so we also had very flaky tests

00:12:49,780 --> 00:12:53,140
that just had race conditions everywhere

00:12:51,190 --> 00:12:54,850
but even when the tests did fail for a

00:12:53,140 --> 00:12:57,250
reason it would be something like the

00:12:54,850 --> 00:12:58,810
server returned to 500 you know that's

00:12:57,250 --> 00:13:00,370
great the server returned to 500 now you

00:12:58,810 --> 00:13:01,870
get to go look and figure out which of

00:13:00,370 --> 00:13:05,260
the twenty trace backs and the server's

00:13:01,870 --> 00:13:06,910
log is related to your test run versus

00:13:05,260 --> 00:13:10,420
somebody else doing a test or just a

00:13:06,910 --> 00:13:12,910
different test from this run it was very

00:13:10,420 --> 00:13:14,140
frustrating so we rapidly reached the

00:13:12,910 --> 00:13:15,459
conclusion that these full system tests

00:13:14,140 --> 00:13:18,040
just can't be a replacement for the unit

00:13:15,459 --> 00:13:19,930
tests they don't help you deal with

00:13:18,040 --> 00:13:25,630
day-to-day development we

00:13:19,930 --> 00:13:27,820
broke them a lot and just a mess the

00:13:25,630 --> 00:13:31,149
unit tests provide much clearer feedback

00:13:27,820 --> 00:13:33,130
and the other thing we started doing was

00:13:31,149 --> 00:13:34,720
to test the stories with the full system

00:13:33,130 --> 00:13:37,420
test so we didn't this worked much but

00:13:34,720 --> 00:13:40,870
yeah we didn't stop writing the full

00:13:37,420 --> 00:13:42,670
system tests we started testing in agile

00:13:40,870 --> 00:13:44,350
terminology a user story you know a user

00:13:42,670 --> 00:13:46,480
goes to the issue tracker clicks new

00:13:44,350 --> 00:13:48,160
issue makes an issue another user comes

00:13:46,480 --> 00:13:49,600
in triage is the issue the user gets

00:13:48,160 --> 00:13:51,610
emailed that's great

00:13:49,600 --> 00:13:53,709
don't try and check your corner cases we

00:13:51,610 --> 00:13:56,110
were at one point trying to check across

00:13:53,709 --> 00:13:58,480
the cross-site scripting attacks using

00:13:56,110 --> 00:13:59,529
selenium and that gets really slow

00:13:58,480 --> 00:14:00,760
because you're checking all the

00:13:59,529 --> 00:14:02,410
different boxes that you could fill in

00:14:00,760 --> 00:14:03,970
and checking to see where things are

00:14:02,410 --> 00:14:05,529
leaking through and it was just too slow

00:14:03,970 --> 00:14:06,820
and you just won't live long enough if

00:14:05,529 --> 00:14:10,630
you're trying to check all your edge

00:14:06,820 --> 00:14:12,959
cases that way so all this was going on

00:14:10,630 --> 00:14:15,700
and and we were gradually becoming

00:14:12,959 --> 00:14:18,490
converted I had been a heretic I had

00:14:15,700 --> 00:14:20,770
been fully won over our whole team had

00:14:18,490 --> 00:14:22,839
gone through this enlightenment and now

00:14:20,770 --> 00:14:25,779
we've come to the modern era and we

00:14:22,839 --> 00:14:29,560
believe we have the right mocking the

00:14:25,779 --> 00:14:31,750
right testing and the right design so

00:14:29,560 --> 00:14:33,850
let's talk about our modern mocking are

00:14:31,750 --> 00:14:37,660
mocking today we have a collection of

00:14:33,850 --> 00:14:39,640
mocks that is authoritative which means

00:14:37,660 --> 00:14:41,650
there's a known place for all the mocks

00:14:39,640 --> 00:14:43,839
if you need a mock of something you go

00:14:41,650 --> 00:14:45,310
look for it there and if it's there you

00:14:43,839 --> 00:14:47,589
use it you don't write your own in your

00:14:45,310 --> 00:14:49,990
own little one-off test you know way off

00:14:47,589 --> 00:14:51,700
in the corner and if it's not there you

00:14:49,990 --> 00:14:53,230
can fill it in there and we also can

00:14:51,700 --> 00:14:55,000
statically verify that these aren't

00:14:53,230 --> 00:14:56,980
included in our deployed binaries so

00:14:55,000 --> 00:14:58,330
there's no way that when we deploy we're

00:14:56,980 --> 00:14:59,950
going to accidentally be writing to say

00:14:58,330 --> 00:15:02,829
an in-memory data store and catch it

00:14:59,950 --> 00:15:04,589
later our collection is narrow it only

00:15:02,829 --> 00:15:06,339
mocks the things that are actually

00:15:04,589 --> 00:15:08,770
expensive and that we don't actually

00:15:06,339 --> 00:15:11,040
want to have present in the tests so

00:15:08,770 --> 00:15:14,170
things like the network things like

00:15:11,040 --> 00:15:16,870
discs things like partner Google

00:15:14,170 --> 00:15:19,720
services with foreign code bases that we

00:15:16,870 --> 00:15:22,899
reach out to with remote procedure calls

00:15:19,720 --> 00:15:26,470
in production our collection of box is

00:15:22,899 --> 00:15:28,300
isolated there's no code dependency

00:15:26,470 --> 00:15:30,339
between our mocks

00:15:28,300 --> 00:15:33,660
and the things that they're mocking we

00:15:30,339 --> 00:15:35,570
had previously had mock objects in herre

00:15:33,660 --> 00:15:39,060
in an object inheritance relationship

00:15:35,570 --> 00:15:41,700
from the the real implementations that

00:15:39,060 --> 00:15:45,990
they were underlying and this raised all

00:15:41,700 --> 00:15:49,050
kinds of problems with with method call

00:15:45,990 --> 00:15:50,790
backs andrey entrance and a method would

00:15:49,050 --> 00:15:53,370
change slightly and instead of getting a

00:15:50,790 --> 00:15:55,680
not implemented problem we'd go off and

00:15:53,370 --> 00:15:58,230
we'd hit some real method and go reach

00:15:55,680 --> 00:16:00,570
out for a database that didn't exist

00:15:58,230 --> 00:16:02,940
we've come to believe that that things

00:16:00,570 --> 00:16:04,890
are much much simpler and safer and more

00:16:02,940 --> 00:16:06,810
straightforward if you have no code

00:16:04,890 --> 00:16:08,160
dependency between your mocks and the

00:16:06,810 --> 00:16:10,170
real implementations that they're

00:16:08,160 --> 00:16:13,200
mocking so if you're in a compiled

00:16:10,170 --> 00:16:15,540
language you can compile your mock

00:16:13,200 --> 00:16:17,640
package without the real things being

00:16:15,540 --> 00:16:21,060
mocked anywhere in the compile path we

00:16:17,640 --> 00:16:22,980
think that's great and when we say mocks

00:16:21,060 --> 00:16:24,980
we've come to believe very strongly in

00:16:22,980 --> 00:16:27,750
what are technically called fakes

00:16:24,980 --> 00:16:30,300
there's a bunch of different types of

00:16:27,750 --> 00:16:34,680
things out there they're stubs dummies

00:16:30,300 --> 00:16:38,190
mocks fakes and we're missing one on it

00:16:34,680 --> 00:16:41,430
doubles doubles we haven't found that

00:16:38,190 --> 00:16:43,710
that really really tough terminology all

00:16:41,430 --> 00:16:46,020
that helpful but we have settled on what

00:16:43,710 --> 00:16:49,020
what are technically called fakes so

00:16:46,020 --> 00:16:50,910
they even live in a mock stop PI module

00:16:49,020 --> 00:16:53,100
that's how loosely we use the

00:16:50,910 --> 00:16:55,650
terminology it's just not helpful much

00:16:53,100 --> 00:16:58,500
they are full in-memory implementations

00:16:55,650 --> 00:17:01,200
of the interface that they are mocking

00:16:58,500 --> 00:17:02,940
and they're not the kind of mocks that

00:17:01,200 --> 00:17:05,490
can be scripted they're not the kind of

00:17:02,940 --> 00:17:08,130
mocks that you say well assert that this

00:17:05,490 --> 00:17:12,150
other method is called for x and then

00:17:08,130 --> 00:17:14,699
return value Y we still have those types

00:17:12,150 --> 00:17:17,069
of assertions in our tests but they have

00:17:14,699 --> 00:17:21,240
to be extrinsic to our mocks and we're

00:17:17,069 --> 00:17:24,329
better off for it so going back to this

00:17:21,240 --> 00:17:26,310
you know example of a modern scalable

00:17:24,329 --> 00:17:30,060
web service what is it that we're

00:17:26,310 --> 00:17:32,280
mocking it's all those expensive things

00:17:30,060 --> 00:17:34,530
those expensive stores and those remote

00:17:32,280 --> 00:17:36,810
services that are represented at the

00:17:34,530 --> 00:17:40,140
triangles at the bottom we don't have

00:17:36,810 --> 00:17:42,060
mocks of any of our own core business

00:17:40,140 --> 00:17:43,950
logic as represented in the middle of

00:17:42,060 --> 00:17:45,990
the diagram and we don't have mocks of

00:17:43,950 --> 00:17:48,570
any of the message types that represent

00:17:45,990 --> 00:17:51,240
user requests data and user response

00:17:48,570 --> 00:17:54,270
data that are passed along those are

00:17:51,240 --> 00:17:56,460
stateless or they're simple or they're

00:17:54,270 --> 00:18:00,090
otherwise inexpensive and so we don't

00:17:56,460 --> 00:18:02,520
mock them we've changed our testing

00:18:00,090 --> 00:18:04,140
around a little bit you've probably

00:18:02,520 --> 00:18:05,700
heard that you should write your tests

00:18:04,140 --> 00:18:07,560
to an interface and not an

00:18:05,700 --> 00:18:09,360
implementation we said it earlier but

00:18:07,560 --> 00:18:11,580
you've certainly heard it before we

00:18:09,360 --> 00:18:13,740
really really really believe this to the

00:18:11,580 --> 00:18:16,590
point that when we're writing a test

00:18:13,740 --> 00:18:18,660
will often ask ourselves how flexibly

00:18:16,590 --> 00:18:21,720
could the implementation under test

00:18:18,660 --> 00:18:24,090
change without our having to change the

00:18:21,720 --> 00:18:27,240
test that we've just written and we feel

00:18:24,090 --> 00:18:29,370
really good when the answer is zero and

00:18:27,240 --> 00:18:31,560
this has been valuable because like the

00:18:29,370 --> 00:18:33,870
example I mentioned before we had a test

00:18:31,560 --> 00:18:35,460
that was passing against a mock BigTable

00:18:33,870 --> 00:18:37,080
and failing against the real thing and

00:18:35,460 --> 00:18:39,540
we caught a very esoteric feature

00:18:37,080 --> 00:18:40,860
regression because of that and you know

00:18:39,540 --> 00:18:43,050
the upstream team was actually really

00:18:40,860 --> 00:18:45,480
glad for that we found something before

00:18:43,050 --> 00:18:46,920
it got out into the wild that this is

00:18:45,480 --> 00:18:48,900
also valuable when you're doing your

00:18:46,920 --> 00:18:50,370
system tests our system tests actually

00:18:48,900 --> 00:18:53,070
run both in our continuous integration

00:18:50,370 --> 00:18:54,810
environment and against our quality

00:18:53,070 --> 00:18:56,070
assurance instance of project hosting

00:18:54,810 --> 00:18:57,900
that's actually you know standing up

00:18:56,070 --> 00:19:00,030
with everything and it runs week in week

00:18:57,900 --> 00:19:02,550
out and you could use it but we wipe it

00:19:00,030 --> 00:19:04,500
occasionally and that's been very

00:19:02,550 --> 00:19:06,960
valuable because the system tests are

00:19:04,500 --> 00:19:11,280
really slow so nobody runs them when

00:19:06,960 --> 00:19:12,960
they're doing development but on the

00:19:11,280 --> 00:19:14,010
other hand if nobody runs them then when

00:19:12,960 --> 00:19:15,570
you go to do your release you're gonna

00:19:14,010 --> 00:19:17,550
find out oh well we changed how this

00:19:15,570 --> 00:19:19,260
form looks and now the tests can't find

00:19:17,550 --> 00:19:20,960
the form fields and scribble them in and

00:19:19,260 --> 00:19:23,760
actually submit the form anymore

00:19:20,960 --> 00:19:25,260
something along those lines and that got

00:19:23,760 --> 00:19:26,610
really tedious when we're doing releases

00:19:25,260 --> 00:19:29,760
because release management used to

00:19:26,610 --> 00:19:31,800
destroy somebody's week and most of that

00:19:29,760 --> 00:19:33,570
was actually spent just squinting at the

00:19:31,800 --> 00:19:36,630
test output from the system test saying

00:19:33,570 --> 00:19:38,940
well it it looks like the site actually

00:19:36,630 --> 00:19:40,950
works but why is the test broken oh I

00:19:38,940 --> 00:19:43,590
see this needs to change by three

00:19:40,950 --> 00:19:45,630
characters and that was just not

00:19:43,590 --> 00:19:47,700
practical you know practical in long

00:19:45,630 --> 00:19:49,290
term so running your system tests in

00:19:47,700 --> 00:19:51,000
continuous integration against all of

00:19:49,290 --> 00:19:52,650
these in-memory implementations makes

00:19:51,000 --> 00:19:54,900
them run fast enough they can finish in

00:19:52,650 --> 00:19:55,980
continuous integration and you find out

00:19:54,900 --> 00:20:00,210
you broke them in an

00:19:55,980 --> 00:20:03,360
our instead of in five days and so we've

00:20:00,210 --> 00:20:05,460
changed our design around for testing we

00:20:03,360 --> 00:20:08,130
use a framework to inject our object

00:20:05,460 --> 00:20:10,799
dependencies we use another framework to

00:20:08,130 --> 00:20:13,110
create our mock object in our

00:20:10,799 --> 00:20:14,970
Constructors we automatically create our

00:20:13,110 --> 00:20:17,640
dependencies if they're not passed in

00:20:14,970 --> 00:20:20,309
and we twist our code around a little

00:20:17,640 --> 00:20:22,200
bit to make things work no no no that's

00:20:20,309 --> 00:20:23,820
not what we do we stop doing all of

00:20:22,200 --> 00:20:25,260
those things we had done those things

00:20:23,820 --> 00:20:27,510
and we actually believe that they were

00:20:25,260 --> 00:20:30,030
virtuous at the time and we've moved

00:20:27,510 --> 00:20:32,010
past them much much happily we now

00:20:30,030 --> 00:20:35,520
design for code that we can both test

00:20:32,010 --> 00:20:38,070
and love we inject our object

00:20:35,520 --> 00:20:40,169
dependencies as required construction

00:20:38,070 --> 00:20:42,480
parameters so let's take a look at this

00:20:40,169 --> 00:20:44,190
we used to do the top right we used to

00:20:42,480 --> 00:20:46,080
have these you know passing a database

00:20:44,190 --> 00:20:47,940
handle and if you don't pass one in I'll

00:20:46,080 --> 00:20:49,200
construct the you know the one that

00:20:47,940 --> 00:20:50,970
talks to a real database just

00:20:49,200 --> 00:20:52,799
dynamically from a command line flag and

00:20:50,970 --> 00:20:54,150
we thought that was great because it

00:20:52,799 --> 00:20:56,520
meant that all of your production code

00:20:54,150 --> 00:20:58,290
required less code and anytime you need

00:20:56,520 --> 00:21:02,730
to mock it out oh just pass the mock one

00:20:58,290 --> 00:21:05,850
in what happens if you do that uh what

00:21:02,730 --> 00:21:08,190
happens is that you have a production

00:21:05,850 --> 00:21:10,200
binary reaching out and looking for

00:21:08,190 --> 00:21:11,700
someone's developer configuration or you

00:21:10,200 --> 00:21:14,130
have a test reaching out and trying to

00:21:11,700 --> 00:21:16,020
hit something in production if you do

00:21:14,130 --> 00:21:17,700
the bottom where you always passing the

00:21:16,020 --> 00:21:21,179
database explicitly you can't do that

00:21:17,700 --> 00:21:22,860
and it's just been a lot safer and made

00:21:21,179 --> 00:21:23,850
the tests a lot more reliable that

00:21:22,860 --> 00:21:25,530
they're actually using fake

00:21:23,850 --> 00:21:28,440
implementations and if you forget

00:21:25,530 --> 00:21:30,809
something your code crashes either in

00:21:28,440 --> 00:21:34,740
your production or tests things crash

00:21:30,809 --> 00:21:36,450
but they don't behave badly you've also

00:21:34,740 --> 00:21:38,309
heard before probably at some point in

00:21:36,450 --> 00:21:40,110
your life separate your state and

00:21:38,309 --> 00:21:41,610
especially your storage from your

00:21:40,110 --> 00:21:44,730
behavior this turned out to be

00:21:41,610 --> 00:21:46,880
surprisingly easy and I'm gonna walk you

00:21:44,730 --> 00:21:49,500
through why and just an example of that

00:21:46,880 --> 00:21:52,380
this is the way we use to have classes

00:21:49,500 --> 00:21:54,090
and this is the way our class methods

00:21:52,380 --> 00:21:57,059
used to look our instance methods and

00:21:54,090 --> 00:21:58,740
it's you know it starts off there's some

00:21:57,059 --> 00:22:00,690
there's some really good business in the

00:21:58,740 --> 00:22:02,340
middle and then it assigns an attribute

00:22:00,690 --> 00:22:04,409
and doesn't have a return value so

00:22:02,340 --> 00:22:07,380
you've probably written methods that

00:22:04,409 --> 00:22:09,870
look like this and I want to take away

00:22:07,380 --> 00:22:12,750
all that business and let's just look

00:22:09,870 --> 00:22:15,900
at this we see the object itself the

00:22:12,750 --> 00:22:18,690
instance itself has an attribute read

00:22:15,900 --> 00:22:21,210
early in the method and an attribute

00:22:18,690 --> 00:22:24,000
assignment as the last part of the

00:22:21,210 --> 00:22:26,670
method everything else does not test

00:22:24,000 --> 00:22:28,770
does not touch the instance at all and

00:22:26,670 --> 00:22:31,230
so we can pull it out we can take that

00:22:28,770 --> 00:22:33,240
exact same business and put it in a free

00:22:31,230 --> 00:22:36,540
function a pure function that is

00:22:33,240 --> 00:22:38,580
perfectly testable because it's its it

00:22:36,540 --> 00:22:41,270
has no state changes and its return

00:22:38,580 --> 00:22:44,330
value is solely a function of its inputs

00:22:41,270 --> 00:22:48,660
perfectly testable this is very easy and

00:22:44,330 --> 00:22:51,179
then we go back to our class and what's

00:22:48,660 --> 00:22:54,000
left is just that early attribute read

00:22:51,179 --> 00:22:55,800
and that final attribute assignment and

00:22:54,000 --> 00:22:57,360
so when you're when you're thinking this

00:22:55,800 --> 00:22:59,490
way when you're starting to refactor

00:22:57,360 --> 00:23:02,460
your code this way you can watch your

00:22:59,490 --> 00:23:05,940
classes shrink before your eyes and it's

00:23:02,460 --> 00:23:08,520
wondrous and I've gone so far on this

00:23:05,940 --> 00:23:11,490
that I get the heebie-jeebies when I see

00:23:08,520 --> 00:23:13,290
a class more than 50 lines long I mean

00:23:11,490 --> 00:23:13,710
what could they possibly be doing in

00:23:13,290 --> 00:23:16,080
there

00:23:13,710 --> 00:23:19,050
what could they possibly need to have

00:23:16,080 --> 00:23:23,370
such close interaction with the object

00:23:19,050 --> 00:23:27,780
State for functional programming is just

00:23:23,370 --> 00:23:30,510
it's one us over in this respect and the

00:23:27,780 --> 00:23:32,400
the we also have found that it's really

00:23:30,510 --> 00:23:34,470
valuable to define clear interfaces

00:23:32,400 --> 00:23:36,360
between your components early on the

00:23:34,470 --> 00:23:38,160
things were kind of a tangle and you

00:23:36,360 --> 00:23:39,480
know request handlers would just you

00:23:38,160 --> 00:23:41,340
know open up the reference to the table

00:23:39,480 --> 00:23:43,830
and write some stuff to persistence and

00:23:41,340 --> 00:23:45,660
that was okay but that makes it both

00:23:43,830 --> 00:23:50,340
hard to do any kind of refactoring and

00:23:45,660 --> 00:23:51,179
also really hard to do any testing is

00:23:50,340 --> 00:23:55,350
there any more you wanted to say about

00:23:51,179 --> 00:23:57,360
that sorry the last point is just don't

00:23:55,350 --> 00:23:59,520
write a test if you can't figure out how

00:23:57,360 --> 00:24:02,010
to if you can't figure out how to write

00:23:59,520 --> 00:24:03,660
a robust test if you can't write a test

00:24:02,010 --> 00:24:07,170
that's not overly coupled to the

00:24:03,660 --> 00:24:09,690
underlying implementation take that as a

00:24:07,170 --> 00:24:12,540
code smell take that as an indication of

00:24:09,690 --> 00:24:14,190
further thought further attention don't

00:24:12,540 --> 00:24:17,190
write a test that's only going to slow

00:24:14,190 --> 00:24:19,830
you down when you when you come back

00:24:17,190 --> 00:24:21,780
with a better idea of how to see

00:24:19,830 --> 00:24:23,399
reaction I've seen tests like this that

00:24:21,780 --> 00:24:24,989
take it to such an extreme

00:24:23,399 --> 00:24:26,879
that they use you know some mocking

00:24:24,989 --> 00:24:29,129
library to make up a an automatic mock

00:24:26,879 --> 00:24:30,779
of everything and what it's actually

00:24:29,129 --> 00:24:32,279
testing at the end is that the compiler

00:24:30,779 --> 00:24:32,879
works because the test actually reads

00:24:32,279 --> 00:24:34,769
like this

00:24:32,879 --> 00:24:36,509
you should call this method then call

00:24:34,769 --> 00:24:37,859
this other method then log these two

00:24:36,509 --> 00:24:39,570
things that you've got returned from

00:24:37,859 --> 00:24:41,759
that then return one of those things and

00:24:39,570 --> 00:24:43,169
that's just not useful because you've

00:24:41,759 --> 00:24:45,210
proved that your compiler does what it

00:24:43,169 --> 00:24:46,919
says on the tin and if your compiler

00:24:45,210 --> 00:25:00,239
doesn't work you really should just give

00:24:46,919 --> 00:25:01,679
up and go home thank you so we've got a

00:25:00,239 --> 00:25:03,239
couple of links that might be a little

00:25:01,679 --> 00:25:05,669
interesting at the bottom of this last

00:25:03,239 --> 00:25:07,080
slide since they're long links the QR

00:25:05,669 --> 00:25:19,460
code should take you to the source code

00:25:07,080 --> 00:25:19,460
for our slides right here in the Red Hat

00:25:38,779 --> 00:25:47,580
okay so the question the question was

00:25:43,759 --> 00:25:50,309
about don't write tests for untestable

00:25:47,580 --> 00:25:52,049
code he's coming from a place where

00:25:50,309 --> 00:25:54,059
there's not with there's very little

00:25:52,049 --> 00:25:55,830
test coverage right now and they want to

00:25:54,059 --> 00:25:59,129
put a line in the sand for statement

00:25:55,830 --> 00:26:01,860
coverage how would you answer that well

00:25:59,129 --> 00:26:04,980
any new code you try and design it for

00:26:01,860 --> 00:26:07,499
testing obviously and you try and use

00:26:04,980 --> 00:26:08,909
you know to an extent do what we did and

00:26:07,499 --> 00:26:10,379
use system tests to try and make up for

00:26:08,909 --> 00:26:12,960
some of the gaps in coverage but at the

00:26:10,379 --> 00:26:15,509
end of the day the bad tests were you're

00:26:12,960 --> 00:26:17,879
using too many mocks actually just cost

00:26:15,509 --> 00:26:19,889
you time they made us feel good because

00:26:17,879 --> 00:26:22,679
we had you know high low relative line

00:26:19,889 --> 00:26:23,730
coverage but when we actually when the

00:26:22,679 --> 00:26:25,679
rubber mat the road and we tried to

00:26:23,730 --> 00:26:27,690
deploy these things often there was no

00:26:25,679 --> 00:26:30,590
relationship between that little orb

00:26:27,690 --> 00:26:33,210
being green or white if you're me and

00:26:30,590 --> 00:26:35,759
actually having a working binary when

00:26:33,210 --> 00:26:38,609
you pushed it to production the false

00:26:35,759 --> 00:26:40,379
security is really really bad let's go

00:26:38,609 --> 00:26:41,940
to the microphone I'm I'm trying to

00:26:40,379 --> 00:26:45,419
resolve your point on dependency

00:26:41,940 --> 00:26:47,820
injection so you're talking about live

00:26:45,419 --> 00:26:49,350
code required database database equals

00:26:47,820 --> 00:26:52,499
none what's kind of a problem or your

00:26:49,350 --> 00:26:54,450
talk about the mock object I'm sorry I

00:26:52,499 --> 00:26:56,159
didn't hear all of that when when you're

00:26:54,450 --> 00:26:58,409
talking about dependency injection you

00:26:56,159 --> 00:26:59,759
had a database and database equals none

00:26:58,409 --> 00:27:02,279
into two examples and the database

00:26:59,759 --> 00:27:03,720
equals none was was the bad way of doing

00:27:02,279 --> 00:27:05,519
it that's right yeah that's that's not a

00:27:03,720 --> 00:27:07,980
mock up tip that's a live code example

00:27:05,519 --> 00:27:10,710
yes curtain and does that mean that you

00:27:07,980 --> 00:27:12,330
don't use defaults anywhere I we I feel

00:27:10,710 --> 00:27:15,840
like that's at odds with with having

00:27:12,330 --> 00:27:17,700
sane defaults so sane defaults are a

00:27:15,840 --> 00:27:19,289
good thing but sometimes you have these

00:27:17,700 --> 00:27:21,210
things that just really have to be

00:27:19,289 --> 00:27:23,549
specified and so if it's controlling a

00:27:21,210 --> 00:27:25,259
critical piece of behavior like where

00:27:23,549 --> 00:27:27,419
it's going to write its persistent data

00:27:25,259 --> 00:27:28,529
we found that it's much safer to make it

00:27:27,419 --> 00:27:32,190
a required argument and just always

00:27:28,529 --> 00:27:35,820
specify it yeah we've we found that in

00:27:32,190 --> 00:27:38,399
cases of object relationship where a

00:27:35,820 --> 00:27:41,700
first object does not make sense unless

00:27:38,399 --> 00:27:44,039
it also has a second so a user profile

00:27:41,700 --> 00:27:46,289
doesn't make sense unless it has a user

00:27:44,039 --> 00:27:49,919
credential or something like that

00:27:46,289 --> 00:27:50,820
we found that explicit construction

00:27:49,919 --> 00:27:53,070
parameters

00:27:50,820 --> 00:27:54,539
is the most robust solution their us and

00:27:53,070 --> 00:27:58,279
you guys must really hate start our

00:27:54,539 --> 00:28:00,480
start kwargs no I use them all the time

00:27:58,279 --> 00:28:01,950
those are good for things that are gonna

00:28:00,480 --> 00:28:04,559
change the behavior of your object in a

00:28:01,950 --> 00:28:06,630
subtle way right this is a bad ik this

00:28:04,559 --> 00:28:07,919
is an example because this object just

00:28:06,630 --> 00:28:10,289
doesn't make any sense if it doesn't

00:28:07,919 --> 00:28:12,419
have a database right you have to have a

00:28:10,289 --> 00:28:15,029
database whereas if it was like a little

00:28:12,419 --> 00:28:16,590
flag that said treat the user one way or

00:28:15,029 --> 00:28:18,120
another you know treat all users as

00:28:16,590 --> 00:28:20,159
admins or some goofy flag like that

00:28:18,120 --> 00:28:23,820
maybe that would be different or like

00:28:20,159 --> 00:28:26,759
does this view require an admin is it

00:28:23,820 --> 00:28:28,710
safe to say that we're phasing out star

00:28:26,759 --> 00:28:31,919
and star star args for construction

00:28:28,710 --> 00:28:34,350
parameters yes okay yeah we do use them

00:28:31,919 --> 00:28:37,230
extensively on methods for behavioral

00:28:34,350 --> 00:28:43,139
and we do use them for when we're

00:28:37,230 --> 00:28:45,960
passing things through to a superclass a

00:28:43,139 --> 00:28:48,889
very interesting talk thank you to the

00:28:45,960 --> 00:28:52,500
to somebody who asked about matting code

00:28:48,889 --> 00:28:54,840
adding testico that's not tested I might

00:28:52,500 --> 00:28:56,669
suggest the book maintaining legacy code

00:28:54,840 --> 00:28:59,399
I think that's what it's called by

00:28:56,669 --> 00:29:01,559
Michael feathers so something to look at

00:28:59,399 --> 00:29:05,519
it offers some techniques for doing that

00:29:01,559 --> 00:29:07,590
I wonder when you guys are designing

00:29:05,519 --> 00:29:10,889
your code for testability have you found

00:29:07,590 --> 00:29:14,279
it useful to follow the tail don't ask

00:29:10,889 --> 00:29:16,590
principal I'm not familiar with atoms

00:29:14,279 --> 00:29:20,940
but tell don't ask principal just spell

00:29:16,590 --> 00:29:24,179
it out for us basically there's a school

00:29:20,940 --> 00:29:26,909
of thought that in that proper improper

00:29:24,179 --> 00:29:29,460
object-oriented design you wouldn't

00:29:26,909 --> 00:29:32,009
basically be calling a lot of getters

00:29:29,460 --> 00:29:35,250
and setters on objects because it's kind

00:29:32,009 --> 00:29:38,820
of breaking abstraction and so instead

00:29:35,250 --> 00:29:41,519
of asking objects what their state is

00:29:38,820 --> 00:29:43,500
you should be telling them things to do

00:29:41,519 --> 00:29:47,610
basically so it's kind of a different

00:29:43,500 --> 00:29:49,200
way of thinking about it I think

00:29:47,610 --> 00:29:52,019
everything we've done has been wholly

00:29:49,200 --> 00:29:54,539
independent of that I don't think we've

00:29:52,019 --> 00:29:56,220
been swayed one way or the other by the

00:29:54,539 --> 00:29:57,809
directions in which we've taken our code

00:29:56,220 --> 00:29:59,669
it does sound similar to what we already

00:29:57,809 --> 00:30:03,919
do but without giving it more thought I

00:29:59,669 --> 00:30:03,919
don't know sorry sorry thank you

00:30:05,030 --> 00:30:12,960
hey when you when you mentioned your

00:30:09,090 --> 00:30:15,660
inspect hack I immediately thought of

00:30:12,960 --> 00:30:19,110
something do you guys use any kind of

00:30:15,660 --> 00:30:22,760
strong interface like ABCs or zope

00:30:19,110 --> 00:30:24,690
interface when declaring your objects

00:30:22,760 --> 00:30:26,730
especially things like soap interface

00:30:24,690 --> 00:30:28,470
have very quick very powerful ways to

00:30:26,730 --> 00:30:30,390
immediately verify whether or not an

00:30:28,470 --> 00:30:31,980
object holds up to its contract

00:30:30,390 --> 00:30:35,580
now as curious as to whether or not you

00:30:31,980 --> 00:30:39,950
guys had inspected those before going

00:30:35,580 --> 00:30:42,480
with a more home world solution no

00:30:39,950 --> 00:30:45,290
because at the time that I wrote the the

00:30:42,480 --> 00:30:49,050
horrible inspect hack we were on 2.4 and

00:30:45,290 --> 00:30:51,870
so the ABC stuff hadn't been implemented

00:30:49,050 --> 00:30:54,780
yet I don't think right that's to 6 yeah

00:30:51,870 --> 00:30:55,950
and as far as the soap interface stuff

00:30:54,780 --> 00:30:57,540
that that's a little more heavyweight

00:30:55,950 --> 00:31:00,330
than I want also a lot of our mocks

00:30:57,540 --> 00:31:02,670
don't implement everything they

00:31:00,330 --> 00:31:05,670
implement enough that whatever things

00:31:02,670 --> 00:31:07,950
are tested will work a lot of our mocks

00:31:05,670 --> 00:31:11,160
are works in progress with notes that

00:31:07,950 --> 00:31:14,010
say hey I only did as much as I needed

00:31:11,160 --> 00:31:16,590
for the test in this moment now if you

00:31:14,010 --> 00:31:19,620
need these additional methods go ahead

00:31:16,590 --> 00:31:21,300
and flesh them out and you know even a

00:31:19,620 --> 00:31:23,670
note saying yo who will gladly do the

00:31:21,300 --> 00:31:25,320
code review if you if you write it you

00:31:23,670 --> 00:31:27,630
know I always fast track those kind of

00:31:25,320 --> 00:31:29,040
things when I get them but it's just not

00:31:27,630 --> 00:31:30,930
always practical to sit down and write a

00:31:29,040 --> 00:31:32,580
full a fully functional in-memory

00:31:30,930 --> 00:31:34,020
implementation of something when you

00:31:32,580 --> 00:31:36,360
just need two methods so that you can

00:31:34,020 --> 00:31:38,520
test one little view function that's it

00:31:36,360 --> 00:31:43,230
Thanks so we're intentionally cheating

00:31:38,520 --> 00:31:46,140
with duck typing okay okay so I like

00:31:43,230 --> 00:31:48,930
what you guys said about having system

00:31:46,140 --> 00:31:50,640
tests for the user stories I'm curious

00:31:48,930 --> 00:31:52,590
whether you whether you think that like

00:31:50,640 --> 00:31:54,960
the ideal situation is to have

00:31:52,590 --> 00:31:56,490
everything under unit tests or whether

00:31:54,960 --> 00:31:59,490
you think it's actually you know kind of

00:31:56,490 --> 00:32:01,410
pick and choose the scenarios where unit

00:31:59,490 --> 00:32:02,970
tests are better and other scenarios

00:32:01,410 --> 00:32:04,170
where the system tests are better

00:32:02,970 --> 00:32:06,510
because I think there's a lot of

00:32:04,170 --> 00:32:07,950
religion around sort of Oh everything

00:32:06,510 --> 00:32:10,890
must have a unit test and that's not

00:32:07,950 --> 00:32:13,230
always the right answer because you know

00:32:10,890 --> 00:32:15,299
sometimes just refactoring your code

00:32:13,230 --> 00:32:19,080
forces you to change so many unit tests

00:32:15,299 --> 00:32:20,910
yes so the question is basically when do

00:32:19,080 --> 00:32:22,320
you use unit tests versus system tests

00:32:20,910 --> 00:32:24,720
and we do have a decent chunk of code

00:32:22,320 --> 00:32:27,450
that's not unit tested at all the very

00:32:24,720 --> 00:32:29,670
highest layers that like you know an

00:32:27,450 --> 00:32:31,590
application startup to I'll go and open

00:32:29,670 --> 00:32:33,059
a handle to a big table and then glom it

00:32:31,590 --> 00:32:36,150
into a bunch of other objects that's not

00:32:33,059 --> 00:32:39,809
tested because it's not testable but

00:32:36,150 --> 00:32:41,880
it's also like six lines and so it's

00:32:39,809 --> 00:32:43,669
very easy to be comfortable with this

00:32:41,880 --> 00:32:45,929
isn't this is correct by inspection

00:32:43,669 --> 00:32:47,820
visual inspection and code review and if

00:32:45,929 --> 00:32:50,280
it ever changes you just do the same

00:32:47,820 --> 00:32:52,559
thing again I would say that my

00:32:50,280 --> 00:32:56,070
philosophy is that I believe in strong

00:32:52,559 --> 00:32:58,470
testing of behavioral parts of software

00:32:56,070 --> 00:33:02,130
so things like functions things like

00:32:58,470 --> 00:33:05,270
computations things like state changes

00:33:02,130 --> 00:33:07,559
and I don't believe in unit tests for

00:33:05,270 --> 00:33:09,570
assemblies right when you're starting up

00:33:07,559 --> 00:33:11,640
your application when you're connecting

00:33:09,570 --> 00:33:14,730
one object to another or when you're

00:33:11,640 --> 00:33:18,000
constructing something what what you

00:33:14,730 --> 00:33:20,490
might think of as glue code it's simple

00:33:18,000 --> 00:33:23,040
enough and it's gonna be covered by your

00:33:20,490 --> 00:33:25,020
integration tests like this this

00:33:23,040 --> 00:33:26,850
contemporary class example that we had

00:33:25,020 --> 00:33:28,200
right we might not write a test for that

00:33:26,850 --> 00:33:29,730
because there's really no interesting

00:33:28,200 --> 00:33:31,110
logic in there other than the side

00:33:29,730 --> 00:33:32,160
effect of setting an attribute but I

00:33:31,110 --> 00:33:34,620
would question whether you should be

00:33:32,160 --> 00:33:37,080
doing that anyway yeah but we've we've

00:33:34,620 --> 00:33:38,880
already written the test for the pure

00:33:37,080 --> 00:33:41,100
function that we factored out of that

00:33:38,880 --> 00:33:43,080
method so there's not a whole lot of

00:33:41,100 --> 00:33:47,429
incremental benefit to testing this

00:33:43,080 --> 00:33:49,950
instance method as well cool thanks all

00:33:47,429 --> 00:33:51,450
right let's take one more quickly hi I

00:33:49,950 --> 00:33:52,500
just wanted to try and understand more

00:33:51,450 --> 00:33:55,140
clearly what you said earlier about

00:33:52,500 --> 00:33:56,640
mocks and fakes I mean it sounded like

00:33:55,140 --> 00:33:57,900
what you said is that all of the things

00:33:56,640 --> 00:33:59,850
you've been referring to as mocks are

00:33:57,900 --> 00:34:01,470
actually actually fakes you don't you

00:33:59,850 --> 00:34:03,179
don't actually use like what are

00:34:01,470 --> 00:34:06,929
officially called mock posting that's

00:34:03,179 --> 00:34:08,399
right so the question is do we use

00:34:06,929 --> 00:34:10,800
mostly marks and not fakes or

00:34:08,399 --> 00:34:12,000
exclusively or exclusively fakes and not

00:34:10,800 --> 00:34:15,389
mocks see I'm already confusing the

00:34:12,000 --> 00:34:16,260
terms that's almost true everyone so and

00:34:15,389 --> 00:34:17,820
this will happen to you too right

00:34:16,260 --> 00:34:19,409
there'll be like a third party service

00:34:17,820 --> 00:34:21,570
that we interact with where you just

00:34:19,409 --> 00:34:22,780
can't get around the fact that you don't

00:34:21,570 --> 00:34:24,610
have a fake

00:34:22,780 --> 00:34:26,140
so you have to use a mock in that case

00:34:24,610 --> 00:34:27,220
you need to verify that like you've

00:34:26,140 --> 00:34:29,409
hooked everything up correctly and

00:34:27,220 --> 00:34:32,679
sometimes a mock is the only way out but

00:34:29,409 --> 00:34:34,780
we treat it as a tool of last resort not

00:34:32,679 --> 00:34:36,400
something that we go to immediately you

00:34:34,780 --> 00:34:41,320
you never write a mock for something

00:34:36,400 --> 00:34:42,760
that you wrote no okay that's I don't

00:34:41,320 --> 00:34:44,290
know if there's time to explain but I

00:34:42,760 --> 00:34:47,169
would really like to understand how you

00:34:44,290 --> 00:34:48,400
manage to do that just come up and

00:34:47,169 --> 00:34:51,900
continue it with us

00:34:48,400 --> 00:34:51,900

YouTube URL: https://www.youtube.com/watch?v=Xu5EhKVZdV8


