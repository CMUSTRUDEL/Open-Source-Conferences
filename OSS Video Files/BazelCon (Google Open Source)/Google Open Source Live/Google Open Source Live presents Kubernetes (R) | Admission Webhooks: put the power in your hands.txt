Title: Google Open Source Live presents Kubernetes (R) | Admission Webhooks: put the power in your hands
Publication date: 2021-01-11
Playlist: Google Open Source Live
Description: 
	
Captions: 
	00:00:11,360 --> 00:00:12,320
Hi everyone.

00:00:12,320 --> 00:00:14,000
Thanks for coming to Google open source.

00:00:14,560 --> 00:00:15,840
I'm Cici Huang

00:00:15,840 --> 00:00:18,240
and I'm currently working at Google as a software engineer.

00:00:19,120 --> 00:00:21,680
Today, the topic is Admission Webhooks:

00:00:21,680 --> 00:00:23,280
Put the Power in Your Hands.

00:00:24,880 --> 00:00:27,360
First, let's take a look at today's agenda.

00:00:28,400 --> 00:00:31,360
We are going to talk about what admission webhooks are

00:00:31,360 --> 00:00:33,200
why people need admission webhooks

00:00:33,760 --> 00:00:37,120
and how to config the customer admission webhook

00:00:37,120 --> 00:00:38,480
some best practices

00:00:38,480 --> 00:00:40,800
where you think about your use case and the configurations

00:00:41,360 --> 00:00:45,600
and then, the way to monitor your admission webhook's behavior

00:00:45,600 --> 00:00:47,680
and lastly, we will have a short demo.

00:00:48,560 --> 00:00:50,800
So let's first take a look at what admission webhooks are.

00:00:54,560 --> 00:00:58,160
Here is an overview of the API request lifecycle.

00:00:58,160 --> 00:01:00,320
To understand the admission webhooks

00:01:00,320 --> 00:01:04,000
first we need to understand the admission procedure in Kubernetes.

00:01:04,960 --> 00:01:07,920
An admission controller is a piece of code

00:01:07,920 --> 00:01:11,440
that intercepts a request to the Kubernetes API server

00:01:11,440 --> 00:01:13,680
prior to persistence of the object

00:01:13,680 --> 00:01:16,800
but after the request is authenticated and authorized.

00:01:18,160 --> 00:01:21,440
Kubernetes ships with lot of admission controllers

00:01:21,440 --> 00:01:25,840
and there are 17 of them enabled by default in v1.19.

00:01:27,120 --> 00:01:30,720
A lot of things we assume are native to Kubernetes

00:01:30,720 --> 00:01:33,920
are actually done by those admission controllers.

00:01:34,880 --> 00:01:38,640
And they can be turned on with the Kubernetes API server flag

00:01:38,640 --> 00:01:40,080
enable-admission-plugins.

00:01:42,080 --> 00:01:45,520
Let's take a look at some admission controllers as examples

00:01:45,520 --> 00:01:47,040
which are shaped with Kubernetes.

00:01:48,880 --> 00:01:51,360
Here is NamespaceLifecycle controller.

00:01:52,400 --> 00:01:55,760
When the request to come in tries to create a deployment

00:01:55,760 --> 00:01:58,480
with the name "mydeploy" in the namespace "test"

00:01:59,200 --> 00:02:04,080
and if the test namespace is currently on terminating status

00:02:04,080 --> 00:02:06,480
there's no point creating new deployments.

00:02:07,120 --> 00:02:10,960
So, the NamespaceLifecycle controller simply fills the request

00:02:10,960 --> 00:02:12,000
and will return to the user.

00:02:13,040 --> 00:02:16,000
Another example is the AlwaysPullImages controller.

00:02:17,040 --> 00:02:19,200
We will check the imagePullPolicy

00:02:19,200 --> 00:02:22,240
and update it to be "Always" if it was not.

00:02:24,400 --> 00:02:25,760
As we can see here

00:02:25,760 --> 00:02:29,040
the admission controllers can be categorized into two types

00:02:29,040 --> 00:02:32,320
mutating admission controllers and validating admission controllers

00:02:32,960 --> 00:02:34,160
and some may be both.

00:02:34,720 --> 00:02:38,000
Mutating controllers may modify the objects they admit.

00:02:38,720 --> 00:02:40,000
Validating controllers may not.

00:02:40,880 --> 00:02:44,640
The admission controller proceeds in two phases.

00:02:45,200 --> 00:02:48,560
In the first phase, mutating admission controllers are on

00:02:48,560 --> 00:02:51,840
and in the second phase validating admission controllers are run.

00:02:52,720 --> 00:02:56,720
If any of the controllers in either phase reject the request

00:02:56,720 --> 00:03:04,000
the entire request is rejected immediately and an error is returned to the end-user.

00:03:04,000 --> 00:03:07,840
Among those admission controllers shipped with Kubernetes

00:03:07,840 --> 00:03:12,320
two take a special role because of their nearly limitless flexibility

00:03:13,200 --> 00:03:15,360
MutatingAdmissionWebhooks and ValidatingAdmissionWebhooks.

00:03:17,200 --> 00:03:20,720
They do not implement any policy decision logic themselves.

00:03:20,720 --> 00:03:25,040
Instead, the respective action is obtained from a REST endpoint

00:03:25,040 --> 00:03:27,040
of a service running inside of the cluster.

00:03:28,000 --> 00:03:31,360
This approach decouples the admission controller logic

00:03:31,360 --> 00:03:33,440
from the Kubernetes API server

00:03:33,440 --> 00:03:36,800
thus allowing users to implement a custom logic

00:03:36,800 --> 00:03:40,000
to be executed whenever resources are created

00:03:40,000 --> 00:03:42,880
updated, or deleted in a Kubernetes cluster.

00:03:43,840 --> 00:03:47,520
The difference between the two kinds of admission controller webhooks

00:03:47,520 --> 00:03:49,840
is pretty much self-explanatory.

00:03:50,640 --> 00:03:54,720
MutatingAdmissionWebhooks may mutate the objects

00:03:54,720 --> 00:03:56,960
while ValidatingAdmissionWebhooks may not.

00:03:57,760 --> 00:04:00,880
And MutatingAdmissionWebhooks are called in serial

00:04:00,880 --> 00:04:03,760
while ValidatingAdmissionWebhooks are called in parallel.

00:04:05,200 --> 00:04:07,520
So, why do we need admission webhooks?

00:04:09,680 --> 00:04:15,360
The admission webhooks can help in 13 areas.

00:04:16,880 --> 00:04:19,200
They can help with increasing security

00:04:19,200 --> 00:04:24,080
by mandating a reasonable security baseline across an entire namespace or cluster.

00:04:24,080 --> 00:04:28,960
For example, we can allow pulling images only from a certain registry

00:04:28,960 --> 00:04:30,640
inside your corporation

00:04:30,640 --> 00:04:33,680
and we can disallow containers from running as root.

00:04:34,480 --> 00:04:40,480
And secondly, they can help to enforce adherence to certain practices

00:04:40,480 --> 00:04:45,120
such as having good labels, annotations, resource limits, or other settings.

00:04:45,120 --> 00:04:48,320
For example, we can enforce some label validation

00:04:48,320 --> 00:04:52,480
or add annotations to objects, like adding a cost center.

00:04:54,080 --> 00:04:57,520
And third, they can help with configuration management.

00:04:58,080 --> 00:05:02,400
For example, we can add resource limits or validate the resource limits.

00:05:03,360 --> 00:05:07,600
And also, we can ensure image references used in production deployments

00:05:07,600 --> 00:05:09,440
are not using the "latest" tags.

00:05:13,760 --> 00:05:18,400
Next, how can we configure our admission webhooks?

00:05:20,800 --> 00:05:24,160
Before we take a deep look at the configuration fields

00:05:24,160 --> 00:05:27,600
there are some prerequisites we'd better keep in mind

00:05:27,600 --> 00:05:29,440
while we are using admission webhooks.

00:05:30,240 --> 00:05:33,280
First, we always have to check the Kubernetes cluster versions.

00:05:33,280 --> 00:05:36,080
It has to be at least at v1.16

00:05:36,080 --> 00:05:38,560
for using admissionregistration.k8s.io/v1

00:05:40,880 --> 00:05:43,920
and it should be at v1.9

00:05:43,920 --> 00:05:45,520
to use admissionregistration.k8s.io/v1beta1.

00:05:49,920 --> 00:05:52,880
And we also have to ensure that the MutatingAdmissionWebhook

00:05:52,880 --> 00:05:57,600
and the ValidatingAdmissionWebhook admission controllers are enabled

00:05:57,600 --> 00:05:59,280
by the flag we talked about earlier.

00:06:00,320 --> 00:06:05,840
And also, we should ensure that the API is enabled.

00:06:07,120 --> 00:06:10,880
Here is an example of a validating webhook configuration.

00:06:10,880 --> 00:06:13,760
I will not go through all the fields in the detail.

00:06:13,760 --> 00:06:17,280
Basically, it's a validating webhook configuration.

00:06:17,280 --> 00:06:22,960
It only contains one webhook with the name: "pod-policy.example.com"

00:06:23,520 --> 00:06:28,080
with the rules triggered on every namespaced pod creation request.

00:06:29,120 --> 00:06:33,840
The ClientConfig tells the API server how to contact the webhook.

00:06:33,840 --> 00:06:36,960
And this webhook does not have any side effects

00:06:36,960 --> 00:06:41,200
and it has 5 seconds' timeout for the API server to call the webhook.

00:06:43,120 --> 00:06:46,480
There are some other optional fields you can set

00:06:46,480 --> 00:06:48,080
which are not shown here.

00:06:48,080 --> 00:06:51,280
We will talk about them in more detail in the following slides.

00:06:53,040 --> 00:06:56,720
And there are always some best practices recommended

00:06:56,720 --> 00:06:59,200
in terms of thinking about your use case

00:06:59,200 --> 00:07:01,760
or thinking about how to configure your own webhook.

00:07:03,920 --> 00:07:06,400
The first one is Idempotence.

00:07:07,600 --> 00:07:08,800
What is Idempotence?

00:07:09,760 --> 00:07:13,680
Idempotence, after being applied multiple times

00:07:15,520 --> 00:07:20,320
the status, the result, and the side effects should be exactly the same

00:07:20,320 --> 00:07:21,600
as being applied once.

00:07:22,800 --> 00:07:26,640
So here is an example of idempotent mutating admission webhooks.

00:07:27,680 --> 00:07:30,080
All of these pull images

00:07:30,080 --> 00:07:34,400
so no matter how many times it's been called

00:07:34,400 --> 00:07:37,120
it will always check the ImagePullPolicy field

00:07:37,120 --> 00:07:39,920
and update it to be "Always" if it was not.

00:07:41,760 --> 00:07:46,800
Another example shows non-idempotent mutating admission webhooks

00:07:47,360 --> 00:07:51,920
which try to inject the sidecar with the timestamp in the name.

00:07:52,720 --> 00:07:55,520
So when it's called the first time

00:07:56,880 --> 00:08:00,720
it will append a sidecar container in your container list

00:08:00,720 --> 00:08:03,600
with the current timestamp in the name.

00:08:03,600 --> 00:08:06,080
But when it's called the second time

00:08:06,080 --> 00:08:12,160
it will append another sidecar container into your containers list with a timestamp

00:08:12,160 --> 00:08:15,600
which might not be something users wanted.

00:08:17,920 --> 00:08:22,880
So, why do we want the mutating webhook to be idempotent?

00:08:24,240 --> 00:08:28,560
Because a mutating webhook may be called twice by the API server.

00:08:30,320 --> 00:08:33,600
A single ordering of mutating animation plug-ins

00:08:33,600 --> 00:08:35,440
just does not work for all cases

00:08:36,080 --> 00:08:40,160
because some other admission controllers may mutate the object.

00:08:40,160 --> 00:08:42,960
And the decision may be different depending on the order.

00:08:43,680 --> 00:08:45,120
Let's take a look at an example.

00:08:46,400 --> 00:08:50,000
Here in the example, we try to inject the sidecar.

00:08:50,000 --> 00:08:52,640
And when this controller is called

00:08:52,640 --> 00:08:56,480
a sidecar container is appended into the port.

00:08:58,080 --> 00:09:02,160
And then all these pull images are called.

00:09:02,160 --> 00:09:03,520
So, maybe I'll go ahead

00:09:03,520 --> 00:09:06,320
and check the imagePullPolicy to all the containers

00:09:06,320 --> 00:09:08,400
and update them to be "Always."

00:09:09,600 --> 00:09:11,360
But what if the order is different?

00:09:13,280 --> 00:09:16,080
If we first call "always pull images"

00:09:16,080 --> 00:09:19,040
which will update our imagePullPolicy to be "Always"

00:09:21,600 --> 00:09:24,400
and then the "inject sidecar" is called

00:09:25,440 --> 00:09:28,800
which will try to append a sidecar with the name "sidecar"

00:09:28,800 --> 00:09:29,920
in the containers list

00:09:30,480 --> 00:09:34,320
but the imagePullPolicy is not set to be "Always"

00:09:34,320 --> 00:09:35,840
which is contrary to our expectation.

00:09:39,520 --> 00:09:44,240
So we try to apply the best effort reinvocation mechanism

00:09:44,240 --> 00:09:49,840
by allowing it to set the reinvocationPolicy field to "IfNeeded."

00:09:50,960 --> 00:09:55,680
So, as in the previous case the injector sidecar is called

00:09:56,240 --> 00:10:00,560
and the sidecar container is ingested into the container list

00:10:00,560 --> 00:10:05,680
and then the "always pull images" is allowed to be called twice

00:10:05,680 --> 00:10:08,560
and updates the image pull policy to be "Always"

00:10:08,560 --> 00:10:09,920
which meets the expectation.

00:10:12,640 --> 00:10:18,640
And the second best practice is intercepting all versions of an object.

00:10:19,760 --> 00:10:23,200
We all know that Kubernetes supports multiple API versions.

00:10:23,200 --> 00:10:28,160
For example, kube-apiserver allows creating, updating deployments

00:10:28,160 --> 00:10:35,360
via extensions/v1beta1, apps/v1beta1, apps/v1beta2, and apps/v1 APIs.

00:10:36,000 --> 00:10:38,080
If a webhook is configured

00:10:38,080 --> 00:10:41,600
to only intercept a deployment request in apps/v1

00:10:42,880 --> 00:10:46,080
it will miss request in the other versions.

00:10:46,080 --> 00:10:48,800
It is recommended that admission webhooks

00:10:48,800 --> 00:10:51,920
should always intercept all versions of an object

00:10:51,920 --> 00:10:55,200
by setting the matchPolicy field to be "Equivalent."

00:10:56,160 --> 00:10:58,000
It is also recommended that

00:10:58,000 --> 00:11:02,800
admission webhooks should prefer registering for the stable versions of the resources

00:11:03,360 --> 00:11:07,040
and a failure to intercept all versions of an object can result in

00:11:07,040 --> 00:11:11,920
admission policies not being enforced for requests in 13 versions.

00:11:13,520 --> 00:11:15,760
The next best practice is availability.

00:11:16,720 --> 00:11:21,600
The time-calling webhook builds up time completing the entire API request.

00:11:22,560 --> 00:11:24,400
So it's always recommended that

00:11:24,400 --> 00:11:27,840
admission webhooks should evaluate as quickly as possible

00:11:27,840 --> 00:11:31,040
and it's encouraged to use a small timeout for webhooks.

00:11:31,920 --> 00:11:32,880
In this example

00:11:33,680 --> 00:11:37,440
the validating admission webhook sets a 2-second timeout.

00:11:38,240 --> 00:11:41,840
If the webhook is being slow and doesn't respond in 2 seconds

00:11:42,480 --> 00:11:45,600
the API server will either reject the request

00:11:45,600 --> 00:11:48,720
or ignore the failure, based on the failure policy set.

00:11:50,720 --> 00:11:56,400
The next best practice is guaranteeing the final state of the object is seen.

00:11:58,080 --> 00:12:01,520
If you use a mutating webhook to enforce security policy

00:12:02,080 --> 00:12:04,960
make sure to use a validating webhook to ensure that

00:12:04,960 --> 00:12:07,520
because another webhook may be invoked

00:12:07,520 --> 00:12:10,160
after your admission webhook is called.

00:12:12,240 --> 00:12:15,200
And then the next best practice

00:12:15,200 --> 00:12:18,480
is avoiding deadlocks in self-hosted webhooks.

00:12:23,200 --> 00:12:29,120
A webhook running inside the cluster might cause deadlocks for its own deployment

00:12:29,120 --> 00:12:33,600
if it is configured to intercept resources required to start its own pods.

00:12:34,560 --> 00:12:35,600
Let's take an example.

00:12:36,640 --> 00:12:41,600
A mutating animation webhook is configured to admit create pod requests

00:12:41,600 --> 00:12:44,160
only if a certain label is set in the pod.

00:12:44,160 --> 00:12:46,800
In this case, we require the environment label

00:12:46,800 --> 00:12:48,080
to be set to "production."

00:12:48,800 --> 00:12:51,760
The webhook server runs a deployment

00:12:51,760 --> 00:12:54,320
which doesn't set the environment label to "production."

00:12:54,960 --> 00:12:59,920
And then the node that runs the webhook server pods becomes unhealthy.

00:12:59,920 --> 00:13:03,760
The webhook deployment will try to reschedule the pods to another node.

00:13:04,480 --> 00:13:09,280
However, the request will get rejected by the existing webhook server

00:13:09,280 --> 00:13:12,160
since the environment label is not set correctly

00:13:12,160 --> 00:13:13,840
and the migration cannot happen.

00:13:16,720 --> 00:13:21,760
So, we recommend to exclude the namespace where your webhook is running

00:13:21,760 --> 00:13:24,640
by setting the namespaceSelector fields.

00:13:27,440 --> 00:13:30,400
And another best practice is side effects.

00:13:31,200 --> 00:13:33,840
Always try to avoid side effects if possible.

00:13:34,480 --> 00:13:38,480
If they cannot be avoided, don't trigger the side effect in dry run

00:13:39,520 --> 00:13:43,680
by setting the sideEffects field to be "NoneOnDryRun."

00:13:45,520 --> 00:13:47,280
And the last best practice

00:13:47,280 --> 00:13:50,400
is avoiding operating on the kube-system namespace.

00:13:51,040 --> 00:13:55,840
The kube-system namespace contains objects created by the Kubernetes system

00:13:56,400 --> 00:14:00,080
like various accounts for control-plane components

00:14:00,080 --> 00:14:02,320
pods like kube-dns.

00:14:02,320 --> 00:14:06,560
Accidentally mutating or rejecting requests in the kube-system namespace

00:14:06,560 --> 00:14:09,520
may cause the control-plane components to stop functioning

00:14:09,520 --> 00:14:11,040
or introduce a null behavior.

00:14:11,920 --> 00:14:13,600
If your admission webhooks

00:14:13,600 --> 00:14:17,120
don't intend to modify the behavior of the Kubernetes control plane

00:14:17,680 --> 00:14:21,680
exclude the kube-system namespace from being intercepted

00:14:21,680 --> 00:14:23,600
using the namespaceSelector field.

00:14:24,720 --> 00:14:25,840
Here is an example.

00:14:26,560 --> 00:14:29,280
Only match the requests in a namespace

00:14:29,280 --> 00:14:32,880
which the rule level value is not equal to 0 or 1.

00:14:34,480 --> 00:14:36,240
It also helps with efficiency.

00:14:36,800 --> 00:14:38,080
We mentioned earlier that

00:14:38,080 --> 00:14:43,760
every webhook invocation latency builds up the entire API request latency.

00:14:43,760 --> 00:14:46,240
By excluding the kube-system namespace

00:14:46,240 --> 00:14:50,160
the webhook invocation is scoped to only what is needed.

00:14:52,560 --> 00:14:57,840
Next, let's talk about the ways to monitor admission webhook behavior.

00:14:58,560 --> 00:14:59,760
There are some questions.

00:15:00,320 --> 00:15:02,960
And the answers to certain questions

00:15:02,960 --> 00:15:06,480
can definitely help us to monitor the admission webhook behavior.

00:15:07,040 --> 00:15:11,120
Like which mutating webhook mutated the object in an API request?

00:15:11,120 --> 00:15:14,160
What change did the mutating webhook apply to the object?

00:15:14,160 --> 00:15:17,200
Or which webhooks are frequently rejecting API requests?

00:15:17,200 --> 00:15:19,200
And what's the reason for rejection?

00:15:21,840 --> 00:15:27,520
The API server provides two main ways to monitor.

00:15:27,520 --> 00:15:29,120
The first is through auditing.

00:15:30,080 --> 00:15:34,480
Kube-apiserver performs auditing on each mutating webhook invocation.

00:15:35,120 --> 00:15:38,240
Each invocation generates an auditing annotation

00:15:38,240 --> 00:15:42,880
capturing if the request object is mutated by the invocation

00:15:42,880 --> 00:15:47,440
and optionally generates an annotation capturing the applied patch

00:15:47,440 --> 00:15:49,120
from the webhook admission response.

00:15:50,400 --> 00:15:54,160
For the audit-level metadata or higher

00:15:54,720 --> 00:15:56,800
an annotation with the key

00:15:56,800 --> 00:16:03,600
mutation.webhook.admission.k8s.io/ round_{round idx}_index_{order idx}

00:16:03,600 --> 00:16:04,240
gets logged

00:16:05,040 --> 00:16:10,400
with JSON payload indicating webhook gets invoked for giving requests

00:16:10,400 --> 00:16:13,600
and whether it mutates the object or not.

00:16:14,480 --> 00:16:19,040
The example on the left shows an annotation case

00:16:19,040 --> 00:16:23,120
recorded for a webhook being invoked in the first round.

00:16:23,120 --> 00:16:26,960
And the webhook is ordered the first in the mutating webhook chain.

00:16:28,960 --> 00:16:32,480
And it mutated the request object during the invocation.

00:16:33,920 --> 00:16:38,080
For audit-level requests or higher

00:16:38,080 --> 00:16:39,840
an annotation with key

00:16:39,840 --> 00:16:47,120
patch.webhook.admission.k8s.io/ round_{round idx}_index_{order idx}

00:16:47,120 --> 00:16:49,440
gets logged with JSON payload

00:16:49,440 --> 00:16:52,480
indicating a webhook gets invoked for giving requests

00:16:52,480 --> 00:16:55,520
and what patch gets applied to the request object.

00:16:56,720 --> 00:16:59,600
If we take a look at the right example

00:17:00,160 --> 00:17:04,240
annotation gets recorded for webhook being reinvoked.

00:17:04,240 --> 00:17:08,480
The webhook is ordered the first in the mutating webhook chain

00:17:08,480 --> 00:17:14,720
and responded with a JSON patch that got applied to the request object.

00:17:16,720 --> 00:17:22,400
And we can also monitor the webhook by the metrics endpoints.

00:17:23,200 --> 00:17:27,920
There are two metrics highly related to the admission webhooks.

00:17:28,560 --> 00:17:34,000
The first is apiserver_admission _webhook_admission_duration_seconds

00:17:34,560 --> 00:17:37,600
which is a histogram metric

00:17:37,600 --> 00:17:42,640
that tells you how long the webhook admission takes.

00:17:43,360 --> 00:17:47,600
And the second is apiserver_admission_webhook_rejection_count

00:17:47,600 --> 00:17:49,280
which is a counter metric

00:17:49,280 --> 00:17:52,720
grouped by name, operation, type, error type, rejection code.

00:17:53,360 --> 00:17:59,840
And below are the examples of what the metrics log looks like.

00:18:00,480 --> 00:18:03,120
And now let's take a look at a short demo.

00:18:04,560 --> 00:18:06,800
The demo use case is fairly simple.

00:18:07,360 --> 00:18:11,120
We want to have a validating admission webhook

00:18:11,120 --> 00:18:14,240
which can ensure pods run as a non-root user.

00:18:14,960 --> 00:18:19,200
I have four examples of pods to be created.

00:18:19,760 --> 00:18:26,000
The first one without the run as a non-root being set at "All."

00:18:26,000 --> 00:18:29,840
And the second one we set the run as a non-root to be fourth.

00:18:30,800 --> 00:18:35,040
The third one, even though we set the run as a non-root to be "True"

00:18:35,040 --> 00:18:37,280
but we're giving an admin "Either."

00:18:37,840 --> 00:18:41,600
The third one with run as a non-root to be "True"

00:18:41,600 --> 00:18:44,320
and we're giving the user as one, two, three.

00:18:45,280 --> 00:18:49,600
So the Kubernetes API should reject the first three requests

00:18:49,600 --> 00:18:51,760
and only allow the last one to be passed.

00:18:53,760 --> 00:18:56,800
And here is our validating webhook configuration

00:18:56,800 --> 00:19:03,520
in which we have one webhook called k8s-validation-webhook.demo.com

00:19:04,400 --> 00:19:10,880
and for all the pod creation requests happening in the namespace

00:19:12,240 --> 00:19:14,560
which have webhook labels to be "enabled."

00:19:16,640 --> 00:19:22,160
And here is the API behavior returned

00:19:22,160 --> 00:19:23,840
when we tried to create the pods.

00:19:25,200 --> 00:19:28,560
I will not do a live demo in this talk

00:19:28,560 --> 00:19:32,320
but I have all the demo code uploaded on GitHub.

00:19:34,480 --> 00:19:37,840
If anyone is interested, please feel free to take a look.

00:19:38,720 --> 00:19:40,240
That's the end of the talk.

00:19:40,240 --> 00:19:51,840

YouTube URL: https://www.youtube.com/watch?v=cPO8dHtxcuk


