Title: Google Open Source Live "Go day" | Get Started
Publication date: 2020-12-03
Playlist: Google Open Source Live
Description: 
	
Captions: 
	00:00:10,480 --> 00:00:11,760
Hey there, I'm Steve Traut.

00:00:11,760 --> 00:00:13,680
I'm a tech writer on the Go team.

00:00:13,680 --> 00:00:15,840
Today I'm going to show you how I can install Go

00:00:15,840 --> 00:00:17,520
and write a bit of code.

00:00:17,520 --> 00:00:19,440
Along the way I'll talk about modules

00:00:19,440 --> 00:00:22,560
which code developers use to manage dependencies

00:00:22,560 --> 00:00:25,200
and I'll finish up by writing a simple web service

00:00:25,200 --> 00:00:27,120
which is one of the things Go does best.

00:00:27,120 --> 00:00:30,160
So let's get started and install Go.

00:00:30,160 --> 00:00:34,240
I'll visit the Go homepage at golang.org and click the Documents link

00:00:34,800 --> 00:00:36,000
and then Installing Go.

00:00:38,000 --> 00:00:42,640
Now, this page includes a button I can use to download a file to install from

00:00:42,640 --> 00:00:44,400
along with installation instructions.

00:00:45,040 --> 00:00:47,760
If the download isn't what I'm looking for

00:00:47,760 --> 00:00:49,760
I can click the other downloads link

00:00:49,760 --> 00:00:57,920
to scroll for a file that might be a better fit for me.

00:00:57,920 --> 00:00:59,520
But I'm going to click the great big button

00:00:59,520 --> 00:01:01,600
to download a file to install.

00:01:05,120 --> 00:01:11,840
And once it's downloaded, I'll open it to start the installer

00:01:14,240 --> 00:01:15,120
and click Continue

00:01:17,760 --> 00:01:21,280
and it's telling me how much space Go will take up on my disk

00:01:21,280 --> 00:01:22,160
after I've installed.

00:01:22,160 --> 00:01:23,040
I'll click Install

00:01:24,880 --> 00:01:26,480
and it prompts me for my password.

00:01:31,920 --> 00:01:34,720
And then the installer begins running scripts to install Go.

00:01:34,720 --> 00:01:36,480
This takes about a minute or so.

00:01:36,480 --> 00:01:39,520
It's downloading files from the Go site to my computer

00:01:39,520 --> 00:01:42,320
and it's running scripts to update PADS on my computer

00:01:42,320 --> 00:01:44,640
so that I can run Go commands from the command line.

00:01:48,640 --> 00:01:50,480
And once it's finished, Go is installed.

00:01:53,280 --> 00:01:55,280
I'll be using the command line for this demo

00:01:55,280 --> 00:01:58,000
but there are several editors and IDEs that support Go.

00:01:58,960 --> 00:02:00,000
If you like an IDE

00:02:00,000 --> 00:02:03,200
be sure to check out the talk by Julie Qiu and Rebecca Stambler.

00:02:03,840 --> 00:02:05,040
In my command prompt

00:02:05,040 --> 00:02:08,480
I'll run the "go version" command to confirm that Go is installed.

00:02:12,080 --> 00:02:15,840
Yep, it tells me Go's release version, along with the OS it's compiled for

00:02:16,400 --> 00:02:17,680
and now I'm ready to write some code.

00:02:17,680 --> 00:02:19,280
I'll start with a "Hello, World!" app.

00:02:19,840 --> 00:02:22,480
First, I'll create a directory in which to keep the code

00:02:27,280 --> 00:02:28,400
and I'll "cd" in there

00:02:29,680 --> 00:02:32,000
and then I'll create a file to put the code in.

00:02:33,280 --> 00:02:35,840
Today, I'm using Sublime Text.

00:02:39,040 --> 00:02:41,360
I'll save it into the directory I just created

00:02:41,360 --> 00:02:42,800
and call it "hello.go."

00:02:47,120 --> 00:02:49,600
All Go code needs to be part of a package.

00:02:49,600 --> 00:02:53,600
A package is the primary group in which you organize the functions you write

00:02:53,600 --> 00:02:55,040
so I'll declare a package first.

00:02:57,600 --> 00:02:58,960
I'm calling this package "main"

00:02:58,960 --> 00:03:03,280
because any Go code you want to execute on its own has to be in a main package

00:03:03,280 --> 00:03:05,120
and I want this to run independently.

00:03:06,080 --> 00:03:08,400
Writing an executable program in Go is easy.

00:03:08,400 --> 00:03:11,040
There's a specific convention that Go follows.

00:03:11,040 --> 00:03:14,240
Create a package called "main" and put a "main" function in it.

00:03:14,240 --> 00:03:18,240
In a "main" package, a "main" function becomes your application's entry point.

00:03:19,440 --> 00:03:21,200
So I'll create a main function.

00:03:25,200 --> 00:03:27,680
Alright, so next I'll import "fmt" package.

00:03:28,400 --> 00:03:31,840
"Fmt" is short for "format."

00:03:35,040 --> 00:03:39,280
The "fmt" package contains functions for reading and printing text

00:03:39,280 --> 00:03:42,960
and it's just one of more than 300 packages in the Go standard library.

00:03:43,520 --> 00:03:45,600
I'll be using a function in the "fmt" package

00:03:45,600 --> 00:03:46,720
to print my greeting.

00:03:47,680 --> 00:03:49,280
So, inside my "main" function

00:03:50,560 --> 00:03:51,600
I'll call "fmt"

00:03:52,680 --> 00:03:54,160
and "Println."

00:03:58,240 --> 00:04:01,680
Go has great native support for Unicode

00:04:01,680 --> 00:04:03,120
so I'll get a little bit clever here.

00:04:03,120 --> 00:04:04,960
Instead of using text for my greeting

00:04:04,960 --> 00:04:08,720
I'll use a couple of emojis and paste them into my code and use those.

00:04:13,200 --> 00:04:14,720
This looks like a "hello" wave.

00:04:25,440 --> 00:04:27,840
And looking for the world... There it is.

00:04:31,120 --> 00:04:31,760
Copy that

00:04:35,200 --> 00:04:36,400
and paste that in as well.

00:04:37,440 --> 00:04:39,520
So this should be all the code I need.

00:04:39,520 --> 00:04:43,440
The quickest way to run Go code in a simple setup like this without an IDE

00:04:44,000 --> 00:04:46,320
is to use the "go run" command

00:04:46,320 --> 00:04:49,520
so I'll type "go run hello.go"

00:04:52,080 --> 00:04:54,000
and it's an emoji "Hello, World!"

00:04:54,000 --> 00:04:56,640
I'll make it a little bit more interesting in a minute

00:04:56,640 --> 00:05:00,000
but first I want to say a bit more about a couple of the things I just introduced.

00:05:01,840 --> 00:05:05,440
You saw me use the "go run" command to run a "main" function in a "main" package.

00:05:06,000 --> 00:05:10,320
Earlier, I used the "go version" command to confirm that Go is installed.

00:05:10,320 --> 00:05:13,520
Those are just two of many Go commands that you might find handy.

00:05:14,080 --> 00:05:15,280
Here are just a few more.

00:05:15,280 --> 00:05:19,840
You could run "go build" and "go install" to compile your code to a local binary.

00:05:20,720 --> 00:05:24,640
You can run "go test" to test your code with Go's testing framework.

00:05:25,440 --> 00:05:27,360
And "go get" is a commonly used command

00:05:27,360 --> 00:05:30,960
to download source for your code's dependencies.

00:05:30,960 --> 00:05:33,840
I'll show that later when I use code someone else has written.

00:05:35,280 --> 00:05:40,080
For the full reference on commands, check out the golang.org website

00:05:40,080 --> 00:05:43,120
where the commands are organized according to the things you might want to do.

00:05:44,960 --> 00:05:48,880
I also want to say more about how Go code is organized and distributed.

00:05:48,880 --> 00:05:50,800
You write code as functions

00:05:50,800 --> 00:05:53,440
and you collect related functions into packages

00:05:53,440 --> 00:05:55,840
and you collect related packages into modules.

00:05:56,640 --> 00:05:59,920
If you want to make your functions available to other developers

00:05:59,920 --> 00:06:01,440
you publish your module

00:06:01,440 --> 00:06:04,480
so that it's visible on the package discovery site.

00:06:05,120 --> 00:06:08,960
As a Go developer, you have access to lots of other packages and functions

00:06:08,960 --> 00:06:10,640
you can use in your own code.

00:06:10,640 --> 00:06:13,920
That includes the hundreds of packages in the Go standard library.

00:06:14,800 --> 00:06:17,200
Those are listed on the package discovery site

00:06:17,200 --> 00:06:20,240
at package.go.dev.

00:06:20,240 --> 00:06:23,440
But you can get even more packages written by other developers.

00:06:23,440 --> 00:06:27,680
Their packages are available alongside the standard library.

00:06:27,680 --> 00:06:29,840
You can search for a package you might want to use

00:06:32,080 --> 00:06:34,640
Packages for adding features relating to databases

00:06:34,640 --> 00:06:37,040
security, encryption, and so on.

00:06:37,040 --> 00:06:40,400
Right now, I just want to show you how you can use a package you've found

00:06:40,400 --> 00:06:42,800
so I'll search for one I already know about.

00:06:42,800 --> 00:06:47,840
I'll look for the "quote" package.

00:06:49,200 --> 00:06:52,480
And this rsc.io quote package is the one I'm looking for.

00:06:54,160 --> 00:06:57,760
That "quote" package was written by Russ Cox, one of Go's designers.

00:06:58,320 --> 00:06:59,600
I know Russ does good work

00:06:59,600 --> 00:07:02,080
so I'm going to give that one a try in my code.

00:07:02,080 --> 00:07:05,440
From the list of functions in the package, I can see he's got a "hello" function

00:07:05,440 --> 00:07:06,960
that returns a friendly greeting.

00:07:08,000 --> 00:07:09,280
And here at the top of the page

00:07:10,160 --> 00:07:16,960
I can see that Russ's package is in a module called "rsc.io/quote."

00:07:18,080 --> 00:07:19,520
On the versions tab here

00:07:19,520 --> 00:07:22,560
I can see a list of the versions for this package in the module.

00:07:24,160 --> 00:07:30,000
Each of these represents a tagged version of the code in Russ's repository.

00:07:30,000 --> 00:07:32,800
Go modules use this semantic versioning model.

00:07:32,800 --> 00:07:36,960
A version number includes a major part, a minor part, and a patch part.

00:07:36,960 --> 00:07:38,800
A major update includes changes

00:07:38,800 --> 00:07:41,280
that aren't guaranteed to be backward compatible.

00:07:41,280 --> 00:07:44,480
Those might be changes to modules' public API, for example

00:07:45,120 --> 00:07:47,760
things that break code that's already using the module.

00:07:48,560 --> 00:07:52,080
A minor version update is guaranteed to be backward compatible

00:07:52,080 --> 00:07:56,240
but it also could include changes to public API such as adding new functions.

00:07:56,800 --> 00:07:59,840
A patch update is guaranteed to be backward compatible

00:07:59,840 --> 00:08:01,120
and is for bug fixes.

00:08:01,840 --> 00:08:04,560
Let's look again at the v1 versions.

00:08:06,400 --> 00:08:08,320
Let's look again at the v1 versions.

00:08:09,360 --> 00:08:12,080
v1.0.0 had a single function in it.

00:08:13,680 --> 00:08:18,480
v1.1.0 is a minor release, so it added another function

00:08:18,480 --> 00:08:20,800
without breaking backward compatibility

00:08:20,800 --> 00:08:23,840
and it was the same for v1.2.0, which added a third.

00:08:24,720 --> 00:08:28,800
v1.2.1 is a patch release, so no changes to the public API

00:08:29,360 --> 00:08:31,040
but it's a bug fix release.

00:08:31,680 --> 00:08:35,440
And down here, v2 and v3, are major version updates

00:08:35,440 --> 00:08:37,520
that don't guarantee backward compatibility.

00:08:38,240 --> 00:08:41,440
This versioning scheme helps you keep your code stable.

00:08:41,440 --> 00:08:44,480
You can upgrade in a deliberate way, knowing the risk.

00:08:44,480 --> 00:08:45,920
So, now I'll try out the package.

00:08:45,920 --> 00:08:48,720
I'll copy the package path up here at the top of the page

00:08:49,920 --> 00:08:51,200
and now I've got it

00:08:51,200 --> 00:08:54,080
I can paste it into my own code in an import statement.

00:08:57,600 --> 00:09:01,040
And "import 'rsc.io/quote'."

00:09:02,960 --> 00:09:06,400
In my "main" function, I'll call Russ's quote hello function.

00:09:06,400 --> 00:09:08,880
I'll replace what I'm doing there with the emojis

00:09:09,600 --> 00:09:11,440
and add a call to "hello."

00:09:18,320 --> 00:09:21,680
So, now I'll put my code into its own module.

00:09:21,680 --> 00:09:25,600
Having it in a module gives me a way to manage its dependencies

00:09:25,600 --> 00:09:27,360
like this quote module I just added.

00:09:27,360 --> 00:09:28,960
I'll show you how in a minute.

00:09:28,960 --> 00:09:35,840
I'll add my code to a new module by running the "go mod init" command.

00:09:44,960 --> 00:09:46,560
And for the command's argument

00:09:47,360 --> 00:09:50,480
I'll give it a location in my Git repository

00:09:51,440 --> 00:09:53,360
because that's where I'll eventually keep my code.

00:09:53,920 --> 00:09:55,680
This becomes my module path

00:09:55,680 --> 00:09:58,240
and it's part of a unique identifier for my module.

00:09:59,280 --> 00:10:03,840
And now I'll run the command.

00:10:05,920 --> 00:10:08,560
The command created a go.mod file.

00:10:08,560 --> 00:10:09,520
Let's take a look at that.

00:10:13,600 --> 00:10:16,000
The file gives the version of Go I'm using

00:10:16,000 --> 00:10:18,640
as the minimum required version for my module.

00:10:18,640 --> 00:10:21,200
Also, at the top, there's that Git repository location

00:10:21,920 --> 00:10:23,440
and that's now my module path.

00:10:24,320 --> 00:10:27,280
If I decide to publish my module for other developers to use

00:10:28,000 --> 00:10:30,560
that module path is how Go will find my code

00:10:30,560 --> 00:10:33,360
to download it when they need it for compiling.

00:10:34,000 --> 00:10:36,560
For example, I'm now importing the "quote" package

00:10:36,560 --> 00:10:39,520
but I don't yet have the package's code to compile with.

00:10:39,520 --> 00:10:42,800
To get it, I'll run "go get"— that Go command I mentioned earlier.

00:10:44,880 --> 00:10:48,560
Go went looking for a source for the packages I'm importing.

00:10:48,560 --> 00:10:53,600
The command downloaded the latest version of Russ's "quote" module

00:10:53,600 --> 00:10:56,080
which for v1 is 1.5.2.

00:10:56,080 --> 00:10:59,840
It also made a change to my go.mod file.

00:11:01,840 --> 00:11:05,600
The file includes this "require" directive down at the bottom now

00:11:05,600 --> 00:11:06,800
and that directive says

00:11:06,800 --> 00:11:11,200
that my module requires the "quote" module at a minimum version of 1.5.2.

00:11:11,920 --> 00:11:13,840
Now I'll run my code again.

00:11:19,360 --> 00:11:23,200
So that's Russ's "hello" function printing "Hello, World!"

00:11:24,000 --> 00:11:25,920
This is a common sequence in Go.

00:11:25,920 --> 00:11:28,080
You start some code and create a module.

00:11:28,080 --> 00:11:30,880
If you need it, you find a useful package

00:11:30,880 --> 00:11:33,840
and then you run "go get" to get source code to build with.

00:11:33,840 --> 00:11:37,360
The go.mod file helps me manage my dependencies.

00:11:37,360 --> 00:11:39,040
In that "require" directive

00:11:39,040 --> 00:11:42,560
if I change the "quote" module's minimum version to 1.5.0

00:11:43,360 --> 00:11:45,600
Go will downgrade the dependency.

00:11:45,600 --> 00:11:47,040
It's the same for upgrading.

00:11:47,760 --> 00:11:50,720
So, I got Go installed and I got "Hello, World!" running.

00:11:50,720 --> 00:11:54,720
I put my code in a module and I started using an external package.

00:11:55,360 --> 00:11:57,920
I'll finish up by showing one of the things Go does best.

00:11:58,480 --> 00:12:01,920
I'll make a "Hello, World!" idea and turn it into a web service.

00:12:03,920 --> 00:12:07,200
Web-based apps are some of the easiest to build with Go.

00:12:07,200 --> 00:12:10,560
That includes HTTP servers and web services.

00:12:10,560 --> 00:12:15,520
I'll change my code so that when someone makes a call to a specific URL

00:12:15,520 --> 00:12:19,280
I'll return JSON with the "Hello, World!" greeting in three languages.

00:12:21,040 --> 00:12:23,840
I'll start by declaring a struct to hold the response data.

00:12:29,280 --> 00:12:31,200
A struct is a collection of fields

00:12:31,200 --> 00:12:34,240
so it gives me a way to group together my greeting text

00:12:34,240 --> 00:12:36,160
the language, and a language code.

00:12:36,880 --> 00:12:39,920
Notice those string literals in the text, the green text there.

00:12:41,680 --> 00:12:43,040
Those are called struct tags.

00:12:44,880 --> 00:12:47,120
Each one specifies the JSON field name

00:12:47,120 --> 00:12:50,000
that will be used in the output, the response value.

00:12:50,000 --> 00:12:51,440
That gives me a way to ensure

00:12:51,440 --> 00:12:54,800
that generated JSON fields have lowercase names.

00:12:54,800 --> 00:12:57,680
Otherwise, Go would use the struct field names

00:12:57,680 --> 00:12:58,640
which are capitalized.

00:12:59,200 --> 00:13:01,840
In Go, you capitalize a field or function name

00:13:01,840 --> 00:13:04,480
when you want it to be visible outside the package it's in.

00:13:05,120 --> 00:13:07,680
In this case, the Go code outside my package

00:13:07,680 --> 00:13:09,840
that creates JSON from my struct

00:13:09,840 --> 00:13:13,120
needs access it can only have if the field name is capitalized.

00:13:13,680 --> 00:13:16,800
Lowercase field and function names aren't visible outside the package.

00:13:18,080 --> 00:13:20,880
Next I'll declare a slice to hold the multiple greetings.

00:13:23,760 --> 00:13:28,480
A slice is a Go ray whose size changes as I add and remove items.

00:13:28,480 --> 00:13:29,680
This slice gives me a way

00:13:29,680 --> 00:13:34,160
to collect multiple structs, one for each language.

00:13:34,160 --> 00:13:37,920
Now I need a function to do something when the requests come over HTTP.

00:13:41,040 --> 00:13:44,080
So, I will add a "Handler."

00:13:45,680 --> 00:13:50,400
I'm adding a "helloHandler" function whose parameters represent the request

00:13:50,400 --> 00:13:51,680
and the response I'll create.

00:13:52,240 --> 00:13:58,880
Both the response writer and the request type are part of the HTTP package

00:13:59,520 --> 00:14:01,120
that's in the Go standard library.

00:14:01,680 --> 00:14:06,400
The HTTP package is one of the reasons it's so easy to write web services in Go.

00:14:06,400 --> 00:14:10,160
It includes functions for making requests over HTTP methods

00:14:10,160 --> 00:14:14,720
handling responses in headers, and other low-level aspects of HTTP.

00:14:15,600 --> 00:14:18,640
Check out the talk by Julie Qiu and Rebecca Stambler

00:14:18,640 --> 00:14:21,360
for more about using the package to set up a web server.

00:14:22,720 --> 00:14:24,640
Inside the Handler function

00:14:24,640 --> 00:14:28,000
my Handler function encodes the contents of the greeting slice

00:14:28,000 --> 00:14:30,320
into JSON for use as a response.

00:14:31,040 --> 00:14:35,040
To do that, it uses an encoder type from the JSON package

00:14:35,040 --> 00:14:37,360
which is also included in the standard library.

00:14:38,400 --> 00:14:41,440
I'm using SetIndent to set an indent string

00:14:41,440 --> 00:14:43,840
so the response is a little bit nicer to look at.

00:14:45,680 --> 00:14:46,800
Before I finish the code

00:14:46,800 --> 00:14:49,760
I want to mention the ":=" operator I'm using here.

00:14:50,560 --> 00:14:52,320
You use it to declare a variable

00:14:52,320 --> 00:14:54,560
and assign it a value in one line of code.

00:14:55,120 --> 00:14:57,920
You don't need to declare the variable's type.

00:14:57,920 --> 00:14:59,280
Go figures that out for you.

00:14:59,840 --> 00:15:02,880
I like it because it's a great example of how Go's design

00:15:02,880 --> 00:15:04,720
keeps things simple and uncluttered.

00:15:05,440 --> 00:15:08,480
Now, to put it all together so the service starts when I run the code.

00:15:09,840 --> 00:15:11,680
I'll update my main function

00:15:11,680 --> 00:15:16,560
and replace what I was doing before with this.

00:15:17,120 --> 00:15:20,560
I'm calling "HandleFunc" to map a URL path

00:15:20,560 --> 00:15:22,160
to the Handler function I just wrote.

00:15:22,800 --> 00:15:25,840
When a request comes in on "/hello"

00:15:27,040 --> 00:15:30,800
the "helloHandler" function will be used to handle the request.

00:15:32,000 --> 00:15:37,760
Then I'll call "ListenAndServe" to start a server that listens on port 8080.

00:15:38,560 --> 00:15:41,440
Ordinarily, ListenAndServe just starts and runs

00:15:41,440 --> 00:15:42,880
without returning a value

00:15:42,880 --> 00:15:45,040
but if it returns an error, I want to handle that.

00:15:45,760 --> 00:15:49,680
The fatal function in a standard library's log package

00:15:49,680 --> 00:15:50,960
will log the error and exit.

00:15:51,840 --> 00:15:53,840
Now I'll run the code.

00:15:59,120 --> 00:16:01,200
And "go run hello.go."

00:16:01,920 --> 00:16:04,480
OK, so apparently I'm not quite finished yet.

00:16:05,360 --> 00:16:07,360
It looks like this command's output tells me

00:16:07,360 --> 00:16:10,160
that I'm importing two packages that I'm not using

00:16:10,720 --> 00:16:14,240
and trying to use three packages that I'm not importing

00:16:14,240 --> 00:16:19,680
so I'm importing "fmt" and "rsc.io/quote" and not using them

00:16:19,680 --> 00:16:23,200
and I'm trying to use HTTP, JSON, and log.

00:16:23,920 --> 00:16:26,480
So, let's take a look at the code here.

00:16:26,480 --> 00:16:29,680
Here's where I'm commenting "fmt" and "quote."

00:16:30,640 --> 00:16:33,760
So, I need to update my imports to account for that.

00:16:34,560 --> 00:16:35,840
So, let's fix that

00:16:38,800 --> 00:16:41,200
by pasting in some new imports.

00:16:41,200 --> 00:16:45,040
I'm going to combine the imports into a block

00:16:45,040 --> 00:16:47,280
using a single import statement.

00:16:47,920 --> 00:16:49,680
This is something I could've done earlier.

00:16:49,680 --> 00:16:50,640
I just didn't.

00:16:55,040 --> 00:16:56,720
So, now I'll try to run the code again.

00:16:57,920 --> 00:17:03,840
I feel a little bit better about it this time.

00:17:04,800 --> 00:17:06,640
OK, so the service is now running.

00:17:07,440 --> 00:17:09,760
I'll open another command prompt to try it out

00:17:14,880 --> 00:17:18,320
and I will curl "localhost:8080/hello."

00:17:23,600 --> 00:17:24,720
It looks like it's working now

00:17:24,720 --> 00:17:27,840
so I've got a snippet of JSON

00:17:27,840 --> 00:17:30,480
with my "Hello, World!" messages in three languages

00:17:31,200 --> 00:17:35,120
and I got this going by using only packages from Go's standard library.

00:17:35,120 --> 00:17:36,400
There are external packages

00:17:36,400 --> 00:17:39,600
that have more web service features and might be as easy to use.

00:17:40,320 --> 00:17:43,360
If I wanted, I could find those using the package discovery site.

00:17:44,720 --> 00:17:46,480
So, that's all I have to show today.

00:17:46,480 --> 00:17:51,440
You can find lots more about Go at golang.org, go.dev, and all over the web.

00:17:52,400 --> 00:17:56,000
If you're interested in support for Go, in editors, in IDEs

00:17:56,000 --> 00:17:58,160
as well as Go's package discovery tools

00:17:58,160 --> 00:18:01,760
be sure to check out the talk by Julie Qiu and Rebecca Stambler.

00:18:01,760 --> 00:18:13,520

YouTube URL: https://www.youtube.com/watch?v=wyF6m10kxjI


