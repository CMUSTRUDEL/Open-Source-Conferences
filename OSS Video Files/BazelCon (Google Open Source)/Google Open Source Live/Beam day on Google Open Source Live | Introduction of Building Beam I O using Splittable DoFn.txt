Title: Beam day on Google Open Source Live | Introduction of Building Beam I O using Splittable DoFn
Publication date: 2021-05-06
Playlist: Google Open Source Live
Description: 
	
Captions: 
	00:00:00,790 --> 00:00:08,360
[Music]

00:00:10,719 --> 00:00:14,639
um hello everyone

00:00:12,160 --> 00:00:16,320
i'm boyan from google cloud dataflow

00:00:14,639 --> 00:00:17,359
today i'm going to give a brief

00:00:16,320 --> 00:00:19,840
introduction

00:00:17,359 --> 00:00:20,960
about how to build source in bing with

00:00:19,840 --> 00:00:23,920
the vadoo phone

00:00:20,960 --> 00:00:25,760
when we get into details first i will

00:00:23,920 --> 00:00:26,720
introduce a little bit more on what is

00:00:25,760 --> 00:00:30,320
being sourced

00:00:26,720 --> 00:00:32,399
and what this will do for

00:00:30,320 --> 00:00:33,840
most bim pipelines are reading from

00:00:32,399 --> 00:00:35,920
external sources

00:00:33,840 --> 00:00:38,320
and get this output record from the

00:00:35,920 --> 00:00:40,960
source and do certain computations

00:00:38,320 --> 00:00:42,559
and write a computation result into sync

00:00:40,960 --> 00:00:44,879
so take a word called pipeline

00:00:42,559 --> 00:00:45,680
as example i have put the pipeline ships

00:00:44,879 --> 00:00:47,200
on the right

00:00:45,680 --> 00:00:49,039
so you can see that what's called

00:00:47,200 --> 00:00:52,640
pipeline read the

00:00:49,039 --> 00:00:55,840
text file from external source and then

00:00:52,640 --> 00:00:58,000
get to the each word from the text and

00:00:55,840 --> 00:01:00,160
do a count pro word and directly

00:00:58,000 --> 00:01:02,480
resulting to the sink

00:01:00,160 --> 00:01:04,640
so as you can see mostly the beam source

00:01:02,480 --> 00:01:07,040
will be the root node of the pipeline

00:01:04,640 --> 00:01:08,479
and before we introduce superbowl dew

00:01:07,040 --> 00:01:10,720
phone into bin

00:01:08,479 --> 00:01:12,240
we already have one data source api for

00:01:10,720 --> 00:01:14,080
batch pipeline and

00:01:12,240 --> 00:01:16,880
unbounded source api for streaming

00:01:14,080 --> 00:01:19,600
pipeline so for example in this case

00:01:16,880 --> 00:01:20,799
the text io is a boundary source and for

00:01:19,600 --> 00:01:24,400
example

00:01:20,799 --> 00:01:26,560
kafka is a streaming source usually

00:01:24,400 --> 00:01:27,520
when we read from bounty source we want

00:01:26,560 --> 00:01:30,159
to read as

00:01:27,520 --> 00:01:32,079
fast as we can so what we can do is we

00:01:30,159 --> 00:01:35,119
can have multiple parallelisms

00:01:32,079 --> 00:01:36,240
while we do the reading so there are two

00:01:35,119 --> 00:01:38,479
kinds of splits

00:01:36,240 --> 00:01:40,640
the first one is initial split and the

00:01:38,479 --> 00:01:42,960
second one is dynamic split

00:01:40,640 --> 00:01:44,000
initial split will give us initial

00:01:42,960 --> 00:01:46,399
parallelisms

00:01:44,000 --> 00:01:48,320
before we actually reading so still use

00:01:46,399 --> 00:01:50,720
a text our example

00:01:48,320 --> 00:01:51,920
uh we have a text file right and we want

00:01:50,720 --> 00:01:54,079
to read that file

00:01:51,920 --> 00:01:56,240
and if we know that we have two other

00:01:54,079 --> 00:01:58,640
workers before we actually read

00:01:56,240 --> 00:02:00,799
we actually can split the text into two

00:01:58,640 --> 00:02:02,320
charts and we can have these two workers

00:02:00,799 --> 00:02:04,320
read from these two charts

00:02:02,320 --> 00:02:06,719
in parallel then we will have the read

00:02:04,320 --> 00:02:08,959
faster and dynamic split means

00:02:06,719 --> 00:02:11,599
we want to split it happens during where

00:02:08,959 --> 00:02:14,239
we during we are doing the reading

00:02:11,599 --> 00:02:16,640
and that split happens in the future so

00:02:14,239 --> 00:02:19,520
this one will give us more parallelisms

00:02:16,640 --> 00:02:21,440
during we're doing the reading so in

00:02:19,520 --> 00:02:23,440
order to do the dynamic split

00:02:21,440 --> 00:02:25,120
we actually need the boundary source to

00:02:23,440 --> 00:02:25,680
do the initial sizing for the whole

00:02:25,120 --> 00:02:27,920
source

00:02:25,680 --> 00:02:29,120
this will give a boundary and assess and

00:02:27,920 --> 00:02:31,280
the size information

00:02:29,120 --> 00:02:32,959
of this source to the runners this will

00:02:31,280 --> 00:02:37,040
help the runners to make this

00:02:32,959 --> 00:02:38,800
a split decision and during the reading

00:02:37,040 --> 00:02:41,200
we also wanted the bonding source to

00:02:38,800 --> 00:02:43,760
able to be able to report the progress

00:02:41,200 --> 00:02:45,120
this is uh that means we want the uh the

00:02:43,760 --> 00:02:47,040
runners will need to know

00:02:45,120 --> 00:02:48,640
how much the boundary source has read

00:02:47,040 --> 00:02:50,640
and how much work left

00:02:48,640 --> 00:02:51,760
from that for that boundary source it's

00:02:50,640 --> 00:02:53,760
also used for

00:02:51,760 --> 00:02:56,319
signals for the runners to make a split

00:02:53,760 --> 00:02:58,159
decision and finally once the time that

00:02:56,319 --> 00:03:00,000
runners want to issue a split

00:02:58,159 --> 00:03:02,000
the bonding source should be able to

00:03:00,000 --> 00:03:04,319
perform that split for the source

00:03:02,000 --> 00:03:05,200
and to gain more parallelisms usually

00:03:04,319 --> 00:03:07,120
for streaming

00:03:05,200 --> 00:03:08,560
we actually are able to perform the

00:03:07,120 --> 00:03:10,319
initial splits as well

00:03:08,560 --> 00:03:12,800
but it's not really possible to do the

00:03:10,319 --> 00:03:14,720
dynamic split it's easy to understand

00:03:12,800 --> 00:03:16,879
why we are not able to do so

00:03:14,720 --> 00:03:18,319
is because first it's unbounded source

00:03:16,879 --> 00:03:20,800
it doesn't have the boundary

00:03:18,319 --> 00:03:22,640
and the second because for the dynamic

00:03:20,800 --> 00:03:23,440
splits we usually want to split in the

00:03:22,640 --> 00:03:26,720
future

00:03:23,440 --> 00:03:28,239
and it's not very known that's for the

00:03:26,720 --> 00:03:30,319
unbounded source whether we will have

00:03:28,239 --> 00:03:30,799
the future so usually we will not do

00:03:30,319 --> 00:03:32,640
that

00:03:30,799 --> 00:03:33,840
but instead we will do the checkpoint

00:03:32,640 --> 00:03:35,840
for this source and

00:03:33,840 --> 00:03:37,440
the most important things for unbounded

00:03:35,840 --> 00:03:39,680
source is we want

00:03:37,440 --> 00:03:40,560
the body source to check the watermark

00:03:39,680 --> 00:03:42,560
correctly

00:03:40,560 --> 00:03:44,159
especially when there are several

00:03:42,560 --> 00:03:46,560
downstream operations have a

00:03:44,159 --> 00:03:47,519
complicated window strategy and do the

00:03:46,560 --> 00:03:49,280
triggers on that

00:03:47,519 --> 00:03:51,840
so that's very important for unbounded

00:03:49,280 --> 00:03:52,959
source so given that we already have the

00:03:51,840 --> 00:03:55,760
boundary source api

00:03:52,959 --> 00:03:56,319
and bonded source apis for the beam

00:03:55,760 --> 00:03:58,239
source

00:03:56,319 --> 00:03:59,920
why st why we still want to introduce

00:03:58,239 --> 00:04:02,959
the new superpower to file

00:03:59,920 --> 00:04:05,360
apis in tubing so the most

00:04:02,959 --> 00:04:06,400
important part for here is as i

00:04:05,360 --> 00:04:08,720
mentioned as

00:04:06,400 --> 00:04:10,480
based on our current framework we should

00:04:08,720 --> 00:04:11,280
have the bing source as a root node

00:04:10,480 --> 00:04:13,360
pipeline

00:04:11,280 --> 00:04:14,879
then we will have the use case like for

00:04:13,360 --> 00:04:16,639
example you have if i have two

00:04:14,879 --> 00:04:19,359
external source which is the corey and

00:04:16,639 --> 00:04:20,479
kafka and i store the topic partitions

00:04:19,359 --> 00:04:23,120
on the bigquery

00:04:20,479 --> 00:04:25,120
and first i need to i need to know which

00:04:23,120 --> 00:04:26,160
topic and partition i can read from from

00:04:25,120 --> 00:04:28,880
the bigquery

00:04:26,160 --> 00:04:30,960
and then read from kafka if i want to do

00:04:28,880 --> 00:04:33,120
all of the things inside one pipeline

00:04:30,960 --> 00:04:34,880
then there's no way in current bonding

00:04:33,120 --> 00:04:37,040
source and the bonding source apis

00:04:34,880 --> 00:04:38,000
to do because it has to be the roots

00:04:37,040 --> 00:04:41,120
node but

00:04:38,000 --> 00:04:41,600
then with the 342 file we are able to do

00:04:41,120 --> 00:04:44,000
so

00:04:41,600 --> 00:04:45,600
so we can first read from the bigquery

00:04:44,000 --> 00:04:47,840
get a topic partition

00:04:45,600 --> 00:04:49,360
and then let the read from kafka to read

00:04:47,840 --> 00:04:52,080
from that topic partition

00:04:49,360 --> 00:04:53,360
and output records the reason why super

00:04:52,080 --> 00:04:55,120
duper can do so

00:04:53,360 --> 00:04:56,880
is because the bible too far is a two

00:04:55,120 --> 00:04:58,400
phone and the two phone can be any nodes

00:04:56,880 --> 00:05:01,120
of the pipeline

00:04:58,400 --> 00:05:02,960
and the second part is superbowl2fun is

00:05:01,120 --> 00:05:03,600
a unified biochannel streaming source

00:05:02,960 --> 00:05:06,080
model

00:05:03,600 --> 00:05:08,080
over phone api execution file api

00:05:06,080 --> 00:05:10,320
execution is a new execution model we

00:05:08,080 --> 00:05:12,000
introduced to bim literally it's kind of

00:05:10,320 --> 00:05:14,160
like a complicated concept

00:05:12,000 --> 00:05:17,520
so i will not go into details in this

00:05:14,160 --> 00:05:19,759
slide but i put a intro but i'll put a

00:05:17,520 --> 00:05:20,560
link related to that at the end of the

00:05:19,759 --> 00:05:22,720
slide

00:05:20,560 --> 00:05:24,000
and the third one is we will have the

00:05:22,720 --> 00:05:26,560
ability to split

00:05:24,000 --> 00:05:27,199
for a split bottle different so that

00:05:26,560 --> 00:05:29,680
means

00:05:27,199 --> 00:05:31,280
we can provide both initial split and

00:05:29,680 --> 00:05:33,680
dynamic sphere for bonding source

00:05:31,280 --> 00:05:35,680
so it's perfect for that one and for

00:05:33,680 --> 00:05:38,400
more details about what split means

00:05:35,680 --> 00:05:40,320
we will go into deeper in uh in the

00:05:38,400 --> 00:05:42,800
following slides

00:05:40,320 --> 00:05:43,520
and the last one is civil dufferin is a

00:05:42,800 --> 00:05:45,759
dew phone

00:05:43,520 --> 00:05:47,120
right so it will have a simple syntax as

00:05:45,759 --> 00:05:48,880
doofan and the most

00:05:47,120 --> 00:05:50,800
bing devs are familiar with two phones

00:05:48,880 --> 00:05:52,639
so it will be simpler simpler and

00:05:50,800 --> 00:05:53,840
straightforward for them to build their

00:05:52,639 --> 00:05:56,160
own sauce on

00:05:53,840 --> 00:05:56,880
top of this building and one more

00:05:56,160 --> 00:05:59,600
interesting things

00:05:56,880 --> 00:06:01,680
around that is if you are building your

00:05:59,600 --> 00:06:03,440
own cells on top of super duper

00:06:01,680 --> 00:06:05,600
then all you need to do is have one

00:06:03,440 --> 00:06:07,280
implementation which should be work for

00:06:05,600 --> 00:06:09,840
both streaming and batch

00:06:07,280 --> 00:06:11,759
instead of uh in the unbounded source

00:06:09,840 --> 00:06:13,759
and multi-source api

00:06:11,759 --> 00:06:14,880
what you have to do is you have to write

00:06:13,759 --> 00:06:16,800
invitation

00:06:14,880 --> 00:06:18,080
derived from bonding source api for

00:06:16,800 --> 00:06:19,759
batch pipeline and

00:06:18,080 --> 00:06:21,280
write another implementation derived

00:06:19,759 --> 00:06:22,880
from a multi-source api

00:06:21,280 --> 00:06:25,280
for streaming pipeline that's kind of

00:06:22,880 --> 00:06:25,680
like this burden for most developers to

00:06:25,280 --> 00:06:27,759
do

00:06:25,680 --> 00:06:30,080
to do two implementations for different

00:06:27,759 --> 00:06:32,319
purpose

00:06:30,080 --> 00:06:34,400
so given that we already know that's why

00:06:32,319 --> 00:06:36,800
we want to have a spiritual phone

00:06:34,400 --> 00:06:38,960
then what it will do from so i would as

00:06:36,800 --> 00:06:41,120
i mentioned many times the bluetooth is

00:06:38,960 --> 00:06:43,360
that you found with the ability to split

00:06:41,120 --> 00:06:45,199
so first it's a new phone it will have

00:06:43,360 --> 00:06:46,560
all sync all simple syntax and

00:06:45,199 --> 00:06:48,400
attributes from different

00:06:46,560 --> 00:06:50,479
and the second it have it will have the

00:06:48,400 --> 00:06:52,880
ability to be able to split

00:06:50,479 --> 00:06:54,639
inside one element so what that means

00:06:52,880 --> 00:06:56,240
split inside one element

00:06:54,639 --> 00:06:58,800
i have to look into uh some more

00:06:56,240 --> 00:06:59,520
examples so let's see we have two

00:06:58,800 --> 00:07:02,080
elements

00:06:59,520 --> 00:07:03,599
element one element two and we have two

00:07:02,080 --> 00:07:04,479
for instance processing these two

00:07:03,599 --> 00:07:06,880
elements

00:07:04,479 --> 00:07:07,599
and we happen to have the first element

00:07:06,880 --> 00:07:09,919
element one

00:07:07,599 --> 00:07:12,880
is super huge and it's heavy and

00:07:09,919 --> 00:07:14,880
currently we are at twenty percent of it

00:07:12,880 --> 00:07:16,000
so let's see for the following eighty

00:07:14,880 --> 00:07:18,000
percent of element

00:07:16,000 --> 00:07:19,120
we still need to take one more day to

00:07:18,000 --> 00:07:20,960
process it

00:07:19,120 --> 00:07:23,280
so if we are using a normal default

00:07:20,960 --> 00:07:24,080
instance what we can do is we have to

00:07:23,280 --> 00:07:25,919
wait for the

00:07:24,080 --> 00:07:28,319
first element to be finished and

00:07:25,919 --> 00:07:31,440
continues to process element two

00:07:28,319 --> 00:07:32,400
so it's it's slow and we have to wait a

00:07:31,440 --> 00:07:34,639
lot of time

00:07:32,400 --> 00:07:36,960
but if we have a support u-fund for that

00:07:34,639 --> 00:07:39,520
what we can do is we can ask the first

00:07:36,960 --> 00:07:41,759
split uh the first element to split

00:07:39,520 --> 00:07:44,000
so that means we can say i want you

00:07:41,759 --> 00:07:44,879
first element to split at the 50 percent

00:07:44,000 --> 00:07:47,680
of you

00:07:44,879 --> 00:07:49,199
then we will have the uh first half of

00:07:47,680 --> 00:07:51,919
the first element on the

00:07:49,199 --> 00:07:53,520
first display instance and then we can

00:07:51,919 --> 00:07:56,240
have the second half of the

00:07:53,520 --> 00:07:58,240
of the element one and the whole element

00:07:56,240 --> 00:07:59,120
two to be rescheduled on another

00:07:58,240 --> 00:08:01,199
instance

00:07:59,120 --> 00:08:02,319
at this moment we will have twos we will

00:08:01,199 --> 00:08:04,720
do for instance

00:08:02,319 --> 00:08:06,879
work working on this two out or two and

00:08:04,720 --> 00:08:09,280
working on this two chart in parallel

00:08:06,879 --> 00:08:10,840
so that means we we should have the

00:08:09,280 --> 00:08:14,479
pipeline to be much

00:08:10,840 --> 00:08:17,120
faster so as you can see it's very

00:08:14,479 --> 00:08:18,000
powerful and it's very useful for batch

00:08:17,120 --> 00:08:20,000
then

00:08:18,000 --> 00:08:21,599
what we should think about when we when

00:08:20,000 --> 00:08:23,440
we're building super bowl dufferin

00:08:21,599 --> 00:08:25,120
the first one is the element and

00:08:23,440 --> 00:08:27,680
restriction

00:08:25,120 --> 00:08:29,360
usually they uh scroll to file is a

00:08:27,680 --> 00:08:32,080
different right so it will take a

00:08:29,360 --> 00:08:32,880
input as element and output several

00:08:32,080 --> 00:08:35,839
records

00:08:32,880 --> 00:08:38,399
so the element here is the input and the

00:08:35,839 --> 00:08:40,560
restriction usually is a description of

00:08:38,399 --> 00:08:42,159
to describe how much work inside us

00:08:40,560 --> 00:08:44,399
inside that element

00:08:42,159 --> 00:08:45,760
so taking examples through different on

00:08:44,399 --> 00:08:48,160
the right as example

00:08:45,760 --> 00:08:50,160
let's say we have a string of abcd as

00:08:48,160 --> 00:08:52,800
input to that spiritual form

00:08:50,160 --> 00:08:54,480
and what this building will do is it

00:08:52,800 --> 00:08:57,839
will output characters

00:08:54,480 --> 00:08:59,920
a b c d separately in this case the

00:08:57,839 --> 00:09:03,200
element will be the input string

00:08:59,920 --> 00:09:04,959
which is a b c d and i will if i'm

00:09:03,200 --> 00:09:07,680
writing this kind of super duper

00:09:04,959 --> 00:09:08,000
i will say i want to have a restriction

00:09:07,680 --> 00:09:10,240
which

00:09:08,000 --> 00:09:11,760
can describe how many works in this

00:09:10,240 --> 00:09:15,360
string so i will take

00:09:11,760 --> 00:09:15,839
offset range from 0 to 4 to describe

00:09:15,360 --> 00:09:18,399
that

00:09:15,839 --> 00:09:19,360
that i have a string and the index from

00:09:18,399 --> 00:09:22,560
for this string

00:09:19,360 --> 00:09:23,440
is from 0 to 4. so that's element and

00:09:22,560 --> 00:09:26,000
restriction

00:09:23,440 --> 00:09:28,240
and we also have a restriction tracker

00:09:26,000 --> 00:09:30,880
to check the progress of the restriction

00:09:28,240 --> 00:09:32,880
and for a restriction tracker you should

00:09:30,880 --> 00:09:33,360
know the current consumer position of

00:09:32,880 --> 00:09:35,839
the

00:09:33,360 --> 00:09:37,600
restriction and should know the progress

00:09:35,839 --> 00:09:39,519
and why it's time to do the split

00:09:37,600 --> 00:09:41,040
from the runners and the other

00:09:39,519 --> 00:09:41,600
restriction tracker should be able to do

00:09:41,040 --> 00:09:44,080
so

00:09:41,600 --> 00:09:45,839
a simple example can be let's say we

00:09:44,080 --> 00:09:48,800
still have this kind of d form

00:09:45,839 --> 00:09:49,839
and we already output character a so the

00:09:48,800 --> 00:09:52,320
current position

00:09:49,839 --> 00:09:54,399
is one and the work has been done is

00:09:52,320 --> 00:09:57,120
from zero to one which i have output

00:09:54,399 --> 00:09:58,560
one characters and the work of the

00:09:57,120 --> 00:10:00,800
remaining is from one

00:09:58,560 --> 00:10:01,680
two four that means i still have four

00:10:00,800 --> 00:10:06,320
characters

00:10:01,680 --> 00:10:06,320
three characters left to output

00:10:06,880 --> 00:10:11,360
combining all the information about uh

00:10:09,600 --> 00:10:12,640
including what is boundary source and

00:10:11,360 --> 00:10:15,360
bonding source requires

00:10:12,640 --> 00:10:16,560
and what is what dupont can provide now

00:10:15,360 --> 00:10:18,560
we can think about

00:10:16,560 --> 00:10:19,600
when it's time to build a source on top

00:10:18,560 --> 00:10:21,760
of spro dew farm

00:10:19,600 --> 00:10:23,760
what we should think about the first

00:10:21,760 --> 00:10:25,360
question is we should decide what

00:10:23,760 --> 00:10:27,839
what is element and what is the

00:10:25,360 --> 00:10:28,160
restriction it's important to pick up

00:10:27,839 --> 00:10:31,040
the

00:10:28,160 --> 00:10:32,480
suitable element and the restriction for

00:10:31,040 --> 00:10:34,800
your source because it

00:10:32,480 --> 00:10:36,800
will it will affect the implementation

00:10:34,800 --> 00:10:39,519
details of our source

00:10:36,800 --> 00:10:41,360
and the second is we should consider

00:10:39,519 --> 00:10:42,399
what kind of split we want to support

00:10:41,360 --> 00:10:44,480
for our source

00:10:42,399 --> 00:10:45,760
as we know that for bonding source it's

00:10:44,480 --> 00:10:48,000
always good to have

00:10:45,760 --> 00:10:49,839
to have good initial to have initial

00:10:48,000 --> 00:10:52,480
split and dynamic split

00:10:49,839 --> 00:10:54,079
and for streaming it it is also always

00:10:52,480 --> 00:10:56,720
good having natural splits

00:10:54,079 --> 00:10:58,160
and to be able to do the checkpointing

00:10:56,720 --> 00:10:59,279
and third one is for streaming

00:10:58,160 --> 00:11:01,839
specifically

00:10:59,279 --> 00:11:04,079
is if i'm writing a source for streaming

00:11:01,839 --> 00:11:06,000
i need to make sure whether i track

00:11:04,079 --> 00:11:07,600
under the one's daughter more correctly

00:11:06,000 --> 00:11:09,200
and i need to make sure i did

00:11:07,600 --> 00:11:11,760
i don't hold back the watermark

00:11:09,200 --> 00:11:12,079
incorrectly to affect the pipeline sort

00:11:11,760 --> 00:11:15,839
to

00:11:12,079 --> 00:11:15,839
affect the pipeline results

00:11:15,920 --> 00:11:20,480
so the first question what is the

00:11:18,320 --> 00:11:23,120
element and what is the restriction

00:11:20,480 --> 00:11:25,040
so you relay for source the element can

00:11:23,120 --> 00:11:27,600
be the metadata of the source

00:11:25,040 --> 00:11:28,320
and the restriction can be the

00:11:27,600 --> 00:11:30,560
description

00:11:28,320 --> 00:11:31,760
to describe how much work in this

00:11:30,560 --> 00:11:34,640
metadata

00:11:31,760 --> 00:11:35,360
so taking textile as example for textile

00:11:34,640 --> 00:11:38,560
we can use

00:11:35,360 --> 00:11:39,760
file name as the element for example i

00:11:38,560 --> 00:11:43,519
want to read from

00:11:39,760 --> 00:11:46,560
file1 text right and for the restriction

00:11:43,519 --> 00:11:49,440
we can use a offset range from

00:11:46,560 --> 00:11:50,240
0 to the total lines of the text as a

00:11:49,440 --> 00:11:52,160
restriction

00:11:50,240 --> 00:11:53,839
so that will describe the whole work in

00:11:52,160 --> 00:11:55,760
such as file

00:11:53,839 --> 00:11:58,399
and another example is reading from

00:11:55,760 --> 00:11:59,680
kafka we know that kafka euler is from

00:11:58,399 --> 00:12:02,320
atopic partitions

00:11:59,680 --> 00:12:03,760
and it will output records with offset

00:12:02,320 --> 00:12:06,480
in that case we can

00:12:03,760 --> 00:12:08,959
use topic partition as element and we

00:12:06,480 --> 00:12:10,000
can also use offset range from zero to

00:12:08,959 --> 00:12:12,480
infinity

00:12:10,000 --> 00:12:14,959
to describe the total workload inside

00:12:12,480 --> 00:12:17,839
for that topic and partition

00:12:14,959 --> 00:12:18,880
then it's time to think about whether we

00:12:17,839 --> 00:12:22,560
can do

00:12:18,880 --> 00:12:26,079
whether we can do for initial split

00:12:22,560 --> 00:12:28,240
so that means uh if if we uh that means

00:12:26,079 --> 00:12:30,800
if we know that our source can do the

00:12:28,240 --> 00:12:33,120
initial split it's always good to do so

00:12:30,800 --> 00:12:34,079
if you if we have decided we want to do

00:12:33,120 --> 00:12:36,000
the initial splits

00:12:34,079 --> 00:12:37,279
the only things we need to do is we can

00:12:36,000 --> 00:12:39,760
create a function

00:12:37,279 --> 00:12:41,839
in the do fun and annotates the function

00:12:39,760 --> 00:12:44,720
with bit restriction annotation

00:12:41,839 --> 00:12:46,560
the sdk framework will pick up this

00:12:44,720 --> 00:12:47,519
function to perform initial splits when

00:12:46,560 --> 00:12:51,040
it's time to do so

00:12:47,519 --> 00:12:52,880
automatically so for example we still

00:12:51,040 --> 00:12:55,839
use the textile

00:12:52,880 --> 00:12:58,160
right so the element is a file name and

00:12:55,839 --> 00:13:01,200
let's say we have timelines for that

00:12:58,160 --> 00:13:03,600
of text file and we want to read the

00:13:01,200 --> 00:13:05,600
text file one line by one line so in

00:13:03,600 --> 00:13:06,480
this case the restriction will be 0 to

00:13:05,600 --> 00:13:09,680
00:13:06,480 --> 00:13:12,320
and i already know that

00:13:09,680 --> 00:13:14,639
i will have two workers to be able to

00:13:12,320 --> 00:13:17,200
read from two charts in parallel

00:13:14,639 --> 00:13:18,079
from the start so i can split the

00:13:17,200 --> 00:13:22,000
restriction

00:13:18,079 --> 00:13:23,920
from 0 to 5 and 5 to 10 and the runners

00:13:22,000 --> 00:13:25,680
before the reads the runners will

00:13:23,920 --> 00:13:27,839
redistribute these two chart

00:13:25,680 --> 00:13:29,920
on these two workers and we will have

00:13:27,839 --> 00:13:33,120
the rate on these two workers in

00:13:29,920 --> 00:13:33,120
parallel at the same time

00:13:33,839 --> 00:13:37,279
during the actual reading happens uh

00:13:36,560 --> 00:13:39,279
which

00:13:37,279 --> 00:13:41,279
we should think about whether we want to

00:13:39,279 --> 00:13:43,760
provide more information to runners

00:13:41,279 --> 00:13:45,760
that's progress so in terms of progress

00:13:43,760 --> 00:13:48,399
it always describes how much work

00:13:45,760 --> 00:13:50,560
we have been done and how much work has

00:13:48,399 --> 00:13:53,279
been left for this source

00:13:50,560 --> 00:13:54,880
for batch is a useful signal to make a

00:13:53,279 --> 00:13:57,600
dynamic split decision

00:13:54,880 --> 00:13:58,959
and for streaming is useful to let the

00:13:57,600 --> 00:14:01,760
runner know the backlog

00:13:58,959 --> 00:14:04,079
especially for data flow data flow will

00:14:01,760 --> 00:14:06,320
use a backlog to determine whether to

00:14:04,079 --> 00:14:07,920
bring up more workers to work on the

00:14:06,320 --> 00:14:09,600
source so that means if

00:14:07,920 --> 00:14:11,120
we can let the runner knows we still

00:14:09,600 --> 00:14:13,199
have a lot of work to do

00:14:11,120 --> 00:14:14,160
the work uh the data flow can bring up

00:14:13,199 --> 00:14:16,079
more workers

00:14:14,160 --> 00:14:17,519
we will have our streaming pipelines

00:14:16,079 --> 00:14:19,680
faster

00:14:17,519 --> 00:14:21,040
so for the progress let's still use the

00:14:19,680 --> 00:14:22,480
uh textile example

00:14:21,040 --> 00:14:24,639
so let's say we are reading the first

00:14:22,480 --> 00:14:25,120
chart of the text so we have the file

00:14:24,639 --> 00:14:27,279
name as

00:14:25,120 --> 00:14:28,720
element again and it has the first chart

00:14:27,279 --> 00:14:31,120
which is from five

00:14:28,720 --> 00:14:32,560
zero to five and let's say we have

00:14:31,120 --> 00:14:34,959
output the first line

00:14:32,560 --> 00:14:36,240
so at this moment the progress the

00:14:34,959 --> 00:14:38,480
progress is kind of like

00:14:36,240 --> 00:14:40,959
the work has been done is we have output

00:14:38,480 --> 00:14:43,600
one line which is from zero to ten

00:14:40,959 --> 00:14:44,079
always from zero to one and they work

00:14:43,600 --> 00:14:47,519
left

00:14:44,079 --> 00:14:49,680
is from one two one to four one to five

00:14:47,519 --> 00:14:52,000
which means we still have uh four lines

00:14:49,680 --> 00:14:54,560
to be outputted

00:14:52,000 --> 00:14:56,880
and when the runners issue split you lay

00:14:54,560 --> 00:14:58,880
for batch is dynamic split to gain more

00:14:56,880 --> 00:15:00,079
parallelisms and the first streaming is

00:14:58,880 --> 00:15:02,000
usually check pointing

00:15:00,079 --> 00:15:03,680
which means uranus wants us to stop

00:15:02,000 --> 00:15:05,360
reading as soon as possible

00:15:03,680 --> 00:15:07,279
and the return whatever we have to the

00:15:05,360 --> 00:15:09,760
runners so for the

00:15:07,279 --> 00:15:11,199
dynamic split let's say after we give

00:15:09,760 --> 00:15:13,519
the progress to the runners

00:15:11,199 --> 00:15:15,839
and the runner says i want you to split

00:15:13,519 --> 00:15:18,639
at 50 percent of the remaining

00:15:15,839 --> 00:15:19,839
element so that means uh for the current

00:15:18,639 --> 00:15:22,959
remaining work which is

00:15:19,839 --> 00:15:25,279
from one to four one two ah five

00:15:22,959 --> 00:15:26,959
the uh runner one has two speeds split

00:15:25,279 --> 00:15:29,600
at fifty percent of it

00:15:26,959 --> 00:15:30,560
so that means uh in the current instance

00:15:29,600 --> 00:15:33,600
we will still

00:15:30,560 --> 00:15:35,600
output uh line two and line three and

00:15:33,600 --> 00:15:36,880
we will return restrictions three to

00:15:35,600 --> 00:15:39,279
five to the runners

00:15:36,880 --> 00:15:40,720
and the runner will have another workers

00:15:39,279 --> 00:15:44,079
to work on this chart

00:15:40,720 --> 00:15:46,320
to continuously to output line 4 to

00:15:44,079 --> 00:15:47,600
length 3 to line 4. so that means at

00:15:46,320 --> 00:15:48,480
this moment we will gain more

00:15:47,600 --> 00:15:51,920
parallelisms

00:15:48,480 --> 00:15:54,720
and our pipeline should be faster and

00:15:51,920 --> 00:15:56,079
for streaming because runner 1 has to

00:15:54,720 --> 00:15:58,880
stop reading immediately

00:15:56,079 --> 00:16:00,160
that means after we finish processing

00:15:58,880 --> 00:16:02,399
output first line

00:16:00,160 --> 00:16:03,759
we should stop and return the whole

00:16:02,399 --> 00:16:07,040
remaining restriction

00:16:03,759 --> 00:16:09,360
which is from 0 4 1 2

00:16:07,040 --> 00:16:10,560
five to the runners and the runners will

00:16:09,360 --> 00:16:14,480
have another

00:16:10,560 --> 00:16:14,480
uh workers to work on this chart

00:16:15,279 --> 00:16:18,480
and finally we are going to the

00:16:17,199 --> 00:16:21,600
streaming watermark

00:16:18,480 --> 00:16:22,800
uh set as i mentioned the watermark is

00:16:21,600 --> 00:16:25,519
extremely extremely

00:16:22,800 --> 00:16:27,440
important for uh streaming pipelines

00:16:25,519 --> 00:16:29,759
especially when your pipelines has

00:16:27,440 --> 00:16:30,560
complicated windowing strategy and the

00:16:29,759 --> 00:16:33,279
triggers

00:16:30,560 --> 00:16:35,040
so when we're building our source based

00:16:33,279 --> 00:16:36,880
on spill2fun for streaming

00:16:35,040 --> 00:16:38,320
we should especially care about the

00:16:36,880 --> 00:16:41,199
watermark

00:16:38,320 --> 00:16:44,160
so for watermark uh spro 25 offered a

00:16:41,199 --> 00:16:47,199
utility class called watermark estimator

00:16:44,160 --> 00:16:49,199
for you to estimate the watermark

00:16:47,199 --> 00:16:51,440
from this reward you farm there are

00:16:49,199 --> 00:16:52,000
three common tabs for the water marques

00:16:51,440 --> 00:16:54,639
meter

00:16:52,000 --> 00:16:55,759
the walton monotonically increasing and

00:16:54,639 --> 00:16:58,240
the manual one

00:16:55,759 --> 00:16:59,440
the water and water mark estimator is a

00:16:58,240 --> 00:17:03,040
super straightforward

00:16:59,440 --> 00:17:07,039
it will always use a current processing

00:17:03,040 --> 00:17:09,520
timestamp as the output watermark

00:17:07,039 --> 00:17:11,679
and for monotonically increasing it

00:17:09,520 --> 00:17:14,240
allows you the output tempstamp

00:17:11,679 --> 00:17:15,679
from the records of the output of the

00:17:14,240 --> 00:17:18,480
superduo fund

00:17:15,679 --> 00:17:20,319
and it it expands the time stamp from

00:17:18,480 --> 00:17:23,039
the output of the spell dupont

00:17:20,319 --> 00:17:23,760
to be always increasing monotonically if

00:17:23,039 --> 00:17:26,240
it doesn't

00:17:23,760 --> 00:17:27,360
it will throw exceptions and errors from

00:17:26,240 --> 00:17:30,480
the sdk

00:17:27,360 --> 00:17:32,000
and says i have errors and and i i don't

00:17:30,480 --> 00:17:36,160
want to output more records

00:17:32,000 --> 00:17:39,440
because it has a it has execution arrows

00:17:36,160 --> 00:17:42,559
and for manual one it it gives the uh

00:17:39,440 --> 00:17:44,960
source author the the freedom to

00:17:42,559 --> 00:17:46,320
set the water mark by themselves inside

00:17:44,960 --> 00:17:48,720
of these four different

00:17:46,320 --> 00:17:51,280
methods you can set the watermark to any

00:17:48,720 --> 00:17:53,200
timestamp that makes sense to you

00:17:51,280 --> 00:17:54,559
as long as you can make sure that

00:17:53,200 --> 00:17:58,080
timestamp is correct

00:17:54,559 --> 00:18:00,559
and it will not mess up the pipelines

00:17:58,080 --> 00:18:01,440
so basically that's all the things i

00:18:00,559 --> 00:18:04,960
want to

00:18:01,440 --> 00:18:07,120
cover and because uh there are too many

00:18:04,960 --> 00:18:09,360
uh point of views of the spiritual fund

00:18:07,120 --> 00:18:12,320
and the building source with produce

00:18:09,360 --> 00:18:12,799
we we don't get into details on each

00:18:12,320 --> 00:18:15,120
point

00:18:12,799 --> 00:18:16,559
but hopefully this overall introduction

00:18:15,120 --> 00:18:20,000
will be helpful

00:18:16,559 --> 00:18:21,760
and finally i will uh

00:18:20,000 --> 00:18:24,080
attach more resources if you are

00:18:21,760 --> 00:18:24,720
interesting here which can help you to

00:18:24,080 --> 00:18:26,880
understand

00:18:24,720 --> 00:18:28,880
more when when it's time to build your

00:18:26,880 --> 00:18:31,120
own source on top of this will do from

00:18:28,880 --> 00:18:32,880
so first if you are interested in

00:18:31,120 --> 00:18:34,160
building your own supervisor phone you

00:18:32,880 --> 00:18:36,240
can look into our

00:18:34,160 --> 00:18:37,280
programming guide so this guide will

00:18:36,240 --> 00:18:40,799
cover

00:18:37,280 --> 00:18:42,880
python java and go sdks

00:18:40,799 --> 00:18:44,080
and if you are using open source runners

00:18:42,880 --> 00:18:47,120
such as spark and

00:18:44,080 --> 00:18:48,799
link and you are uh you are wondering

00:18:47,120 --> 00:18:50,960
what kind of functionalities these

00:18:48,799 --> 00:18:54,080
runners can support forcible dupont

00:18:50,960 --> 00:18:56,240
you can look into the capability metrics

00:18:54,080 --> 00:18:57,919
and as i mentioned for dynamic split

00:18:56,240 --> 00:19:00,640
it's very complicated

00:18:57,919 --> 00:19:00,960
and in for data flow we have a blog post

00:19:00,640 --> 00:19:03,200
to

00:19:00,960 --> 00:19:05,200
explain how this happens on data flow

00:19:03,200 --> 00:19:07,360
it's very interesting and helpful

00:19:05,200 --> 00:19:09,440
and if you're interested in you can look

00:19:07,360 --> 00:19:10,480
into this one for more details about the

00:19:09,440 --> 00:19:14,000
mixed blitz

00:19:10,480 --> 00:19:14,799
and for bing phone api we also have a

00:19:14,000 --> 00:19:16,960
centralized

00:19:14,799 --> 00:19:19,200
documentation to see what kind of

00:19:16,960 --> 00:19:21,360
execution models we want to have and

00:19:19,200 --> 00:19:22,799
all the different aspects for these

00:19:21,360 --> 00:19:24,640
models we have

00:19:22,799 --> 00:19:26,720
and if you decide to build your own

00:19:24,640 --> 00:19:28,799
source i would recommend you look into

00:19:26,720 --> 00:19:31,360
our bing uh io guide first

00:19:28,799 --> 00:19:31,840
to get a sense of how to build a handle

00:19:31,360 --> 00:19:35,360
things

00:19:31,840 --> 00:19:37,520
and the things you need to prepare and

00:19:35,360 --> 00:19:38,640
if you are interested in how to

00:19:37,520 --> 00:19:40,880
interested in knowing

00:19:38,640 --> 00:19:41,760
how these ideas got generated at the

00:19:40,880 --> 00:19:44,240
first place

00:19:41,760 --> 00:19:44,960
i would recommend you can look into our

00:19:44,240 --> 00:19:47,440
design doc

00:19:44,960 --> 00:19:48,400
website it contains all of the docs we

00:19:47,440 --> 00:19:50,559
have so far

00:19:48,400 --> 00:19:52,000
and there are many interesting reading

00:19:50,559 --> 00:19:54,080
materials there

00:19:52,000 --> 00:19:55,679
and finally if you are decide to

00:19:54,080 --> 00:19:58,559
contribute to the bing

00:19:55,679 --> 00:20:00,400
or or bring any your source or any or

00:19:58,559 --> 00:20:02,320
code into bing

00:20:00,400 --> 00:20:04,400
the first thing i would recommend is to

00:20:02,320 --> 00:20:06,480
look into our contribution guide

00:20:04,400 --> 00:20:09,200
it includes all of the instructions

00:20:06,480 --> 00:20:12,080
ideas on how to contribute to our

00:20:09,200 --> 00:20:13,120
bim community and finally thanks for

00:20:12,080 --> 00:20:16,480
your interest

00:20:13,120 --> 00:20:21,290
and uh thanks for thanks for your time

00:20:16,480 --> 00:20:28,859
and welcome to bing community

00:20:21,290 --> 00:20:28,859

YouTube URL: https://www.youtube.com/watch?v=VeMdVnkLHog


