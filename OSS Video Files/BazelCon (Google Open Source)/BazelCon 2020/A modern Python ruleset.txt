Title: A modern Python ruleset
Publication date: 2020-11-13
Playlist: BazelCon 2020
Description: 
	Bazel's native Python rules are infamously ill-suited for Python projects of any complexity outside of Google. Dropbox's dbx_build_tools includes a pure Starlark alternative Python ruleset that handles millions of lines of Python in production. The Python rules include support for third-party PyPI dependencies (including native dependencies), BUILD file generation, and hermetic Python archives that don't depend on the system.

Resources:
Github: https://goo.gle/3naDrHR

Speaker: Benjamin Peterson

Watch more:
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Unlisted; product: Open Source - General; fullname: Benjamin Peterson; event: Bazelcon 2020;
Captions: 
	00:00:01,040 --> 00:00:07,279
[Music]

00:00:05,440 --> 00:00:09,679
thanks for tuning in

00:00:07,279 --> 00:00:10,800
i'm benjamin i'm currently i work at

00:00:09,679 --> 00:00:12,880
dropbox

00:00:10,800 --> 00:00:13,920
uh and i'm here to tell you about a set

00:00:12,880 --> 00:00:16,400
of bazel rules

00:00:13,920 --> 00:00:18,800
we at dropbox have developed for python

00:00:16,400 --> 00:00:20,960
over the last five years

00:00:18,800 --> 00:00:22,800
firstly though why do we build our own

00:00:20,960 --> 00:00:24,400
rule set for python

00:00:22,800 --> 00:00:26,480
a cursory inspection of the bazel

00:00:24,400 --> 00:00:28,480
documentation reveals that bazel already

00:00:26,480 --> 00:00:30,320
has python rules built in so why don't

00:00:28,480 --> 00:00:32,559
we just use those

00:00:30,320 --> 00:00:33,520
unfortunately bazel's built-in rules are

00:00:32,559 --> 00:00:35,120
limited

00:00:33,520 --> 00:00:36,800
they assume a python interpreter is

00:00:35,120 --> 00:00:37,680
already installed somewhere on the

00:00:36,800 --> 00:00:40,480
system

00:00:37,680 --> 00:00:42,239
which compromises hermeticity bazel does

00:00:40,480 --> 00:00:43,200
not support compilation of bytecode

00:00:42,239 --> 00:00:46,719
cache files

00:00:43,200 --> 00:00:48,960
pycs having by code cache files around

00:00:46,719 --> 00:00:50,559
is not essential for running python but

00:00:48,960 --> 00:00:52,079
it helps the startup time of large

00:00:50,559 --> 00:00:53,840
applications

00:00:52,079 --> 00:00:55,440
perhaps the severest problem of the

00:00:53,840 --> 00:00:57,760
built-in python rules relate to

00:00:55,440 --> 00:00:59,600
third-party dependencies

00:00:57,760 --> 00:01:00,800
bazel has no built-in way to build c

00:00:59,600 --> 00:01:02,559
extensions

00:01:00,800 --> 00:01:04,159
it doesn't understand wheels a common

00:01:02,559 --> 00:01:05,840
python packaging format

00:01:04,159 --> 00:01:09,439
or how to download dependencies from

00:01:05,840 --> 00:01:11,040
pipi the python packaging index

00:01:09,439 --> 00:01:12,880
these shortcomings lead to the

00:01:11,040 --> 00:01:14,880
conclusion that bazel's built in python

00:01:12,880 --> 00:01:16,000
roles are only suitable for triply use

00:01:14,880 --> 00:01:19,360
cases

00:01:16,000 --> 00:01:20,799
and google i'd note that blaze's python

00:01:19,360 --> 00:01:21,520
rules do not suffer from most of the

00:01:20,799 --> 00:01:24,159
defects

00:01:21,520 --> 00:01:26,000
that i've enumerated in bazel's however

00:01:24,159 --> 00:01:28,400
google's python practices evolved years

00:01:26,000 --> 00:01:29,040
ago and have drifted far from how most

00:01:28,400 --> 00:01:32,240
python

00:01:29,040 --> 00:01:34,320
is developed today so blaze's python

00:01:32,240 --> 00:01:35,040
rules are not directly useful outside of

00:01:34,320 --> 00:01:37,040
google

00:01:35,040 --> 00:01:39,280
which explains why they have not been

00:01:37,040 --> 00:01:41,680
open sourced

00:01:39,280 --> 00:01:43,759
dropbox needed python rules for bazel

00:01:41,680 --> 00:01:46,560
before the advent of the open source and

00:01:43,759 --> 00:01:49,040
semi-official rules python set

00:01:46,560 --> 00:01:49,600
so we needed to strike out our own to

00:01:49,040 --> 00:01:52,720
create

00:01:49,600 --> 00:01:55,200
production-grade python rules

00:01:52,720 --> 00:01:56,320
even today our python rules provide some

00:01:55,200 --> 00:01:58,799
unique features

00:01:56,320 --> 00:02:00,240
over other python role sets like rules

00:01:58,799 --> 00:02:02,880
python

00:02:00,240 --> 00:02:03,600
our python roles are part of dbx build

00:02:02,880 --> 00:02:05,680
tools

00:02:03,600 --> 00:02:08,080
a collection of rules and tools related

00:02:05,680 --> 00:02:10,720
to bazel that dropbox has developed

00:02:08,080 --> 00:02:12,560
over the last five years it is used

00:02:10,720 --> 00:02:13,280
heavily internally for millions of lines

00:02:12,560 --> 00:02:16,000
of python

00:02:13,280 --> 00:02:17,280
in production the source is available on

00:02:16,000 --> 00:02:20,480
github

00:02:17,280 --> 00:02:20,480
at the link in the slide

00:02:20,640 --> 00:02:24,720
as is implied in his name dbx build

00:02:23,040 --> 00:02:25,760
tools contains more than just python

00:02:24,720 --> 00:02:27,440
rules

00:02:25,760 --> 00:02:29,360
uh and we've given talks at previous

00:02:27,440 --> 00:02:32,560
bazel cons about some of the other tools

00:02:29,360 --> 00:02:34,640
in dbx build tools in 2017 we talked

00:02:32,560 --> 00:02:37,680
about our integration testing framework

00:02:34,640 --> 00:02:39,280
built with bazel and in 2018 we talked

00:02:37,680 --> 00:02:40,640
about our build file generator

00:02:39,280 --> 00:02:42,640
which can automatically generate

00:02:40,640 --> 00:02:44,480
dependencies from source files

00:02:42,640 --> 00:02:46,080
as we'll see later in this talk the

00:02:44,480 --> 00:02:48,080
generator can also be applied

00:02:46,080 --> 00:02:49,920
to python and works with our python

00:02:48,080 --> 00:02:51,599
rules

00:02:49,920 --> 00:02:54,319
let's first take a look at how our

00:02:51,599 --> 00:02:56,720
python rules look to the user

00:02:54,319 --> 00:02:59,440
that is people writing build files and

00:02:56,720 --> 00:02:59,440
python code

00:02:59,519 --> 00:03:02,959
the macro structure of our python rules

00:03:01,200 --> 00:03:05,040
will be familiar to anyone who has used

00:03:02,959 --> 00:03:06,959
the built-in python rules or indeed any

00:03:05,040 --> 00:03:08,879
language rule set

00:03:06,959 --> 00:03:10,560
bazel's built-in python rules generally

00:03:08,879 --> 00:03:12,000
have counterparts in our role set

00:03:10,560 --> 00:03:15,120
prefixed with dbx

00:03:12,000 --> 00:03:16,159
underscore to access them a build file

00:03:15,120 --> 00:03:19,680
must load from the

00:03:16,159 --> 00:03:22,640
at dbx build tools workspace

00:03:19,680 --> 00:03:24,560
the most common rule dbx pi library

00:03:22,640 --> 00:03:26,640
describes a set of python sources

00:03:24,560 --> 00:03:28,480
possibly with some dependencies for

00:03:26,640 --> 00:03:30,640
other code to import

00:03:28,480 --> 00:03:32,159
in the example in this slide my lib

00:03:30,640 --> 00:03:35,040
contains one source file

00:03:32,159 --> 00:03:36,239
my lived up pi and my lib depends on

00:03:35,040 --> 00:03:39,280
another dbx

00:03:36,239 --> 00:03:43,360
binary library rule bar lib

00:03:39,280 --> 00:03:45,519
in the foo package the dbx pi binary

00:03:43,360 --> 00:03:46,000
rule creates an executable that invokes

00:03:45,519 --> 00:03:48,799
the script

00:03:46,000 --> 00:03:50,080
listed in its main attribute with the

00:03:48,799 --> 00:03:52,080
code on this slide

00:03:50,080 --> 00:03:53,680
running the myapp target after it's

00:03:52,080 --> 00:03:56,799
built will execute the code in

00:03:53,680 --> 00:03:59,360
myapp.pi myapp.pi

00:03:56,799 --> 00:04:01,200
may itself import from mylib since the

00:03:59,360 --> 00:04:04,799
binary rule has a dependency

00:04:01,200 --> 00:04:07,360
on the my label rule there is of course

00:04:04,799 --> 00:04:08,720
also support for testing in our rule set

00:04:07,360 --> 00:04:12,000
the simplest kind of test

00:04:08,720 --> 00:04:13,040
uses a dbx pi test rule which is a dbx

00:04:12,000 --> 00:04:15,200
pi binary

00:04:13,040 --> 00:04:16,560
marked as a basal test rule this

00:04:15,200 --> 00:04:18,239
provides the most general kind of

00:04:16,560 --> 00:04:20,400
testing bazel supports

00:04:18,239 --> 00:04:21,600
if the binary exits with status quo zero

00:04:20,400 --> 00:04:23,919
the test passes

00:04:21,600 --> 00:04:26,000
otherwise it fails bazel collects

00:04:23,919 --> 00:04:27,520
whatever logs the binary prints into the

00:04:26,000 --> 00:04:29,440
test log

00:04:27,520 --> 00:04:31,440
this simple rule is useful for oddball

00:04:29,440 --> 00:04:33,600
tests and wrapping third party test

00:04:31,440 --> 00:04:35,280
cases

00:04:33,600 --> 00:04:36,800
for most of our tests though we want

00:04:35,280 --> 00:04:39,120
some more structure

00:04:36,800 --> 00:04:40,479
in the python world pi test is a very

00:04:39,120 --> 00:04:42,639
popular test runner

00:04:40,479 --> 00:04:45,199
and we use pi test heavily internally at

00:04:42,639 --> 00:04:45,199
dropbox

00:04:45,520 --> 00:04:49,759
our python roles have special support

00:04:47,280 --> 00:04:52,560
for pi test in the form of the dbx pi

00:04:49,759 --> 00:04:54,160
pi test test rule try saying that five

00:04:52,560 --> 00:04:55,919
times fast

00:04:54,160 --> 00:04:57,520
this rule runs pi test collect and

00:04:55,919 --> 00:04:58,400
execute the tests in its sources

00:04:57,520 --> 00:05:00,400
attribute

00:04:58,400 --> 00:05:01,840
the wide penetration of pi test in the

00:05:00,400 --> 00:05:04,320
open source world means python

00:05:01,840 --> 00:05:05,199
programmers can use dbx pi pi pi test

00:05:04,320 --> 00:05:08,400
test

00:05:05,199 --> 00:05:11,120
without learning new conventions

00:05:08,400 --> 00:05:12,320
since it is more structured dbx pi pi

00:05:11,120 --> 00:05:13,840
test test

00:05:12,320 --> 00:05:15,919
automatically supports richer

00:05:13,840 --> 00:05:18,160
integration with bazel

00:05:15,919 --> 00:05:19,120
the role automatically produces xml test

00:05:18,160 --> 00:05:21,680
result output

00:05:19,120 --> 00:05:23,440
in junit format it also has native

00:05:21,680 --> 00:05:24,080
support for some special bazel test

00:05:23,440 --> 00:05:26,880
command line

00:05:24,080 --> 00:05:28,400
flags dash dash test filter for running

00:05:26,880 --> 00:05:30,160
individual tests with

00:05:28,400 --> 00:05:31,600
in a test target from the command line

00:05:30,160 --> 00:05:33,840
and dash test run

00:05:31,600 --> 00:05:35,919
or fail fast which makes test targets

00:05:33,840 --> 00:05:37,759
fail as soon as one individual test case

00:05:35,919 --> 00:05:39,600
does

00:05:37,759 --> 00:05:41,360
next topic i'll discuss is how the

00:05:39,600 --> 00:05:42,400
python rules integrate with third-party

00:05:41,360 --> 00:05:44,320
libraries

00:05:42,400 --> 00:05:46,720
but first let's touch on the challenges

00:05:44,320 --> 00:05:49,680
in integrating the python ecosystem

00:05:46,720 --> 00:05:50,880
with bazel a central issue in python

00:05:49,680 --> 00:05:52,639
packaging

00:05:50,880 --> 00:05:55,199
is that the native packaging system is

00:05:52,639 --> 00:05:57,039
based on arbitrary code execution

00:05:55,199 --> 00:05:58,240
python source distributions have a file

00:05:57,039 --> 00:06:00,639
called setup to pi

00:05:58,240 --> 00:06:02,639
that is invoked to build the package

00:06:00,639 --> 00:06:03,680
most packages set out to pi files call

00:06:02,639 --> 00:06:05,680
into disk details

00:06:03,680 --> 00:06:07,919
a venerable library of helper code for

00:06:05,680 --> 00:06:09,840
packaging in the standard library

00:06:07,919 --> 00:06:11,520
or they call into its equally venerable

00:06:09,840 --> 00:06:13,120
counterpart

00:06:11,520 --> 00:06:15,039
setup tools which is a third party

00:06:13,120 --> 00:06:16,319
package

00:06:15,039 --> 00:06:18,160
this fact means that there's no

00:06:16,319 --> 00:06:20,240
universal declarative way to discover

00:06:18,160 --> 00:06:21,759
the dependencies or other build metadata

00:06:20,240 --> 00:06:23,759
about a package

00:06:21,759 --> 00:06:25,600
you have to execute setup to pi to do

00:06:23,759 --> 00:06:27,840
basically anything

00:06:25,600 --> 00:06:30,400
furthermore setup highs frequently do

00:06:27,840 --> 00:06:32,560
feature detection by probing the system

00:06:30,400 --> 00:06:34,240
so we must figure out a way to tame

00:06:32,560 --> 00:06:37,759
arbitrary packages into producing

00:06:34,240 --> 00:06:39,759
hermetic archives during the build

00:06:37,759 --> 00:06:41,520
as an aside i can note that the python

00:06:39,759 --> 00:06:42,319
packaging situation is improving every

00:06:41,520 --> 00:06:43,919
day

00:06:42,319 --> 00:06:45,840
many dedicated people have been working

00:06:43,919 --> 00:06:46,800
in the python packaging ecosystem in the

00:06:45,840 --> 00:06:48,880
last decade

00:06:46,800 --> 00:06:50,800
and a lot of progress has been made

00:06:48,880 --> 00:06:51,520
unfortunately for packaged consumers uh

00:06:50,800 --> 00:06:53,039
life is as

00:06:51,520 --> 00:06:55,520
tough as your thorniest third-party

00:06:53,039 --> 00:06:57,120
dependency and in my experience

00:06:55,520 --> 00:06:58,720
large code pieces always seem to need at

00:06:57,120 --> 00:06:59,520
least one really old third-party

00:06:58,720 --> 00:07:02,720
dependency

00:06:59,520 --> 00:07:04,720
with a wicked homegrown build system

00:07:02,720 --> 00:07:06,720
here's an example of how the dbx build

00:07:04,720 --> 00:07:07,919
tools rules integrate with external

00:07:06,720 --> 00:07:10,560
packages

00:07:07,919 --> 00:07:12,479
the main rule we use is called dbx pi

00:07:10,560 --> 00:07:14,400
pipi pip lib

00:07:12,479 --> 00:07:15,759
that rule pulls in a dependency from the

00:07:14,400 --> 00:07:17,919
python package index

00:07:15,759 --> 00:07:19,440
that's what pi p i stands for in the

00:07:17,919 --> 00:07:21,840
rule name

00:07:19,440 --> 00:07:23,440
six here is a simple library so we only

00:07:21,840 --> 00:07:24,479
need to provide the library name and

00:07:23,440 --> 00:07:25,919
version

00:07:24,479 --> 00:07:28,000
traditionally we put our third party

00:07:25,919 --> 00:07:30,160
library roles in subdirectories of a pip

00:07:28,000 --> 00:07:32,560
directory at the root of a repository

00:07:30,160 --> 00:07:34,800
this aids discoverability for humans and

00:07:32,560 --> 00:07:37,199
tools

00:07:34,800 --> 00:07:39,199
once a piplup rule like this is set up

00:07:37,199 --> 00:07:42,639
first party code could depend on it

00:07:39,199 --> 00:07:44,240
as if it was a normal dbx pi library

00:07:42,639 --> 00:07:46,960
the imports just work out for the

00:07:44,240 --> 00:07:49,199
calling code

00:07:46,960 --> 00:07:51,199
of course not all of the python aq

00:07:49,199 --> 00:07:52,960
system is simple one line pure python

00:07:51,199 --> 00:07:54,639
libraries like six

00:07:52,960 --> 00:07:56,400
python date util furnishes a more

00:07:54,639 --> 00:07:58,080
complex example

00:07:56,400 --> 00:08:00,160
the name and pip version attributes are

00:07:58,080 --> 00:08:01,840
still here but some other information

00:08:00,160 --> 00:08:03,840
has come into play too

00:08:01,840 --> 00:08:04,960
the first thing to notice is that python

00:08:03,840 --> 00:08:08,080
date util

00:08:04,960 --> 00:08:09,919
has a dependency on six such inter pi pi

00:08:08,080 --> 00:08:10,560
dependencies are declared using the deps

00:08:09,919 --> 00:08:14,080
attribute

00:08:10,560 --> 00:08:15,919
of dbx pi pipi piplin

00:08:14,080 --> 00:08:18,879
python date util also has a setup

00:08:15,919 --> 00:08:20,560
requires dependency on setup tool skim

00:08:18,879 --> 00:08:22,720
that means setup tool skim is a build

00:08:20,560 --> 00:08:24,960
time dependency of python date util

00:08:22,720 --> 00:08:26,800
so it must be present when python python

00:08:24,960 --> 00:08:28,639
date util is being built

00:08:26,800 --> 00:08:29,919
however setup tool skim does not need to

00:08:28,639 --> 00:08:33,200
be around at run time

00:08:29,919 --> 00:08:35,680
when python date util is imported

00:08:33,200 --> 00:08:37,360
this python dateutil rule also has a

00:08:35,680 --> 00:08:39,120
provides attribute

00:08:37,360 --> 00:08:41,599
the provides attribute declares what

00:08:39,120 --> 00:08:43,599
names the code is importable under

00:08:41,599 --> 00:08:45,360
python dash date utils is the name of

00:08:43,599 --> 00:08:47,200
the package on pi pi

00:08:45,360 --> 00:08:48,959
but the dependent code loads it under

00:08:47,200 --> 00:08:51,440
the date utils name

00:08:48,959 --> 00:08:53,680
provides is a list because some packages

00:08:51,440 --> 00:08:56,240
occupy multiple namespaces

00:08:53,680 --> 00:08:57,680
for instance setup tools the package

00:08:56,240 --> 00:08:59,519
provides both

00:08:57,680 --> 00:09:01,760
code both under the setup tools and

00:08:59,519 --> 00:09:03,600
package resources namespaces

00:09:01,760 --> 00:09:05,200
a related feature that we also support

00:09:03,600 --> 00:09:08,080
is namespace packages

00:09:05,200 --> 00:09:09,200
which is new in python 3. in namespace

00:09:08,080 --> 00:09:11,120
packages

00:09:09,200 --> 00:09:12,880
multiple packages may contribute code to

00:09:11,120 --> 00:09:14,800
the same top level package

00:09:12,880 --> 00:09:16,800
for example many separate packages for

00:09:14,800 --> 00:09:17,360
google apis are importable under the

00:09:16,800 --> 00:09:20,800
google

00:09:17,360 --> 00:09:23,600
top level name unfortunately

00:09:20,800 --> 00:09:25,200
the dynamics-ness of python packaging

00:09:23,600 --> 00:09:27,360
which i discussed earlier

00:09:25,200 --> 00:09:29,120
means that the data that goes into these

00:09:27,360 --> 00:09:32,160
attributes is not

00:09:29,120 --> 00:09:34,080
readily declare available anywhere in a

00:09:32,160 --> 00:09:35,120
declarative fashion

00:09:34,080 --> 00:09:36,959
normally figuring out the right

00:09:35,120 --> 00:09:38,640
attribute values is a manual process

00:09:36,959 --> 00:09:39,680
that involves some code inspection of

00:09:38,640 --> 00:09:41,600
the package

00:09:39,680 --> 00:09:43,360
we've gotten quite good at turning a set

00:09:41,600 --> 00:09:46,399
of piles into proper dbx pi

00:09:43,360 --> 00:09:48,560
pi piplub rules at dropbox

00:09:46,399 --> 00:09:50,160
our third-party python roles also have

00:09:48,560 --> 00:09:52,640
transparent support for linking

00:09:50,160 --> 00:09:53,760
native dependencies like c or c plus

00:09:52,640 --> 00:09:55,680
plus

00:09:53,760 --> 00:09:58,160
for example here is the build file for

00:09:55,680 --> 00:10:01,360
the cryptography package

00:09:58,160 --> 00:10:02,880
the cryptography package uses openssl

00:10:01,360 --> 00:10:04,640
and the cryptography build file

00:10:02,880 --> 00:10:07,200
indicates this dependency by putting the

00:10:04,640 --> 00:10:08,959
target for the role that builds openssl

00:10:07,200 --> 00:10:11,600
into the depth attribute of the

00:10:08,959 --> 00:10:15,440
cryptography package rule

00:10:11,600 --> 00:10:18,480
here at org openssl

00:10:15,440 --> 00:10:20,480
colon ssl is a cc library rule

00:10:18,480 --> 00:10:22,320
that the python rules transparently know

00:10:20,480 --> 00:10:23,680
how to link into the build products of

00:10:22,320 --> 00:10:26,079
cryptography

00:10:23,680 --> 00:10:27,120
sometimes a third party package needs to

00:10:26,079 --> 00:10:28,399
be forked

00:10:27,120 --> 00:10:30,640
either because it can't be built

00:10:28,399 --> 00:10:31,360
unmodified or some other patching

00:10:30,640 --> 00:10:34,240
requirement

00:10:31,360 --> 00:10:35,920
unrelated to the build system dbx build

00:10:34,240 --> 00:10:36,880
tools natively supports forking

00:10:35,920 --> 00:10:40,000
third-party code

00:10:36,880 --> 00:10:41,440
into the source tree the example in this

00:10:40,000 --> 00:10:42,959
slide builds a local version of the

00:10:41,440 --> 00:10:45,279
django web framework

00:10:42,959 --> 00:10:47,600
we've copied django into the third party

00:10:45,279 --> 00:10:49,839
slash django directory

00:10:47,600 --> 00:10:52,160
made desired modifications and written a

00:10:49,839 --> 00:10:55,600
dbx pi local piplub rule

00:10:52,160 --> 00:10:58,399
in the build file a dbx pi local pip lib

00:10:55,600 --> 00:11:00,560
is very similar to the dbx pi pi pivot

00:10:58,399 --> 00:11:02,320
rule seen earlier but it builds a

00:11:00,560 --> 00:11:04,480
package from the files and the sources

00:11:02,320 --> 00:11:06,640
attribute rather than downloading the

00:11:04,480 --> 00:11:09,600
sources from

00:11:06,640 --> 00:11:10,399
the internet the piv version attribute

00:11:09,600 --> 00:11:12,240
is still used

00:11:10,399 --> 00:11:13,440
but only serves a documentation and

00:11:12,240 --> 00:11:15,200
auditing purpose now

00:11:13,440 --> 00:11:17,200
because nothing is downloaded from the

00:11:15,200 --> 00:11:19,680
python packaging index

00:11:17,200 --> 00:11:20,959
one of the more useful features in dbx

00:11:19,680 --> 00:11:23,839
build tools for python

00:11:20,959 --> 00:11:25,519
is build file generation i won't venture

00:11:23,839 --> 00:11:26,240
deeply into the mechanics of build file

00:11:25,519 --> 00:11:27,680
generation

00:11:26,240 --> 00:11:29,279
since as i said at the beginning of the

00:11:27,680 --> 00:11:33,600
talk we have a whole

00:11:29,279 --> 00:11:35,200
other talk about it at bazelcon 2018.

00:11:33,600 --> 00:11:37,680
the main feature of the build file

00:11:35,200 --> 00:11:39,360
generator is writing dependencies

00:11:37,680 --> 00:11:41,360
in build files based on import

00:11:39,360 --> 00:11:42,800
statements in the source code

00:11:41,360 --> 00:11:44,320
the build file generator can infer

00:11:42,800 --> 00:11:45,120
dependencies on libraries in the same

00:11:44,320 --> 00:11:46,640
package

00:11:45,120 --> 00:11:48,399
different packages as well as

00:11:46,640 --> 00:11:50,560
third-party dependencies in the pip

00:11:48,399 --> 00:11:52,959
or third-party directories these

00:11:50,560 --> 00:11:55,519
different kinds of dependencies are seen

00:11:52,959 --> 00:11:57,279
in this generated example a few other

00:11:55,519 --> 00:11:59,120
extra features of our roles are worth

00:11:57,279 --> 00:12:01,760
briefly noting

00:11:59,120 --> 00:12:03,279
firstly we have a verifier in the form

00:12:01,760 --> 00:12:06,240
of a command line aspect

00:12:03,279 --> 00:12:08,320
for library rule dependencies the

00:12:06,240 --> 00:12:10,160
verifier checks that library rules

00:12:08,320 --> 00:12:11,920
directly depend on all the libraries

00:12:10,160 --> 00:12:13,600
they import and conversely

00:12:11,920 --> 00:12:15,200
they don't depend on the libraries they

00:12:13,600 --> 00:12:17,200
don't use

00:12:15,200 --> 00:12:18,800
users don't run a follow this verifier

00:12:17,200 --> 00:12:20,240
very frequently

00:12:18,800 --> 00:12:22,639
because of automatic build file

00:12:20,240 --> 00:12:24,320
generation but the system is still

00:12:22,639 --> 00:12:27,360
useful as an independent check

00:12:24,320 --> 00:12:30,160
on the build file generator and also

00:12:27,360 --> 00:12:31,760
for manually written library rules which

00:12:30,160 --> 00:12:34,079
happen sometimes

00:12:31,760 --> 00:12:36,000
secondly we support having binaries that

00:12:34,079 --> 00:12:38,240
run python 2 and binaries that run

00:12:36,000 --> 00:12:39,760
python 3 in the same build

00:12:38,240 --> 00:12:41,600
if you're lucky enough to not have

00:12:39,760 --> 00:12:42,399
python 2 in your codebase you won't care

00:12:41,600 --> 00:12:44,399
about this

00:12:42,399 --> 00:12:46,000
but for codebases transitioning between

00:12:44,399 --> 00:12:47,760
python 2 and python 3

00:12:46,000 --> 00:12:50,079
it's invaluable to be able to build code

00:12:47,760 --> 00:12:52,399
using both versions

00:12:50,079 --> 00:12:54,079
in theory this python 2 and 3 support

00:12:52,399 --> 00:12:55,200
could also be extended to arbitrary

00:12:54,079 --> 00:12:56,639
python versions

00:12:55,200 --> 00:12:59,680
for example we could allow running

00:12:56,639 --> 00:13:02,399
python 3.8 and 3.9 in the same build

00:12:59,680 --> 00:13:04,079
um it's quite possible that we'll delete

00:13:02,399 --> 00:13:05,920
this support for multiple versions from

00:13:04,079 --> 00:13:07,519
dbx build tools

00:13:05,920 --> 00:13:09,839
once we managed to get rid of python 2

00:13:07,519 --> 00:13:11,839
in our code base because a feature adds

00:13:09,839 --> 00:13:13,920
a lot of complexity

00:13:11,839 --> 00:13:14,880
next i will touch on a little bit how

00:13:13,920 --> 00:13:18,720
the rules

00:13:14,880 --> 00:13:21,760
work internally their guts the crux of

00:13:18,720 --> 00:13:23,279
the dbx build tools python rules is dbx

00:13:21,760 --> 00:13:24,800
pi binary

00:13:23,279 --> 00:13:26,720
that's because it brings together all

00:13:24,800 --> 00:13:27,600
transitive python code first and third

00:13:26,720 --> 00:13:31,360
party

00:13:27,600 --> 00:13:33,360
into a working executable building a dbx

00:13:31,360 --> 00:13:35,600
pi binary produces several items

00:13:33,360 --> 00:13:36,399
into the executables run files tree

00:13:35,600 --> 00:13:38,560
first of all

00:13:36,399 --> 00:13:40,399
there's the executables code including

00:13:38,560 --> 00:13:42,000
dot pi files from transitive library

00:13:40,399 --> 00:13:44,160
rules

00:13:42,000 --> 00:13:46,000
pyc bytecode cache files are also

00:13:44,160 --> 00:13:47,680
generated into the run files tree for

00:13:46,000 --> 00:13:49,600
all dot pi files

00:13:47,680 --> 00:13:51,279
second of all there's the third-party

00:13:49,600 --> 00:13:54,800
code from dbx pi

00:13:51,279 --> 00:13:58,320
pi pi pip loop and dbx pi local pip lib

00:13:54,800 --> 00:14:00,000
rules third-party code is built and

00:13:58,320 --> 00:14:02,880
unpacked into the run files tree

00:14:00,000 --> 00:14:04,720
so it can be imported by python third

00:14:02,880 --> 00:14:06,639
there's a hermetic python interpreter

00:14:04,720 --> 00:14:08,240
with its standard library

00:14:06,639 --> 00:14:09,839
we build a python interpreter so that it

00:14:08,240 --> 00:14:11,199
has all of its third-party dependencies

00:14:09,839 --> 00:14:13,920
statically linked in

00:14:11,199 --> 00:14:15,920
except for libsy this yields portability

00:14:13,920 --> 00:14:16,959
and reproducibility across a wide range

00:14:15,920 --> 00:14:19,519
of linux systems

00:14:16,959 --> 00:14:20,959
and distributions finally there's a

00:14:19,519 --> 00:14:22,800
wrapper shell script

00:14:20,959 --> 00:14:24,079
named after the target that invokes the

00:14:22,800 --> 00:14:26,079
hermetic python

00:14:24,079 --> 00:14:28,240
with the right python path environmental

00:14:26,079 --> 00:14:29,680
variable and leaps into the user's main

00:14:28,240 --> 00:14:32,079
code

00:14:29,680 --> 00:14:34,160
this layout means the dbx pi binary's

00:14:32,079 --> 00:14:36,240
run files tree can be copied to almost

00:14:34,160 --> 00:14:38,000
any linux system and run without

00:14:36,240 --> 00:14:41,040
installing other dependencies

00:14:38,000 --> 00:14:43,279
that's very helpful for distribution now

00:14:41,040 --> 00:14:44,480
a peek into the grimy third party

00:14:43,279 --> 00:14:47,839
packaging build

00:14:44,480 --> 00:14:49,120
process the basic idea is to for each

00:14:47,839 --> 00:14:51,120
package invoke pip

00:14:49,120 --> 00:14:52,560
the python package builder and manager

00:14:51,120 --> 00:14:55,040
in a controlled environment

00:14:52,560 --> 00:14:57,199
so it produces what we need using only

00:14:55,040 --> 00:14:59,440
the dependencies that have been declared

00:14:57,199 --> 00:15:00,720
bazel's linux sandbox helps greatly with

00:14:59,440 --> 00:15:02,639
this task

00:15:00,720 --> 00:15:04,160
within the sandbox we build a little

00:15:02,639 --> 00:15:06,480
virtual environment for pip

00:15:04,160 --> 00:15:08,079
install the target package into it and

00:15:06,480 --> 00:15:10,160
finally produce a wheel of the

00:15:08,079 --> 00:15:12,399
built package as the ultimate output of

00:15:10,160 --> 00:15:14,079
the rule

00:15:12,399 --> 00:15:15,839
native dependencies are especially

00:15:14,079 --> 00:15:16,720
tricky because most packages are

00:15:15,839 --> 00:15:18,560
expected

00:15:16,720 --> 00:15:20,079
to be able to probe the system for

00:15:18,560 --> 00:15:21,519
headers and libraries to compile and

00:15:20,079 --> 00:15:23,440
link against

00:15:21,519 --> 00:15:26,079
but we want packages to only use the

00:15:23,440 --> 00:15:27,680
code and dependencies that we provide

00:15:26,079 --> 00:15:29,120
both native dependencies and the need

00:15:27,680 --> 00:15:30,079
for determinism require a lot of

00:15:29,120 --> 00:15:32,800
delicate code

00:15:30,079 --> 00:15:33,199
we might just say hacks for example we

00:15:32,800 --> 00:15:35,360
need

00:15:33,199 --> 00:15:36,880
extra compiler and pip flags to ensure

00:15:35,360 --> 00:15:38,240
absolute paths aren't written into the

00:15:36,880 --> 00:15:40,160
build artifacts

00:15:38,240 --> 00:15:42,079
we provide a wrapper for the linker to

00:15:40,160 --> 00:15:43,839
ensure that undesired system libraries

00:15:42,079 --> 00:15:45,920
are not linked

00:15:43,839 --> 00:15:48,160
overall there's years of accreted

00:15:45,920 --> 00:15:50,720
hardware knowledge about building python

00:15:48,160 --> 00:15:52,240
packages in our code for this and i'm

00:15:50,720 --> 00:15:53,440
sad to say that i know things like how

00:15:52,240 --> 00:15:55,199
to configure numpy

00:15:53,440 --> 00:15:58,320
so that it accepts a hermetic fortran

00:15:55,199 --> 00:16:00,720
compiler and runtime

00:15:58,320 --> 00:16:02,800
the dvx build tools python rules assume

00:16:00,720 --> 00:16:04,079
conventions that do not universally hold

00:16:02,800 --> 00:16:06,320
in the python world

00:16:04,079 --> 00:16:09,600
as the rules may not easily work out of

00:16:06,320 --> 00:16:11,680
the box for everyone

00:16:09,600 --> 00:16:13,360
a primary expectation of our roles is

00:16:11,680 --> 00:16:15,839
that there is only one entry on the

00:16:13,360 --> 00:16:18,160
python path within the main workspace

00:16:15,839 --> 00:16:21,040
that is to say all python imports are

00:16:18,160 --> 00:16:22,959
resolved from the root of our repository

00:16:21,040 --> 00:16:24,880
this rule makes it easier for humans and

00:16:22,959 --> 00:16:27,920
tools to find python code

00:16:24,880 --> 00:16:29,199
corresponding to imports and very

00:16:27,920 --> 00:16:30,639
important tool that wants to match

00:16:29,199 --> 00:16:32,320
imports to source files

00:16:30,639 --> 00:16:34,639
is the build file generator i talked

00:16:32,320 --> 00:16:37,839
about earlier

00:16:34,639 --> 00:16:40,399
so previous to using bazel uh dropbox

00:16:37,839 --> 00:16:41,600
had a more complex python layout in our

00:16:40,399 --> 00:16:44,000
repository

00:16:41,600 --> 00:16:45,600
um and in order to achieve the structure

00:16:44,000 --> 00:16:47,839
of only having one entry in the python

00:16:45,600 --> 00:16:49,519
path we had to move a lot of code around

00:16:47,839 --> 00:16:51,440
but we're really glad we'd do it we did

00:16:49,519 --> 00:16:53,279
it though because

00:16:51,440 --> 00:16:55,440
it really helps with clarity in the code

00:16:53,279 --> 00:16:57,600
base

00:16:55,440 --> 00:16:59,759
another assumption of our rules is that

00:16:57,600 --> 00:17:01,680
there will be only one version

00:16:59,759 --> 00:17:02,880
of a third party dependency in our tree

00:17:01,680 --> 00:17:04,720
at a time

00:17:02,880 --> 00:17:06,079
again this is partially to support build

00:17:04,720 --> 00:17:07,600
file generation

00:17:06,079 --> 00:17:09,679
because if there's only one version of a

00:17:07,600 --> 00:17:10,720
third party package there's no ambiguity

00:17:09,679 --> 00:17:14,400
in resolving

00:17:10,720 --> 00:17:15,120
imports to it this so-called one version

00:17:14,400 --> 00:17:17,360
policy

00:17:15,120 --> 00:17:19,120
also has merits on its own it prevents

00:17:17,360 --> 00:17:20,959
diamond dependencies from arising

00:17:19,120 --> 00:17:23,679
and it makes auditing for security

00:17:20,959 --> 00:17:26,319
issues easier

00:17:23,679 --> 00:17:28,240
lastly we prefer to build third party

00:17:26,319 --> 00:17:30,400
packages from source

00:17:28,240 --> 00:17:31,360
this gives us control over dependency

00:17:30,400 --> 00:17:33,039
versions

00:17:31,360 --> 00:17:35,360
and ensures we are never stuck with a

00:17:33,039 --> 00:17:37,840
binary blob that doesn't work on a newer

00:17:35,360 --> 00:17:39,440
operating system or compiler

00:17:37,840 --> 00:17:40,960
it's more work upfront definitely to

00:17:39,440 --> 00:17:43,840
compile from source

00:17:40,960 --> 00:17:44,640
but the peace of mind it produces is

00:17:43,840 --> 00:17:47,760
worthwhile

00:17:44,640 --> 00:17:49,440
in our view and experience so there

00:17:47,760 --> 00:17:52,960
exist workarounds available

00:17:49,440 --> 00:17:54,160
to subvert all these guidelines but

00:17:52,960 --> 00:17:56,559
our python rules are definitely

00:17:54,160 --> 00:17:57,440
streamlined for code bases that conform

00:17:56,559 --> 00:18:00,720
to

00:17:57,440 --> 00:18:02,160
these suggestions the dbx build tools

00:18:00,720 --> 00:18:04,480
python roles have been stable for

00:18:02,160 --> 00:18:06,880
several years now under heavy use

00:18:04,480 --> 00:18:08,080
but as it is the way with software there

00:18:06,880 --> 00:18:11,840
are improvements to be made

00:18:08,080 --> 00:18:14,480
and bugs to be fixed let's discuss a few

00:18:11,840 --> 00:18:16,559
firstly we could use better

00:18:14,480 --> 00:18:18,880
cross-platform support

00:18:16,559 --> 00:18:20,320
our roles have had the most battle

00:18:18,880 --> 00:18:21,760
testing and we've had the most

00:18:20,320 --> 00:18:24,640
experience using them

00:18:21,760 --> 00:18:26,080
on server-side linux in the last year

00:18:24,640 --> 00:18:28,559
we've begun working on supporting

00:18:26,080 --> 00:18:30,080
a mac os and windows primary for our

00:18:28,559 --> 00:18:32,160
client applications

00:18:30,080 --> 00:18:33,679
but there's a lot more work to do to

00:18:32,160 --> 00:18:34,400
bring them to parity with linux in

00:18:33,679 --> 00:18:35,919
particular

00:18:34,400 --> 00:18:37,440
we don't support hermetic python

00:18:35,919 --> 00:18:41,200
interpreters on windows

00:18:37,440 --> 00:18:42,000
or mac os secondly we'd like to explore

00:18:41,200 --> 00:18:43,760
other distribution

00:18:42,000 --> 00:18:45,280
mechanisms for binaries the

00:18:43,760 --> 00:18:47,039
self-contained run files tree with a

00:18:45,280 --> 00:18:47,440
hermetic python interpreter works fairly

00:18:47,039 --> 00:18:50,240
well

00:18:47,440 --> 00:18:51,840
on server-side linux but a single file

00:18:50,240 --> 00:18:53,440
executable could be better for other

00:18:51,840 --> 00:18:54,400
operating systems and distribution

00:18:53,440 --> 00:18:56,720
channels

00:18:54,400 --> 00:18:57,679
a major difficulty here is a lot of

00:18:56,720 --> 00:19:00,160
python code

00:18:57,679 --> 00:19:01,200
both first and third party assumes it is

00:19:00,160 --> 00:19:04,559
installed

00:19:01,200 --> 00:19:06,160
directly on a file system lastly

00:19:04,559 --> 00:19:07,840
there are upcoming challenges in the

00:19:06,160 --> 00:19:09,679
python ecosystem

00:19:07,840 --> 00:19:11,520
historically python packages have done

00:19:09,679 --> 00:19:13,280
all their building through dist utils

00:19:11,520 --> 00:19:16,000
or as third-party replacement setup

00:19:13,280 --> 00:19:17,600
tools disk details and setup tools have

00:19:16,000 --> 00:19:19,600
had long-standing problems

00:19:17,600 --> 00:19:21,360
so releasing recently python packaging

00:19:19,600 --> 00:19:23,200
tools gain the ability to use completely

00:19:21,360 --> 00:19:27,760
different build back-ends

00:19:23,200 --> 00:19:30,000
using a system introduced by pep 517

00:19:27,760 --> 00:19:31,600
dbx build tools today is somewhat tied

00:19:30,000 --> 00:19:33,200
to dis details instead of tools

00:19:31,600 --> 00:19:36,000
implementation details

00:19:33,200 --> 00:19:36,559
uh for example it's quite subtle and

00:19:36,000 --> 00:19:38,400
delicate

00:19:36,559 --> 00:19:41,440
tasks to inject the right compiler and

00:19:38,400 --> 00:19:43,120
linger flags into them

00:19:41,440 --> 00:19:44,960
our python roles in the future will need

00:19:43,120 --> 00:19:45,679
to ensure that packages using new build

00:19:44,960 --> 00:19:47,679
back ends

00:19:45,679 --> 00:19:49,200
can be built as easily and hermetically

00:19:47,679 --> 00:19:51,520
as disutils project

00:19:49,200 --> 00:19:53,120
this may be particularly hard if new

00:19:51,520 --> 00:19:55,280
build back-ends don't provide the same

00:19:53,120 --> 00:19:57,120
configuration knobs as disutils and

00:19:55,280 --> 00:19:59,200
setup tools

00:19:57,120 --> 00:20:01,039
and that's all thank you very much for

00:19:59,200 --> 00:20:03,600
listening and your attention

00:20:01,039 --> 00:20:05,520
again here's a link to the dbx build

00:20:03,600 --> 00:20:08,640
tools project on github

00:20:05,520 --> 00:20:08,640
and we're looking forward to your

00:20:08,820 --> 00:20:14,789
[Music]

00:20:16,600 --> 00:20:19,600

YouTube URL: https://www.youtube.com/watch?v=BnYUn7slfgk


