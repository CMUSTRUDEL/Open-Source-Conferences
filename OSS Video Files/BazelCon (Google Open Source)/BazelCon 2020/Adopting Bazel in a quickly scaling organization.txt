Title: Adopting Bazel in a quickly scaling organization
Publication date: 2020-11-13
Playlist: BazelCon 2020
Description: 
	CarGurus is a rapidly growing software engineering organization. As we scaled, our build process degraded to the point where it had a heavy impact on productivity. Enter Bazel. We embarked on a journey to make our builds faster, easier to understand for our developers, more observable, and sustainable to the point where tech-debt (a.k.a. “dependency hell”) is handled up-front. 
Bazel is now rolled out in our org, and it has not only sped up our builds, but it serves as the core interface for how teams declare and orchestrate every part of their build and delivery process. In 10 months, I went from knowing next to nothing about the then pre-1.0 build tool to working with the Bazel community and our engineers to bring the best experience to CarGurus possible. 
We share key observations and pitfalls we encountered while trying to move quickly.

Speaker: Charles Essien

Watch more:
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Charles Essien;
Captions: 
	00:00:01,040 --> 00:00:06,640
[Music]

00:00:06,000 --> 00:00:09,200
hi

00:00:06,640 --> 00:00:11,040
my name is charles ession i'm a software

00:00:09,200 --> 00:00:12,960
engineering lead at a small company

00:00:11,040 --> 00:00:13,679
called cargurus based out of cambridge

00:00:12,960 --> 00:00:15,040
mess

00:00:13,679 --> 00:00:17,279
and i'm here to tell you about our

00:00:15,040 --> 00:00:19,039
journey switching to bazel and leveling

00:00:17,279 --> 00:00:19,439
up our builds in a way that helped us

00:00:19,039 --> 00:00:22,080
solve

00:00:19,439 --> 00:00:23,840
some pretty big scaling issues before i

00:00:22,080 --> 00:00:25,119
dive in i want to share a little bit

00:00:23,840 --> 00:00:26,720
about cargurus

00:00:25,119 --> 00:00:28,160
we're on a mission to build the world's

00:00:26,720 --> 00:00:30,320
most trusted transparent

00:00:28,160 --> 00:00:32,079
automotive marketplace so as you can

00:00:30,320 --> 00:00:33,200
imagine there's a massive need to

00:00:32,079 --> 00:00:34,800
provide the best

00:00:33,200 --> 00:00:36,800
most relevant information to the

00:00:34,800 --> 00:00:38,719
consumer who we believe wants to

00:00:36,800 --> 00:00:40,480
understand more about their current or

00:00:38,719 --> 00:00:42,399
future daily driver

00:00:40,480 --> 00:00:44,719
as we're scaling up to iterate on new

00:00:42,399 --> 00:00:46,559
ideas cargurus is chartering a path for

00:00:44,719 --> 00:00:49,360
re-platforming our stack

00:00:46,559 --> 00:00:51,280
our code base does one thing really well

00:00:49,360 --> 00:00:53,199
inventory listings for cars

00:00:51,280 --> 00:00:54,800
connecting consumers interested in

00:00:53,199 --> 00:00:56,239
exploring their next vehicle

00:00:54,800 --> 00:00:58,640
with the lots that they can find their

00:00:56,239 --> 00:01:00,879
next car on looking at the car buying

00:00:58,640 --> 00:01:03,120
and maintaining experience holistically

00:01:00,879 --> 00:01:04,720
finding the lot on your car is just one

00:01:03,120 --> 00:01:05,760
small piece of the car shopping

00:01:04,720 --> 00:01:07,680
experience

00:01:05,760 --> 00:01:09,119
as many of you know there's still a high

00:01:07,680 --> 00:01:10,880
amount of friction for the average

00:01:09,119 --> 00:01:13,280
consumer throughout researching

00:01:10,880 --> 00:01:14,400
purchasing selling and maintaining

00:01:13,280 --> 00:01:16,159
vehicles

00:01:14,400 --> 00:01:17,920
re-platforming is going to help us

00:01:16,159 --> 00:01:19,360
transition from a system that serves us

00:01:17,920 --> 00:01:21,759
well for that one thing

00:01:19,360 --> 00:01:22,479
car listings to something that helps us

00:01:21,759 --> 00:01:24,320
move quickly

00:01:22,479 --> 00:01:26,400
iterating on new products and new

00:01:24,320 --> 00:01:28,880
features that look nothing like it

00:01:26,400 --> 00:01:29,920
like peer-to-peer transactions or online

00:01:28,880 --> 00:01:32,159
financing

00:01:29,920 --> 00:01:33,360
my current role is leading a team called

00:01:32,159 --> 00:01:35,439
build and delivery

00:01:33,360 --> 00:01:36,479
we're tasked to significantly refine our

00:01:35,439 --> 00:01:38,720
ci systems

00:01:36,479 --> 00:01:40,880
and delivery process as we scale to add

00:01:38,720 --> 00:01:41,920
more engineers and focus on moving

00:01:40,880 --> 00:01:44,079
quickly

00:01:41,920 --> 00:01:46,560
as you can imagine the task of refining

00:01:44,079 --> 00:01:48,479
a ci system or really changing it at all

00:01:46,560 --> 00:01:49,520
to make the developer experience better

00:01:48,479 --> 00:01:51,840
for everyone

00:01:49,520 --> 00:01:53,759
can be a bit daunting i've been in this

00:01:51,840 --> 00:01:54,399
role for almost a year now and when i

00:01:53,759 --> 00:01:56,240
started

00:01:54,399 --> 00:01:58,880
i would say i knew just enough to

00:01:56,240 --> 00:02:00,479
execute builds and how to get code out

00:01:58,880 --> 00:02:02,399
i knew just enough about our build

00:02:00,479 --> 00:02:04,000
platform like every other engineer

00:02:02,399 --> 00:02:05,360
joining us also knows

00:02:04,000 --> 00:02:07,520
and had witnessed the cost and

00:02:05,360 --> 00:02:08,080
complexity of the scaling issues that

00:02:07,520 --> 00:02:09,840
can come

00:02:08,080 --> 00:02:12,080
from not tending to the build process

00:02:09,840 --> 00:02:13,360
over time i'll talk more about these

00:02:12,080 --> 00:02:16,000
issues later

00:02:13,360 --> 00:02:18,000
it wasn't until 2018 that i thought that

00:02:16,000 --> 00:02:20,640
build systems for statically typed

00:02:18,000 --> 00:02:22,640
compiled languages were largely the same

00:02:20,640 --> 00:02:24,800
feature complete not much left to

00:02:22,640 --> 00:02:28,000
optimize and make more efficient

00:02:24,800 --> 00:02:31,440
but in a 2017 google cloud next demo

00:02:28,000 --> 00:02:33,120
kelsey hightower implied that it's 2017

00:02:31,440 --> 00:02:34,959
and developers shouldn't have to build

00:02:33,120 --> 00:02:36,879
on their laptops anymore

00:02:34,959 --> 00:02:39,200
he didn't really elaborate and he was

00:02:36,879 --> 00:02:40,879
focused on a non-build centric demo

00:02:39,200 --> 00:02:42,800
but it wasn't until that point that i

00:02:40,879 --> 00:02:45,120
realized that i hadn't really considered

00:02:42,800 --> 00:02:47,200
what much larger code bases did

00:02:45,120 --> 00:02:48,800
to manage build sanely other than

00:02:47,200 --> 00:02:50,720
modularization

00:02:48,800 --> 00:02:52,800
and it wasn't until i started to work

00:02:50,720 --> 00:02:54,720
with bazel nearly a year later that i

00:02:52,800 --> 00:02:55,440
started to process what efficient builds

00:02:54,720 --> 00:02:58,239
really meant

00:02:55,440 --> 00:02:58,560
at scale and also realizing the benefits

00:02:58,239 --> 00:03:01,360
for

00:02:58,560 --> 00:03:04,319
organizations of any size by investing

00:03:01,360 --> 00:03:06,959
in modernizing your build architecture

00:03:04,319 --> 00:03:08,720
see much like kubernetes i believe bazel

00:03:06,959 --> 00:03:10,480
flips the notion of a typical build

00:03:08,720 --> 00:03:12,480
system on its head

00:03:10,480 --> 00:03:14,800
bazel strikes a great balance between

00:03:12,480 --> 00:03:16,319
having an opinionated process that you

00:03:14,800 --> 00:03:18,480
need to prescribe to

00:03:16,319 --> 00:03:20,000
like the build files directed acyclic

00:03:18,480 --> 00:03:21,120
graph and lack of transitive

00:03:20,000 --> 00:03:23,200
dependencies

00:03:21,120 --> 00:03:26,159
and yet being extensible enough to make

00:03:23,200 --> 00:03:28,400
the rules that do the work for you

00:03:26,159 --> 00:03:30,000
also like kubernetes one shouldn't

00:03:28,400 --> 00:03:32,879
simply switch to bazel

00:03:30,000 --> 00:03:35,040
in a large organization on a whim at

00:03:32,879 --> 00:03:37,840
least for us it required strategy

00:03:35,040 --> 00:03:40,319
building teaching learning and adopting

00:03:37,840 --> 00:03:42,319
the best of the bazel ecosystem

00:03:40,319 --> 00:03:44,400
if you're considering a switch for your

00:03:42,319 --> 00:03:45,120
organization i'm hoping this talk

00:03:44,400 --> 00:03:47,360
provides

00:03:45,120 --> 00:03:49,519
data points and at least useful

00:03:47,360 --> 00:03:52,799
anecdotal insight into what worked well

00:03:49,519 --> 00:03:55,120
for us at cargurus and what didn't

00:03:52,799 --> 00:03:55,840
tech de exists in modern software-based

00:03:55,120 --> 00:03:57,840
systems

00:03:55,840 --> 00:04:00,239
most of them it's a well-understood

00:03:57,840 --> 00:04:02,560
concept in our industry

00:04:00,239 --> 00:04:04,080
however russ miles with his stopping

00:04:02,560 --> 00:04:06,400
grounds being from pivotal

00:04:04,080 --> 00:04:08,799
and currently ceo of chaos iq and a

00:04:06,400 --> 00:04:10,640
pioneer in the chaos engineering space

00:04:08,799 --> 00:04:12,319
asserts that there's a not much talked

00:04:10,640 --> 00:04:15,439
about form of tech tet

00:04:12,319 --> 00:04:17,600
called dark ominous i know

00:04:15,439 --> 00:04:18,880
but if dark debt is the measurable range

00:04:17,600 --> 00:04:20,479
of known unknowns

00:04:18,880 --> 00:04:23,120
or things that we know we'll have to

00:04:20,479 --> 00:04:24,880
improve upon then dark debt represents

00:04:23,120 --> 00:04:27,199
the deep architectural flaws

00:04:24,880 --> 00:04:28,080
in a system that are hard to predict or

00:04:27,199 --> 00:04:30,800
observe

00:04:28,080 --> 00:04:31,759
until they happen the term is typically

00:04:30,800 --> 00:04:33,759
used to describe

00:04:31,759 --> 00:04:34,800
architectural flaws in production

00:04:33,759 --> 00:04:36,960
systems

00:04:34,800 --> 00:04:38,400
but i think dark debt plays a major role

00:04:36,960 --> 00:04:41,600
behind build systems

00:04:38,400 --> 00:04:44,240
and build patterns over time

00:04:41,600 --> 00:04:44,720
pre-bazel cargurus was experiencing

00:04:44,240 --> 00:04:47,680
several

00:04:44,720 --> 00:04:48,960
unsustainable build anti-patterns all

00:04:47,680 --> 00:04:50,960
problems that got worse

00:04:48,960 --> 00:04:52,240
as we added more engineers to the same

00:04:50,960 --> 00:04:55,440
code base

00:04:52,240 --> 00:04:57,120
our monorepo is primarily 1.2 million

00:04:55,440 --> 00:04:59,360
lines of java code

00:04:57,120 --> 00:05:01,039
we observed class issues with multiple

00:04:59,360 --> 00:05:02,080
jar versions ending up in the same

00:05:01,039 --> 00:05:04,639
artifact

00:05:02,080 --> 00:05:06,880
our monorepo made it too easy to include

00:05:04,639 --> 00:05:09,600
packages and dependencies transitively

00:05:06,880 --> 00:05:10,240
in monolithic artifacts copying and

00:05:09,600 --> 00:05:12,320
pasting

00:05:10,240 --> 00:05:14,560
module declarations without strong

00:05:12,320 --> 00:05:15,680
governance leads to hard to understand

00:05:14,560 --> 00:05:18,960
interdependencies

00:05:15,680 --> 00:05:20,560
across modules and packages we also

00:05:18,960 --> 00:05:22,639
observed incorrect builds that would

00:05:20,560 --> 00:05:24,800
compromise our developer sanity

00:05:22,639 --> 00:05:25,919
and finally build times were both

00:05:24,800 --> 00:05:29,039
ballooning

00:05:25,919 --> 00:05:31,120
and locally and in ci ultimately

00:05:29,039 --> 00:05:33,919
you can see where this is going the most

00:05:31,120 --> 00:05:35,919
empathic sobering and motivating problem

00:05:33,919 --> 00:05:37,360
my team owned was that our builds

00:05:35,919 --> 00:05:39,039
couldn't be trusted

00:05:37,360 --> 00:05:40,880
and builds you can't trust are

00:05:39,039 --> 00:05:44,479
frustrating and slow you down

00:05:40,880 --> 00:05:46,880
unnecessarily in order for cargurus to

00:05:44,479 --> 00:05:48,880
scale we need to undercut this debt

00:05:46,880 --> 00:05:50,960
our system has by either dramatically

00:05:48,880 --> 00:05:51,520
refactoring and cleaning up our utility

00:05:50,960 --> 00:05:54,800
scripts

00:05:51,520 --> 00:05:55,600
and systems on top of maven or rethink

00:05:54,800 --> 00:05:57,440
the problems

00:05:55,600 --> 00:06:00,560
and the solutions we're using to solve

00:05:57,440 --> 00:06:02,160
them we liked and we chose bazel because

00:06:00,560 --> 00:06:04,240
a lot of these problems we were facing

00:06:02,160 --> 00:06:05,360
had solutions we could adopt natively

00:06:04,240 --> 00:06:07,759
within bazel

00:06:05,360 --> 00:06:09,039
in best practices automated governance

00:06:07,759 --> 00:06:10,800
that would naturally prevent

00:06:09,039 --> 00:06:13,840
issues on the builds closest to the

00:06:10,800 --> 00:06:15,759
developer before even hitting ci

00:06:13,840 --> 00:06:17,759
with its dependency analysis-centric

00:06:15,759 --> 00:06:20,080
model bazel puts a lot of the would-be

00:06:17,759 --> 00:06:22,080
tech debt on the team who owns the code

00:06:20,080 --> 00:06:24,639
and minimizes the need for a centralized

00:06:22,080 --> 00:06:27,120
team like ours to manually intervene

00:06:24,639 --> 00:06:29,039
with how we share code while growing

00:06:27,120 --> 00:06:31,199
with reproducible builds the same

00:06:29,039 --> 00:06:33,120
feedback you get in ci could be run and

00:06:31,199 --> 00:06:35,199
caught before the commit

00:06:33,120 --> 00:06:36,560
and of course choosing bazel allows us

00:06:35,199 --> 00:06:38,560
to simplify

00:06:36,560 --> 00:06:40,800
my favorite part about choosing bazel is

00:06:38,560 --> 00:06:42,560
how much code we would get to rip out

00:06:40,800 --> 00:06:44,800
and how little code we would need to

00:06:42,560 --> 00:06:45,440
compose in-house to make bazel work for

00:06:44,800 --> 00:06:48,160
us

00:06:45,440 --> 00:06:49,520
minimizing our potential for dectet

00:06:48,160 --> 00:06:50,880
choosing a tool that allows you to

00:06:49,520 --> 00:06:52,720
delete in-house code

00:06:50,880 --> 00:06:54,880
while making your organization more

00:06:52,720 --> 00:06:55,520
efficient really is the most satisfying

00:06:54,880 --> 00:06:57,520
form

00:06:55,520 --> 00:06:59,360
of writing a team out of existence a

00:06:57,520 --> 00:07:01,440
team like mine

00:06:59,360 --> 00:07:03,440
tech that aside we wanted to make it

00:07:01,440 --> 00:07:04,000
super simple for developers to quickly

00:07:03,440 --> 00:07:06,800
compose

00:07:04,000 --> 00:07:09,039
new independent libraries bazel's build

00:07:06,800 --> 00:07:10,160
files and starlark make for really great

00:07:09,039 --> 00:07:12,479
readability

00:07:10,160 --> 00:07:14,400
paired with easy build file composition

00:07:12,479 --> 00:07:16,800
bazel's package visibility system

00:07:14,400 --> 00:07:19,840
is a really great option for safely

00:07:16,800 --> 00:07:21,520
reusing code within a monorepo

00:07:19,840 --> 00:07:23,440
there should be a term for that initial

00:07:21,520 --> 00:07:24,720
moment when an org completes a switch

00:07:23,440 --> 00:07:26,800
over to bazel

00:07:24,720 --> 00:07:28,400
that moment when theory is witnessed in

00:07:26,800 --> 00:07:31,360
practice and it just kind of

00:07:28,400 --> 00:07:32,720
works i mean theory is one thing but

00:07:31,360 --> 00:07:33,680
seeing the language agnostic

00:07:32,720 --> 00:07:35,120
deterministic

00:07:33,680 --> 00:07:37,440
incremental build system have a

00:07:35,120 --> 00:07:38,560
significant impact on the overall cost

00:07:37,440 --> 00:07:40,560
of building code

00:07:38,560 --> 00:07:42,400
is a completely different thing i've

00:07:40,560 --> 00:07:44,560
seen this moment referred to in the pr

00:07:42,400 --> 00:07:46,639
as the promised land of the past but i'm

00:07:44,560 --> 00:07:48,879
suggesting basilization

00:07:46,639 --> 00:07:50,960
in achieving basalization we managed to

00:07:48,879 --> 00:07:54,160
switch over to a much cleaner dag

00:07:50,960 --> 00:07:56,080
of dependencies we switched over 230

00:07:54,160 --> 00:07:57,599
plus artifacts to be built with basil

00:07:56,080 --> 00:07:59,520
within our mono repo

00:07:57,599 --> 00:08:01,440
and we're currently using a mostly

00:07:59,520 --> 00:08:02,400
hermetic tool chain for reproducible

00:08:01,440 --> 00:08:04,639
builds

00:08:02,400 --> 00:08:06,960
we also operate a self-hosted remote

00:08:04,639 --> 00:08:09,120
execution service powered by buildbarn

00:08:06,960 --> 00:08:11,120
in kubernetes

00:08:09,120 --> 00:08:13,680
where our maven build times to produce a

00:08:11,120 --> 00:08:15,360
correct build took upwards of 18 minutes

00:08:13,680 --> 00:08:17,199
on a developer laptop

00:08:15,360 --> 00:08:18,879
we managed to get bazel incremental

00:08:17,199 --> 00:08:21,120
builds down to eight minutes

00:08:18,879 --> 00:08:22,240
without a shared remote cache with

00:08:21,120 --> 00:08:24,400
remote caching

00:08:22,240 --> 00:08:25,680
and remote execution configured to build

00:08:24,400 --> 00:08:27,759
without the bytes

00:08:25,680 --> 00:08:29,120
our average incremental builds on our

00:08:27,759 --> 00:08:31,919
legacy artifacts

00:08:29,120 --> 00:08:33,760
in our code base is around 90 seconds

00:08:31,919 --> 00:08:34,880
while the worst case is around five and

00:08:33,760 --> 00:08:37,839
a half minutes

00:08:34,880 --> 00:08:39,599
down from 18. our elapsed build time

00:08:37,839 --> 00:08:40,080
typically lines up nicely with our

00:08:39,599 --> 00:08:42,240
critical

00:08:40,080 --> 00:08:43,919
path meaning we've right-sized our

00:08:42,240 --> 00:08:46,240
remote execution system

00:08:43,919 --> 00:08:47,680
to build code nearly as efficiently as

00:08:46,240 --> 00:08:49,519
possible

00:08:47,680 --> 00:08:51,360
and what i'm most excited about is the

00:08:49,519 --> 00:08:52,720
leverage for action we now have on

00:08:51,360 --> 00:08:54,480
future improvements

00:08:52,720 --> 00:08:56,160
i'll speak a little bit more to it at

00:08:54,480 --> 00:08:57,760
the end of this presentation

00:08:56,160 --> 00:08:59,680
but we have a lot more we can do

00:08:57,760 --> 00:09:00,720
iteratively to improve our build times

00:08:59,680 --> 00:09:02,880
even further

00:09:00,720 --> 00:09:03,760
and simplify our developers lives even

00:09:02,880 --> 00:09:06,080
more

00:09:03,760 --> 00:09:07,920
this project was two years in the making

00:09:06,080 --> 00:09:09,760
and like to take a brief moment to make

00:09:07,920 --> 00:09:12,320
a shout out to all the contributors

00:09:09,760 --> 00:09:14,320
who made it happen a few have moved on

00:09:12,320 --> 00:09:16,480
to different teams and organizations and

00:09:14,320 --> 00:09:19,040
i want to thank everyone for being part

00:09:16,480 --> 00:09:21,200
of basalization at cargurus

00:09:19,040 --> 00:09:22,880
all this said getting to the point where

00:09:21,200 --> 00:09:24,959
a switchover was possible

00:09:22,880 --> 00:09:26,160
required a lot of predictable steps in

00:09:24,959 --> 00:09:28,160
our strategy

00:09:26,160 --> 00:09:30,640
integration with ci for feedback

00:09:28,160 --> 00:09:32,800
exposing the tool for developers to try

00:09:30,640 --> 00:09:33,839
configuring our tool chain so bazel will

00:09:32,800 --> 00:09:36,000
understand it

00:09:33,839 --> 00:09:38,560
and adding and developing rules in

00:09:36,000 --> 00:09:41,279
macros we need to compose our builds

00:09:38,560 --> 00:09:42,959
but in retrospect there are three major

00:09:41,279 --> 00:09:45,519
challenge areas we face trying to get

00:09:42,959 --> 00:09:47,120
bazel in the hands of our developers

00:09:45,519 --> 00:09:50,399
the first was cleaning up our java

00:09:47,120 --> 00:09:52,560
dependency graph our palm.xml files

00:09:50,399 --> 00:09:54,480
don't correctly describe the intent of

00:09:52,560 --> 00:09:56,320
our builds in attempting to build with

00:09:54,480 --> 00:09:58,160
basal exposed conflicts

00:09:56,320 --> 00:10:00,240
transit of dependencies cyclic

00:09:58,160 --> 00:10:02,160
dependencies and duplicate dependencies

00:10:00,240 --> 00:10:04,079
that spanned multiple versions in our

00:10:02,160 --> 00:10:06,560
monolithic artifacts

00:10:04,079 --> 00:10:08,720
a directed acyclic graph is a strong

00:10:06,560 --> 00:10:10,800
prerequisite to really make bazel work

00:10:08,720 --> 00:10:11,600
so we had to invest a lot of needed time

00:10:10,800 --> 00:10:13,600
and effort

00:10:11,600 --> 00:10:15,040
to carefully cleaning up our production

00:10:13,600 --> 00:10:16,640
maven artifacts

00:10:15,040 --> 00:10:19,040
working with developers across

00:10:16,640 --> 00:10:20,959
functional areas in our organization

00:10:19,040 --> 00:10:22,320
to better understand the intent behind

00:10:20,959 --> 00:10:24,079
dependencies

00:10:22,320 --> 00:10:26,240
i believe that the effort spent cleaning

00:10:24,079 --> 00:10:26,800
up the dependency graph alone was worth

00:10:26,240 --> 00:10:29,040
it

00:10:26,800 --> 00:10:30,640
but it was definitely unexpected that

00:10:29,040 --> 00:10:32,480
the initial lack of a strong

00:10:30,640 --> 00:10:34,640
understanding of your dependencies will

00:10:32,480 --> 00:10:35,920
only slow down a transition

00:10:34,640 --> 00:10:38,800
and will eventually need to be

00:10:35,920 --> 00:10:40,720
reconciled at least in java

00:10:38,800 --> 00:10:42,800
secondly we realized that the failure

00:10:40,720 --> 00:10:44,560
modes with builds were pretty confusing

00:10:42,800 --> 00:10:47,120
for our developers because

00:10:44,560 --> 00:10:48,079
incremental builds remote caching this

00:10:47,120 --> 00:10:50,560
local caching

00:10:48,079 --> 00:10:51,279
abstracted as remote caching and remote

00:10:50,560 --> 00:10:53,600
execution

00:10:51,279 --> 00:10:55,200
are rather nebulous concepts compared to

00:10:53,600 --> 00:10:58,000
what our organization was

00:10:55,200 --> 00:11:00,000
used to so when something does go wrong

00:10:58,000 --> 00:11:02,880
with the builds our developers are left

00:11:00,000 --> 00:11:03,839
guessing often running unnecessary clean

00:11:02,880 --> 00:11:05,839
builds

00:11:03,839 --> 00:11:07,920
for example if a developer can't

00:11:05,839 --> 00:11:08,720
communicate with the build event service

00:11:07,920 --> 00:11:11,360
to upload

00:11:08,720 --> 00:11:13,440
metrics in bazel the build technically

00:11:11,360 --> 00:11:14,079
completes successfully but returns a

00:11:13,440 --> 00:11:16,800
non-zero

00:11:14,079 --> 00:11:18,320
exit code with verbose texts there's a

00:11:16,800 --> 00:11:20,480
learning curve to bazel

00:11:18,320 --> 00:11:22,000
and we factored most of it into a series

00:11:20,480 --> 00:11:24,800
of workshops we did

00:11:22,000 --> 00:11:27,200
about the operational aspects and rules

00:11:24,800 --> 00:11:29,600
we use to help developers ramp up

00:11:27,200 --> 00:11:30,560
we also attempted to document as much as

00:11:29,600 --> 00:11:32,640
we could

00:11:30,560 --> 00:11:34,000
documenting and linking to upstream

00:11:32,640 --> 00:11:36,959
bazel documentation

00:11:34,000 --> 00:11:38,880
about caching fundamentals really helps

00:11:36,959 --> 00:11:41,040
we also created a placebo effect of

00:11:38,880 --> 00:11:42,000
sorts by changing our build scripts to

00:11:41,040 --> 00:11:44,640
print warnings

00:11:42,000 --> 00:11:45,920
and in some cases not actually run the

00:11:44,640 --> 00:11:48,959
developer requested

00:11:45,920 --> 00:11:50,959
clean build command in clean builds one

00:11:48,959 --> 00:11:52,800
of the biggest challenges by far

00:11:50,959 --> 00:11:54,959
was the fact that in order to realize

00:11:52,800 --> 00:11:58,000
the benefits of a correct build

00:11:54,959 --> 00:12:00,160
developers have to trust them

00:11:58,000 --> 00:12:01,040
our monolith at cargurus has costly

00:12:00,160 --> 00:12:03,519
startup times

00:12:01,040 --> 00:12:04,720
so as i pointed out before the cost of

00:12:03,519 --> 00:12:07,279
an incorrect build

00:12:04,720 --> 00:12:08,560
magnified the frustrations and time loss

00:12:07,279 --> 00:12:10,560
for developers

00:12:08,560 --> 00:12:12,720
even worse if our tightly coupled

00:12:10,560 --> 00:12:15,040
monolith failed to start up or execute

00:12:12,720 --> 00:12:17,440
correctly after developers change

00:12:15,040 --> 00:12:19,200
they can no longer reasonably assume

00:12:17,440 --> 00:12:21,279
that it was just their code

00:12:19,200 --> 00:12:23,360
as a preventative measure to mitigate

00:12:21,279 --> 00:12:25,680
incorrect builds on maven

00:12:23,360 --> 00:12:27,200
developers often stuck to using clean

00:12:25,680 --> 00:12:29,519
builds to circumvent

00:12:27,200 --> 00:12:31,920
any potential issues relieving their

00:12:29,519 --> 00:12:32,959
sanity at the cost of build performance

00:12:31,920 --> 00:12:34,800
and time

00:12:32,959 --> 00:12:36,000
switching to bazel was problematic

00:12:34,800 --> 00:12:38,079
because bazel has

00:12:36,000 --> 00:12:40,079
never really produced an incorrect build

00:12:38,079 --> 00:12:42,720
but the psychology around

00:12:40,079 --> 00:12:44,240
correct builds is still slowly changing

00:12:42,720 --> 00:12:45,519
and lagging behind the initial

00:12:44,240 --> 00:12:48,079
switchover

00:12:45,519 --> 00:12:48,959
startup times still come at a cost so

00:12:48,079 --> 00:12:51,200
when a server

00:12:48,959 --> 00:12:53,519
incorrectly starts up occasionally

00:12:51,200 --> 00:12:55,519
developers attempt to clean build

00:12:53,519 --> 00:12:56,959
ultimately producing the same results

00:12:55,519 --> 00:12:58,240
and wasting time

00:12:56,959 --> 00:13:00,079
we're still working through this

00:12:58,240 --> 00:13:00,880
challenge but so far repeated

00:13:00,079 --> 00:13:02,959
announcements

00:13:00,880 --> 00:13:05,120
and sharing case studies help build

00:13:02,959 --> 00:13:07,200
trust in the bazel builds

00:13:05,120 --> 00:13:09,120
if anything significantly speeding up

00:13:07,200 --> 00:13:11,120
the build process via bazel

00:13:09,120 --> 00:13:13,279
exposes the level of dark debt we have

00:13:11,120 --> 00:13:16,079
elsewhere in our developer experience

00:13:13,279 --> 00:13:17,360
something we aim to tackle next bazel's

00:13:16,079 --> 00:13:20,000
helping our organization

00:13:17,360 --> 00:13:21,839
shape how we share code in a big way

00:13:20,000 --> 00:13:22,959
there are four big things that we

00:13:21,839 --> 00:13:25,519
learned that i believe

00:13:22,959 --> 00:13:26,000
helped us in our transition the first

00:13:25,519 --> 00:13:28,959
being

00:13:26,000 --> 00:13:30,560
observability is key having a picture of

00:13:28,959 --> 00:13:32,639
what our build times look like

00:13:30,560 --> 00:13:34,079
across the various profiles developers

00:13:32,639 --> 00:13:36,320
care about in both

00:13:34,079 --> 00:13:38,079
maven and bazel helped us gather

00:13:36,320 --> 00:13:39,680
objective metrics we could use to

00:13:38,079 --> 00:13:42,240
confirm the theory of bazel

00:13:39,680 --> 00:13:44,480
actually makes a difference in practice

00:13:42,240 --> 00:13:46,480
we used a combination of bash scripts

00:13:44,480 --> 00:13:47,760
and the build event protocol to upload

00:13:46,480 --> 00:13:50,079
event durations about

00:13:47,760 --> 00:13:52,399
build metrics to our observability tools

00:13:50,079 --> 00:13:54,160
honeycomb and prometheus

00:13:52,399 --> 00:13:56,079
this help still helps us post switch

00:13:54,160 --> 00:13:57,920
over to understand trending metrics

00:13:56,079 --> 00:13:59,040
about performance and understand the

00:13:57,920 --> 00:14:01,839
value proposition

00:13:59,040 --> 00:14:03,440
further speeding up builds next choose a

00:14:01,839 --> 00:14:06,000
switch over strategy

00:14:03,440 --> 00:14:08,320
cargurus chose to run both build systems

00:14:06,000 --> 00:14:10,720
and ci for an extended period of time

00:14:08,320 --> 00:14:11,680
giving build feedback for both maven and

00:14:10,720 --> 00:14:13,519
bazel

00:14:11,680 --> 00:14:15,279
this gave us room to experiment and

00:14:13,519 --> 00:14:16,160
learn about the tool in a projection of

00:14:15,279 --> 00:14:17,920
the real world

00:14:16,160 --> 00:14:19,279
at the cost of having developers

00:14:17,920 --> 00:14:22,160
manually maintaining

00:14:19,279 --> 00:14:22,720
dependencies across the two systems not

00:14:22,160 --> 00:14:25,600
too great

00:14:22,720 --> 00:14:27,680
but an acceptable cost for us we also

00:14:25,600 --> 00:14:28,480
wanted to dramatically simplify our

00:14:27,680 --> 00:14:30,560
build scripts

00:14:28,480 --> 00:14:32,320
and put bazel at the front and center of

00:14:30,560 --> 00:14:33,760
build feedback for all stages of

00:14:32,320 --> 00:14:35,839
development

00:14:33,760 --> 00:14:37,040
in march we aim to roll out remote

00:14:35,839 --> 00:14:39,440
caching before

00:14:37,040 --> 00:14:41,360
remote execution using our on-premise

00:14:39,440 --> 00:14:43,600
high bandwidth network connection

00:14:41,360 --> 00:14:45,519
however due to the pandemic in the

00:14:43,600 --> 00:14:47,519
remote work from home situation

00:14:45,519 --> 00:14:49,519
we decided to pivot to using remote

00:14:47,519 --> 00:14:50,639
execution in a build without the bytes

00:14:49,519 --> 00:14:53,120
configuration

00:14:50,639 --> 00:14:54,959
to speed up builds in a meaningful way

00:14:53,120 --> 00:14:56,560
across a variety of work from home

00:14:54,959 --> 00:14:58,160
network connections

00:14:56,560 --> 00:15:00,720
i feel like this was the right strategy

00:14:58,160 --> 00:15:02,240
for us but unless switchovers become a

00:15:00,720 --> 00:15:04,480
repeatable process

00:15:02,240 --> 00:15:06,320
different orgs of different scales will

00:15:04,480 --> 00:15:08,399
have different strategies

00:15:06,320 --> 00:15:10,000
the most important thing to do is choose

00:15:08,399 --> 00:15:13,199
a strategy that respects

00:15:10,000 --> 00:15:15,199
how your developers currently work

00:15:13,199 --> 00:15:16,639
another key concept to focus on for

00:15:15,199 --> 00:15:19,360
getting the most out of bazel

00:15:16,639 --> 00:15:20,079
is the reproducibility of your builds

00:15:19,360 --> 00:15:22,160
bazel is

00:15:20,079 --> 00:15:23,440
mid transition to fully relying on the

00:15:22,160 --> 00:15:25,360
notion of platforms

00:15:23,440 --> 00:15:26,480
and tool chain resolution to resolve

00:15:25,360 --> 00:15:28,720
tool chains

00:15:26,480 --> 00:15:30,639
it's a powerful concept we were able to

00:15:28,720 --> 00:15:33,279
use to start providing reproducible

00:15:30,639 --> 00:15:35,759
tools for our compilation process

00:15:33,279 --> 00:15:38,160
having defined tools in your tool chain

00:15:35,759 --> 00:15:41,040
helps you be as hermetic as possible

00:15:38,160 --> 00:15:43,040
reducing incorrect uncashable builds and

00:15:41,040 --> 00:15:44,079
also helping simplify the development

00:15:43,040 --> 00:15:46,399
process

00:15:44,079 --> 00:15:48,720
for example at cargurus early into the

00:15:46,399 --> 00:15:50,639
switchover we observed a nasty caching

00:15:48,720 --> 00:15:52,959
issue with rules docker

00:15:50,639 --> 00:15:55,040
if docker isn't installed the first time

00:15:52,959 --> 00:15:57,279
retar ball has attempted to load into

00:15:55,040 --> 00:15:59,519
the docker daemon with bazel run

00:15:57,279 --> 00:16:01,519
rule's docker throws an error and bazel

00:15:59,519 --> 00:16:04,560
caches the tool chain resolution

00:16:01,519 --> 00:16:06,800
of the absence of docker this was easily

00:16:04,560 --> 00:16:08,480
fixed and can be avoided by explicitly

00:16:06,800 --> 00:16:11,040
defining the path to docker

00:16:08,480 --> 00:16:12,480
in bazel for every tool chain that we're

00:16:11,040 --> 00:16:14,800
not having bazel pull

00:16:12,480 --> 00:16:16,880
in the workspace file we use a custom

00:16:14,800 --> 00:16:18,240
checked in brew file for keeping tool

00:16:16,880 --> 00:16:21,360
chains in sync across

00:16:18,240 --> 00:16:23,199
development bazel docs have some really

00:16:21,360 --> 00:16:25,440
good guides that help you debug

00:16:23,199 --> 00:16:27,120
tool chain resolution in actions that

00:16:25,440 --> 00:16:28,240
produce different results in different

00:16:27,120 --> 00:16:30,480
environments

00:16:28,240 --> 00:16:31,600
getting this right means better caching

00:16:30,480 --> 00:16:34,079
for your devs

00:16:31,600 --> 00:16:35,600
unless it worked on my machine as you

00:16:34,079 --> 00:16:38,079
scale

00:16:35,600 --> 00:16:38,959
finally the bazel ecosystem is

00:16:38,079 --> 00:16:41,600
extensible

00:16:38,959 --> 00:16:44,160
and growing much like the ecosystem of

00:16:41,600 --> 00:16:46,399
tools and services around kubernetes

00:16:44,160 --> 00:16:47,600
services and rules around bazel are

00:16:46,399 --> 00:16:49,759
starting to emerge

00:16:47,600 --> 00:16:51,120
that really make the experience more

00:16:49,759 --> 00:16:53,519
delightful

00:16:51,120 --> 00:16:55,600
core rules we rely on are rules jvm

00:16:53,519 --> 00:16:56,800
external for pulling maven central

00:16:55,600 --> 00:16:59,279
dependencies

00:16:56,800 --> 00:17:01,839
gazelle for maintaining our go code and

00:16:59,279 --> 00:17:03,440
rules docker for our final artifacts

00:17:01,839 --> 00:17:04,880
we use salesforce's spring boot

00:17:03,440 --> 00:17:07,280
packaging for packaging

00:17:04,880 --> 00:17:09,360
spring boot and war files correctly and

00:17:07,280 --> 00:17:11,679
we're working through converting our 600

00:17:09,360 --> 00:17:12,959
000 plus lines of javascript to be built

00:17:11,679 --> 00:17:15,039
with bazel

00:17:12,959 --> 00:17:16,640
we self-host our own remote execution

00:17:15,039 --> 00:17:19,919
service internally

00:17:16,640 --> 00:17:22,640
thus far but by far my favorite new tool

00:17:19,919 --> 00:17:23,280
has been build buddy it's a tool that's

00:17:22,640 --> 00:17:25,039
helped us

00:17:23,280 --> 00:17:26,720
visualize and share the results of

00:17:25,039 --> 00:17:28,400
builds as they happen

00:17:26,720 --> 00:17:30,640
and it makes what's happening underneath

00:17:28,400 --> 00:17:32,720
the base with bazel super clear

00:17:30,640 --> 00:17:34,720
our developers love using buildbuddy to

00:17:32,720 --> 00:17:37,280
share a link of build results

00:17:34,720 --> 00:17:38,880
with us for help and even better build

00:17:37,280 --> 00:17:41,200
buddies expanding to support

00:17:38,880 --> 00:17:42,720
manage remote execution if you haven't

00:17:41,200 --> 00:17:44,080
tried it out yet i would highly

00:17:42,720 --> 00:17:46,720
recommend them

00:17:44,080 --> 00:17:48,960
external rules are great but you can and

00:17:46,720 --> 00:17:50,080
should create rules that work for you

00:17:48,960 --> 00:17:51,679
too

00:17:50,080 --> 00:17:53,120
we're currently working through creating

00:17:51,679 --> 00:17:55,679
rules that work for us

00:17:53,120 --> 00:17:56,960
in the systems that we use that don't

00:17:55,679 --> 00:17:59,120
exist yet

00:17:56,960 --> 00:18:00,320
after evaluating what's out there we're

00:17:59,120 --> 00:18:03,039
currently in the process

00:18:00,320 --> 00:18:04,640
of writing our own rules helm it's a lot

00:18:03,039 --> 00:18:06,720
like kubernetes

00:18:04,640 --> 00:18:08,160
except we use a helm-like setup for

00:18:06,720 --> 00:18:10,320
templating and values

00:18:08,160 --> 00:18:11,520
and we use bazel rules for injecting and

00:18:10,320 --> 00:18:14,240
controlling helm

00:18:11,520 --> 00:18:15,440
dependency management chart packaging in

00:18:14,240 --> 00:18:17,679
linting

00:18:15,440 --> 00:18:19,760
our rules will be used to enforce devops

00:18:17,679 --> 00:18:21,520
practices we care about at build time

00:18:19,760 --> 00:18:23,840
and it will allow us to do things like

00:18:21,520 --> 00:18:26,640
hook bazel test into helm test

00:18:23,840 --> 00:18:28,880
and helm lint for easy feedback we've

00:18:26,640 --> 00:18:30,799
also written our own take on scaffold a

00:18:28,880 --> 00:18:32,080
popular tool for iterating quickly on

00:18:30,799 --> 00:18:34,640
kubernetes

00:18:32,080 --> 00:18:36,480
scaffold is compatible with basil you

00:18:34,640 --> 00:18:38,720
can give it a bazel target and it will

00:18:36,480 --> 00:18:41,280
invoke bazel for you but our version

00:18:38,720 --> 00:18:43,200
integrates directly into bazel itself

00:18:41,280 --> 00:18:45,280
and does exactly what we need it to to

00:18:43,200 --> 00:18:47,039
bootstrap a development environment via

00:18:45,280 --> 00:18:48,720
bazel run commands

00:18:47,039 --> 00:18:50,240
we plan on using this process to

00:18:48,720 --> 00:18:52,400
interact directly with the remote

00:18:50,240 --> 00:18:54,640
execution protobuf api

00:18:52,400 --> 00:18:56,000
submitting custom orchestration actions

00:18:54,640 --> 00:18:58,320
to pull built images

00:18:56,000 --> 00:18:59,840
from the execution services content

00:18:58,320 --> 00:19:02,400
addressable storage

00:18:59,840 --> 00:19:03,840
directly and upload the image to a repo

00:19:02,400 --> 00:19:05,840
for deployment

00:19:03,840 --> 00:19:08,240
this will enable us to use bazel to run

00:19:05,840 --> 00:19:10,240
without any local artifacts

00:19:08,240 --> 00:19:11,919
the builds in orchestration happens

00:19:10,240 --> 00:19:14,240
completely remotely

00:19:11,919 --> 00:19:14,960
up next we want to approach build file

00:19:14,240 --> 00:19:17,200
generation

00:19:14,960 --> 00:19:18,480
in templating for new services

00:19:17,200 --> 00:19:20,320
minimizing the friction

00:19:18,480 --> 00:19:22,000
a developer experiences trying to get

00:19:20,320 --> 00:19:24,240
new code to production

00:19:22,000 --> 00:19:25,919
finally we're writing declarative rules

00:19:24,240 --> 00:19:28,559
for generating ci cd

00:19:25,919 --> 00:19:30,480
concourse based pipelines as code for

00:19:28,559 --> 00:19:32,640
new services and artifacts

00:19:30,480 --> 00:19:34,320
for better separation of concerns and

00:19:32,640 --> 00:19:36,240
team ownership

00:19:34,320 --> 00:19:38,000
put it all together and you can see what

00:19:36,240 --> 00:19:39,679
we're able to do with bazel over the

00:19:38,000 --> 00:19:41,600
course of just a year

00:19:39,679 --> 00:19:43,520
the bottom line is that we have a much

00:19:41,600 --> 00:19:44,720
more sane model for ownership and

00:19:43,520 --> 00:19:47,520
accountability

00:19:44,720 --> 00:19:49,039
when it comes to how we share code

00:19:47,520 --> 00:19:50,720
switching over to bazel

00:19:49,039 --> 00:19:52,400
was a great way to simplify our

00:19:50,720 --> 00:19:54,480
development process before

00:19:52,400 --> 00:19:56,480
our next big step towards splitting up

00:19:54,480 --> 00:19:57,840
our monolith and iterating on new

00:19:56,480 --> 00:20:00,720
products and features

00:19:57,840 --> 00:20:02,240
more quickly so thanks for listening i

00:20:00,720 --> 00:20:03,840
hope insight from our journey was

00:20:02,240 --> 00:20:04,720
valuable for those considering a

00:20:03,840 --> 00:20:07,120
switchover

00:20:04,720 --> 00:20:07,840
or changing their existing setup i'm

00:20:07,120 --> 00:20:09,919
happy to take

00:20:07,840 --> 00:20:12,590
any questions and dive down as deep as

00:20:09,919 --> 00:20:18,559
anyone would like

00:20:12,590 --> 00:20:18,559
[Music]

00:20:18,840 --> 00:20:23,440
thanks

00:20:21,360 --> 00:20:23,440

YouTube URL: https://www.youtube.com/watch?v=tgaM-5Oa938


